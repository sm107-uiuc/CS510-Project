{"url": "https://towardsdatascience.com/shortest-paths-and-dijkstras-algorithm-68c9ec30eff0", "time": 1683015448.1419399, "path": "towardsdatascience.com/shortest-paths-and-dijkstras-algorithm-68c9ec30eff0/", "webpage": {"metadata": {"title": "Shortest Paths and Dijkstra\u2019s Algorithm | by Shuo Wang | Towards Data Science", "h1": "Shortest Paths and Dijkstra\u2019s Algorithm", "description": "If I were given a graph of nodes, each node is connected to several other nodes and the connections are of varying distance, what is the shortest path to every node in the graph if I start from one\u2026"}, "outgoing_paragraph_urls": [{"url": "https://en.wikipedia.org/wiki/Fibonacci_heap", "anchor_text": "Fibonacci Heap", "paragraph_index": 31}], "all_paragraphs": ["A classic formulation of the problem would be:", "If I were given a graph of nodes, each node is connected to several other nodes and the connections are of varying distance, what is the shortest path to every node in the graph if I start from one of the nodes in the graph?", "In order to implement Dijkstra\u2019s algorithm we first need to define a node and an edge:", "In this case, I have defined a node that contains a value (an id basically), a distance initialized to be -1 (infinity). Additionally, the Node contains a list of edges, each is a tuple of the target node the edge connects to (from self) and the distance to the target node.", "So, how do I go about populating the shortest distance to each node in the graph from a starting node?", "Quite simple actually. At the start node, I update its distance to 0, and for each of the edges this node has, I recursively update the distance of the target node to be the distance of current node plus the edge distance, if the target node is unvisited (distance = -1) or the target node\u2019s current distance is greater than the new distance:", "Putting all of this together with an example graph:", "Now if I update the edge from node 2 to node 4's distance to 1, I should have node 4's shortest distance to now be 2, since now I can go from node 1 to 2, then 2 to 4, with a distance of 2. Let\u2019s see if this is the case:", "That wasn\u2019t too bad, was it?", "But let\u2019s pause for a second and think about how long this process takes.", "Starting at the start node, if the start node is connected to every other node, then the first loop in update_distance is O(n-1), where n is the number of nodes in the graph. Inside of the update_distance, we are recursively calling update_distance on the connected target node, in the worst case the target node might be connected to every other node as well, and only one edge is guaranteed to not be traversed (the edge with the current node), so second recursive update_distance is O(n-2).", "At this point, it\u2019s not hard to realize that the complexity of the overall algorithm is O((n-1) * (n-2) * \u2026 * 2 * 1) = O(n!) in the worst case. Not good.", "Looks like we have some improvements to make, and that\u2019s what Dijkstra\u2019s algorithm does.", "The algorithm can be understood from a very clever observation. In our graph 2 above, node 1 is connected to node 2, 3, 4 directly. and the minimum distance among them is the distance to node 2, which is 1. Now you know that the shortest distance to node 2 is at most 1, can it be any shorter than that? The answer is no because any indirect path from node 1 to node 2 will have to pass through either node 3 or node 4, both of which have a distance greater than 1.", "This is a very important insight because this means that after processing node 2, I don\u2019t ever have to look at node 2 again, knowing that the shortest distance to node 2 is just 1. This avoids the redundancy of checking the distance from node 1 to 3 to 2 since we know for sure that that distance will be larger than the distance we already have for node 2.", "In order to implement this, we employ a minimum heap data structure. The implementation of it can vary greatly, but the operations are simple, I can put any objects onto it, and when I ask the heap to return an object, it always returns the object with the minimum associated key.", "Here is an implementation of the Dijkstra\u2019s algorithm with min heap:", "Let\u2019s discuss a little bit regarding the performance of the new algorithm.", "Starting at the first node, we set its distance to zero and add it to the min heap with its current distance as the sort key. Then, as long as the min heap is not empty, continually pop off the node with the minimum key, loop through all of its connected nodes and update their shortest distance and push them onto the min heap if the new distance is a shorter distance.", "One important thing to pay attention to is the following lines in the loop:", "This checks if the key of the object on the heap is the same as the current shortest distance of the node. Consider the following situation:", "Start: push start node onto heap with distance 0", "Iteration 1: During the first iteration, the min heap contains node1 with key 0, it is then popped off and its neighbors added to the heap.", "Iteration 2: node2 is popped off and its neighbors added.", "Iteration 3: node3 is popped off and its neighbors added.", "But wait! node3\u2019s neighbor, node4, is already on the queue, the only difference is that its shortest distance is updated to 6 now:", "You see, there are actually two entries for node4 in the heap, one with key 6 and one with key 11, only one entry has the key equaling to the current node4\u2019s distance value.", "In the next iteration, the entry with key 6 is popped off since it\u2019s the minimum key, and its neighbors processed, but since its neighbors all have shortest distance already, they won\u2019t make it onto the queue. and only one entry is left:", "In this case, you will obviously want to ignore it, since node4 is processed already, and the way you can tell is that the key and the node4\u2019s shortest distance doesn\u2019t equal each other.", "With currently known implementations of min heap, pop function is an O(log(n)) operation. Since you\u2019ll push a node on to the heap if there is an edge, the complexity of the algorithm is O(e * log(n)) where e is the number of edges.", "Actually, there is a little bit more to it. What is the maximum number of edges you can have? Well if every node is connected to every other node, and there are n nodes in the graph, then the total number of edges is n * (n + 1) / 2. so e is actually on the order of O(n**2) and the algorithm is actually on the order of O((n ** 2) * log(n))", "But as you can see from the above example, where node4 is on the heap twice due to the two edges it has, if we can update the existing edge of 11 to 6, we don\u2019t actually have to add it twice. It just so happens that there is a particular type of heap that allows you to do that. It\u2019s called a Fibonacci Heap. In this case you can just decrease the key to 6 from 11 and only have node4 on the heap once, no matter how many edges are connected to it.", "The decrease key function in Fibonacci Heap is O(1), constant operation, so your overall complexity comes down to O(n*log(n) + e). The reason you add e is that you have to decrease key on the order of e times.", "Finally, if we think of the original min heap algorithm as having a decrease key functionality with a runtime of O(log(n)) (basically the time it takes to pop off node4 entry with key 11), the original algorithm complexity can be more precisely defined as O((n + e) * log(n)).", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Interesting pieces on various topics in finance and technology."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F68c9ec30eff0&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://r-shuo-wang.medium.com/?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": ""}, {"url": "https://r-shuo-wang.medium.com/?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": "Shuo Wang"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F693d095d5e0d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&user=Shuo+Wang&userId=693d095d5e0d&source=post_page-693d095d5e0d----68c9ec30eff0---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F68c9ec30eff0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F68c9ec30eff0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://en.wikipedia.org/wiki/Fibonacci_heap", "anchor_text": "Fibonacci Heap"}, {"url": "https://medium.com/tag/dijkstra?source=post_page-----68c9ec30eff0---------------dijkstra-----------------", "anchor_text": "Dijkstra"}, {"url": "https://medium.com/tag/python?source=post_page-----68c9ec30eff0---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/programming?source=post_page-----68c9ec30eff0---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/tag/algorithms?source=post_page-----68c9ec30eff0---------------algorithms-----------------", "anchor_text": "Algorithms"}, {"url": "https://medium.com/tag/graph?source=post_page-----68c9ec30eff0---------------graph-----------------", "anchor_text": "Graph"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F68c9ec30eff0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&user=Shuo+Wang&userId=693d095d5e0d&source=-----68c9ec30eff0---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F68c9ec30eff0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&user=Shuo+Wang&userId=693d095d5e0d&source=-----68c9ec30eff0---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F68c9ec30eff0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F68c9ec30eff0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----68c9ec30eff0---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----68c9ec30eff0--------------------------------", "anchor_text": ""}, {"url": "https://r-shuo-wang.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://r-shuo-wang.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Shuo Wang"}, {"url": "https://r-shuo-wang.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "273 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F693d095d5e0d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&user=Shuo+Wang&userId=693d095d5e0d&source=post_page-693d095d5e0d--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F74e98ddc277b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fshortest-paths-and-dijkstras-algorithm-68c9ec30eff0&newsletterV3=693d095d5e0d&newsletterV3Id=74e98ddc277b&user=Shuo+Wang&userId=693d095d5e0d&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}