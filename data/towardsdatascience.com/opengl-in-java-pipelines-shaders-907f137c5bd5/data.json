{"url": "https://towardsdatascience.com/opengl-in-java-pipelines-shaders-907f137c5bd5", "time": 1683003712.1210408, "path": "towardsdatascience.com/opengl-in-java-pipelines-shaders-907f137c5bd5/", "webpage": {"metadata": {"title": "OpenGL in Java: Pipelines & Shaders | by Mario Emmanuel | Towards Data Science", "h1": "OpenGL in Java: Pipelines & Shaders", "description": "In another article, I introduced OpenGL and briefly discussed why I chose Java, OpenGL and JOGL. I also presented a working example in Java which would be the equivalent to the first \u201cHello World\u201d\u2026"}, "outgoing_paragraph_urls": [{"url": "https://link.medium.com/mK7fHn3YS3", "anchor_text": "another article", "paragraph_index": 0}, {"url": "https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)#Vertex_shader_attribute_index", "anchor_text": "on the OpenGL specification page", "paragraph_index": 17}, {"url": "https://ieee.shortcm.li/OP8dFS", "anchor_text": "https://ieee.shortcm.li/OP8dFS", "paragraph_index": 35}], "all_paragraphs": ["In another article, I introduced OpenGL and briefly discussed why I chose Java, OpenGL and JOGL. I also presented a working example in Java which would be the equivalent to the first \u201cHello World\u201d program. The intended example was using old OpenGL syntax, which is easy to understand but not optimised. It is called the \u201cimmediate\u201d mode in OpenGL where the drawing commands are submitted directly to the GPU enclosed in glBegin and glEnd blocks.", "Since OpenGL 3.3, it is recommended to program OpenGL using what is known as the core language. In this mode, OpenGL is used through compiled GLSL programs which are called shaders. Those shaders are pipelined so we have a chained software flow to get our graphics rendered. The GLSL programs need to be compiled and are often stored in separate files in our source code, as they are a separate programming language on their own.", "When programming OpenGL, we are writing pipelined code for the GPU which will run in parallel. This implies that the way we code is different from a regular program. Routines need to be concise and stateless, as execution order is not known. Each pipeline stage operation can not rely on other operation from the same stage. Code must be also compiled and downloaded to the GPU, this is done in runtime.", "In this article, we will briefly explain how this pipeline works, how shaders are coded and how vertex coordinates are used. We will use those concepts to draw a square following the complete process. While the example is quite basic, the process reflects how OpenGL is programmed.", "Remember that this is not an exhaustive tutorial explaining every OpenGL concept but a material that I have gathered explaining the steps that I have found more complex while learning OpenGL. The focus is doing basic but complete examples which illustrate how to use OpenGL for 2D data visualisation applications. Do not worry if you are unsure on the scope of certain OpenGL keywords, focusing on getting the overall idea on how shaders and the pipeline work will make much easier to learn complementary material. The examples are prepared also to fill in gaps I have found in the most recommended learning materials (which I will revisit at the end of the tutorial series) and to stress on the areas which took me more time to solve.", "OpenGL is all about rendering basic shapes defined by their vertexes. If you want to model a 3D dinosaur, it will be likely shaped using really small triangles, so small that will appear to the human edge as a continuous texture.", "OpenGL will, therefore, transform sets of vertexes into actual rendered images, and it will do it using what is called shaders. For 2D, it is the same, we are just always drawing on the z=0 plane.", "In plain English, this is how it works:", "All shaders are defined and compiled (at runtime) for the graphics card GPU using GLSL language.", "The tessellation shader is an optional shader introduced in OpenGL 4 that allows to define and manipulate grids made up of a large number of triangles. It has been incorporated in OpenGL version 4 and it is intended to build things like 3D landscapes.", "In this example, we will use a vertex shader, a geometry shader and a fragment shader. The idea is that given a set of coordinates (vertexes) by the application, our GPU will draw squares centred on those coordinates and will draw them coloured as per their location in the window. This is a perfectly valid example which illustrates perfectly how to program OpenGL using \u201ccore\u201d mode.", "One thing that was novel for me was the concept of shaders being stateless. The idea behind the shaders is that they can be executed concurrently and in any order. This effectively enables to execute by the GPU a large number of shaders (each one processing one vertex/pixel) in parallel. This is the reason why fast response and renderization can be achieved even on high definition displays without affecting the CPU. As a trade-off every shader we code must be stateless and can not depend on other shaders. This implies that the way in which we code the shaders is slightly different from what we are used to do.", "Let\u2019s prepare a program to draw a pixel using a vertex shader and a fragment shader. We will first define the source code which will be allocated in a separate file, which is what you would likely want to do.", "Our vertex shader does nothing, it just passes the vertex point to the next shader, but it is still required.", "Let\u2019s analyse in detail the source code.", "The first line states that we are using OpenGL 3.3 core. We will code for 3.3 even if \u2014 at the time of writing this article \u2014 OpenGL has reached version 4.6. The reason for doing this is that 3.3 is the first one enforcing core programming and that by doing that we can use old Graphics Cards.", "The second line states that we are going to use an input layout variable which we will name it squareCenterPosition, the reason for this name is that in the next example we will use it as the centre of a square. For the moment, just bear in mind that it is just the position for an individual pixel.", "The layout clause allows qualifiers to be specified, which in this context defines which position we are using in the vertex matrix. The full specification about what layout qualifiers do can be read on the OpenGL specification page. Be prepared to always check the specification to clarify doubts about code examples.", "The variable is of type vec2 defines a two float vector. As we are dealing with 2D, we just need two points. More data could be provided if needed.", "The second block is the main function. OpenGL resembles C syntax in many aspects, so shaders will always have a \u201cmain\u201d function. In this function, we define the variable gl_Position which has a special meaning in OpenGL. It defines the final position of the vertex. In this case, we define a 4 float vector which includes the 3D coordinates plus a value used for projection. In our case Z coordinate is 0 and the projection value is hardcoded to 1.", "This is all we have to do in our vertex shader, which is turning an x/y location into a proper 4 float vector.", "The next shader is the geometry shader. This shader can manipulate vertexes and compute primitives. It is important to understand that GPUs manipulate basic primitives: points, lines and triangles. And that is all.", "As an example we will first provide a geometry shader which just generates 4 points around the vertex:", "For the geometry shader, we define layout clauses for both in and out data from the shader. In our shader, we are defining that for each point received we are delivering 4 points. It could be a different case (we will see an example later) and we could be delivering a triangle for each point.", "gl_Position is an OpenGL variable used to define the position of a vertex. In this case, we are defining it four times, one per each generated vertex. Notice how we get the input value (gl_in[0]) and translate it with an offset of 0.2 to build each point of our imaginary square. For each point, we invoke EmitVertex() and EndPrimitive() as we are generating 4 primitives of 1 vertex each (a point is still a primitive). Later we will generate four triangles in each location to further illustrate how geometry shaders work.", "Now that we have our pixel defined by the vertex shader, we will code our fragment shader, which again, it is a dumb routine which just draws the pixel in red colour (RGB 1,0,0). The code is as follows:", "Before moving forward into the actual JOGL implementation code let\u2019s revisit what are VAOs and VBOs in OpenGL. A VBO (Vertex Buffer Object) is a buffer stored in the Graphics Card memory which contains data to be operated by the shaders. Being allocated and stored inside the Graphics Card it is much faster than moving data back and forth from the CPU. The idea is that we load those buffers with the rendering data and the buffers are processed by the GPU. Each VBO contains usually data related to an entity. A VBO could contain all the information related to a 3D model of a dinosaur, in 2D, each VBO could, for example, contain the vertexes and necessary info to draw a logic gate or a transistor in an EDA (Electronic Design Automation) CAD program.", "A VAO is a superset of VBOs, which means that we need to have at least one VAO. One potential example of VAO usage would be to group all render VBOs of a certain game level in a VAO. By doing that it is easier for the main program to manage which buffers need to be loaded. It is a way to group buffers that are likely to be required at the same time. Basic 2D applications can work with just one VAO. For complex applications, its usage might provide some advantages, especially if you can not put all information in memory at the same time.", "We will create a new class named Window C which contains the three shaders. We will define one VAO and two VBOs, each one will contain one 2D x,y coordinates. We will process both VBOs and we will end up getting two imaginary squares drawn on the screen.", "We will also need our main class:", "Before finishing this example, let\u2019s imagine that we want to draw one triangle at each point instead of the vertexes of an imaginary square. To do that, we just modify our Geometry shader using triangle_strip instead of points as output. Three vertexes need to be defined before calling EndPrimitive().", "While the example is pretty basic, it illustrates the basic workflow for programs using hardware acceleration using OpenGL. It uses the three main steps used in rendering programs: the vertex shader, the geometry shader and the fragment shader. It illustrates how OpenGL programs are concise and not that easy to follow, but at the same time provide great computational power to software, as all graphic drawing efforts are delivered by the GPU. This frees our application and CPU which effectively simplifies the code at that level and boosts performance.", "I have intentionally left out any other aspect which would complicate this basic workflow used in OpenGL. Remember that we have defined some coordinates, each coordinate has been stored in a VBO, the two VBOs has been included in a single VAO, the GPU has been coded to use a Vertex, Geometry and Fragment shader and we got our shapes rendered.", "In the next articles we will continue covering things like scaling, panning, and debugging (error check at least).", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Consultant, retail trader & lifelong learner | Linkedin https://ieee.shortcm.li/OP8dFS"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F907f137c5bd5&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@m.emmanuel?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@m.emmanuel?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": "Mario Emmanuel"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F7728df51142e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&user=Mario+Emmanuel&userId=7728df51142e&source=post_page-7728df51142e----907f137c5bd5---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F907f137c5bd5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F907f137c5bd5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://link.medium.com/mK7fHn3YS3", "anchor_text": "another article"}, {"url": "https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)#Vertex_shader_attribute_index", "anchor_text": "on the OpenGL specification page"}, {"url": "https://medium.com/tag/java?source=post_page-----907f137c5bd5---------------java-----------------", "anchor_text": "Java"}, {"url": "https://medium.com/tag/data-science?source=post_page-----907f137c5bd5---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/data-visualization?source=post_page-----907f137c5bd5---------------data_visualization-----------------", "anchor_text": "Data Visualization"}, {"url": "https://medium.com/tag/graphics?source=post_page-----907f137c5bd5---------------graphics-----------------", "anchor_text": "Graphics"}, {"url": "https://medium.com/tag/programming?source=post_page-----907f137c5bd5---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F907f137c5bd5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&user=Mario+Emmanuel&userId=7728df51142e&source=-----907f137c5bd5---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F907f137c5bd5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&user=Mario+Emmanuel&userId=7728df51142e&source=-----907f137c5bd5---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F907f137c5bd5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F907f137c5bd5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----907f137c5bd5---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----907f137c5bd5--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----907f137c5bd5--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----907f137c5bd5--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----907f137c5bd5--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@m.emmanuel?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@m.emmanuel?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Mario Emmanuel"}, {"url": "https://medium.com/@m.emmanuel/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "977 Followers"}, {"url": "https://ieee.shortcm.li/OP8dFS", "anchor_text": "https://ieee.shortcm.li/OP8dFS"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F7728df51142e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&user=Mario+Emmanuel&userId=7728df51142e&source=post_page-7728df51142e--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Ffd67658cd0f9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fopengl-in-java-pipelines-shaders-907f137c5bd5&newsletterV3=7728df51142e&newsletterV3Id=fd67658cd0f9&user=Mario+Emmanuel&userId=7728df51142e&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}