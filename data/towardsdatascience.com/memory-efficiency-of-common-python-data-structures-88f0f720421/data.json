{"url": "https://towardsdatascience.com/memory-efficiency-of-common-python-data-structures-88f0f720421", "time": 1683018278.348525, "path": "towardsdatascience.com/memory-efficiency-of-common-python-data-structures-88f0f720421/", "webpage": {"metadata": {"title": "Memory Efficiency of Common Python Data Structures | by Louis Chan | Towards Data Science", "h1": "Memory Efficiency of Common Python Data Structures", "description": "Memory efficiency of python data structures. How does python over allocate memory? What is the implication and mitigation for over allocation?"}, "outgoing_paragraph_urls": [{"url": "https://wiki.python.org/moin/TimeComplexity", "anchor_text": "how Python has implemented the data structure", "paragraph_index": 14}], "all_paragraphs": ["Almost certainly, the first iterable data structure any Python programmer has come across is a list. It has a strong first impression of being super flexible, and suitable in almost any scenario in our daily coding routine. But if we want to become a better Python programmer, we should not opt for one structure just because of the flexibility and first impression, but rather make the decision after understanding what is under the hood.", "After diving into the rabbit hole of different Python data structure for quite a while, we are going to cover in this blog on some findings on memory efficiencies of the following data structures:", "In Python, it is not uncommon for flexible data structures to be over-allocated with memory headroom to support dynamic resizing operations like append, extend, add, etc. All of these resizing operations, supported by the resize or realloc method, is being evaluated every time an insertion happens. This over-allocation is done to reduce the number of re-allocation, and maintain computation complexities, e.g. over-allocating in list for O(1) amortised append performance.", "As we can see from the graph above, a tuple is the only data structure that is not over-allocating memory. As tuple is immutable in nature, once created, it can not be changed, nor resized. There is simply no need for Python to over-allocate memory for it. In order to append records into a tuple, we can concatenate two tuples together with:", "We would have though that this over-allocation can be reversed as we remove elements from the iterable. This is unfortunately not entirely true. From the graph above, there are clearly three types of behaviour on releasing memory, just like the three types of friends that owe us money:", "In order to force a set or a dict to release that memory, we can do something called re-hashing, which is basically re-creating the hash table behind the set or dict. This can be achieved with just a couple of lines:", "Or, you can also insert another element into set or dict as that would trigger the resizing and shrink the hash table.", "Why don\u2019t set and dict release any memory to it even if we have removed everything from it?", "If you recall, we have been using Memory Directly Attributed in the graph titles. That\u2019s right, there is a significant difference between memory directly attributed to an object vs the memory that the object actually takes up; and the difference lies at Python\u2019s implementation of the data structure.", "Take the dictionary dict(a=0, b=1, c=2, d=3) as an example. This dictionary object takes up 232 bytes according to sys.getsizeof. This is actually the size of memory directly attributed to the dictionary.", "When we want to access the element with key a, we will need to first translate (hash) the key a into a 0-based index that Python can use to retrieve the element. A simple example is modulo (%): the index of the element can be evaluated as: hash(\"a\") % 8, which is 3, meaning that our element is the 4-th element (1-based indexing).", "The point is, for a dictionary with 4 key-value pairs, it has internal C array of 8 buckets with a total of 232 bytes. Each bucket contains:", "As Python dictionaries allow keys and values of dynamic types, it is neither straightforward nor practical for us to measure the all the memory that an object uses. On top of that, it is not uncommon to have memories being shared across multiple objects with copy-on-write.", "sys.getsizeof counts only the memory size of internal C arrays and other bookkeeping attributes that will reference the actual values", "The internal memory depend very much on how Python has implemented the data structure. For dict and set, they are implemented as hash tables. Because of that, their internal C arrays contains hash values, pointers to keys and pointers to values (these will be None for set as only keys matter). A list on the other hand is based on linear array of pointers. With a slight twist to list, a deque is instead implemented with a linked link. And lastly, for a tuple, it can be represented with a struct, and hence has the minimal overhead.", "So what exactly is the strategy for over-allocating internal memory?", "Apart from tuple, which thanks to the immutable nature does not need any second thoughts on resizing, the other 4 data structures would need to support dynamic sizing. There are in general two different approaches to implement over-allocation:", "The two expansion strategies comes with both strengths and weaknesses. In general, the fewer number of element that you are anticipating, the lower the over-allocation headroom for geometric expansion. However, as the number of elements grows, the amount of memory attributed to over-allocation for geometric expansion will be significantly larger than that of linear expansion strategy.", "To illustrate the above, I have plotted out the over-allocation headroom below, both as units of over-allocation and percentage based on the current length for all the five different data structure. For those who are interested in the parameters for the over-allocating strategy, I have also put together tables with the expansion strategies and parameters for the data structures.", "But hold on. Why isn\u2019t load factor always 1?", "This happens for set and dict, which both has a hash table as briefly touched earlier. Take an empty set with 8 allocated elements in the internal memory, and that we would like to insert the following 5 elements into it:", "If we use the modulo hashing as mentioned above, we will get the following:", "This means the first 4 elements will be at 2nd, 7th, 4th, and 6th position in the internal memory buckets of the set object. Now the problem comes for the next element. 782 also has a remainder of 6; and the 7th position has already been occupied by 582. So where should 782 go? This is what we called collision i.e. two data has the same hash value. While there are various ways to mitigate this, it is usually a general rule of thumb that we construct a hash table of sufficient large number of rows based on the number of elements as the denominator of the modulo function (i.e. length of the allocated elements) for minimising probability of collision. The hash table should then be expanded as the table get filled up to a particular threshold. In Python\u2019s implementation of set and dict, the thresholds (load factor) are 0.6 and ~0.67 respectively with hash table length being expanded to at least twice longer than the load at the time of expansion.", "Why is it important to learn about over-allocation?", "It\u2019s simple. Now that we know about how Python over-allocates dynamic data structures, we can look into ways to improve our Python scripts\u2019 memory efficiency, making us one step closer to becoming a Python master.", "Using tuple As Static Arrays: Imagine we are finishing processing tokens for 1,000,000 documents each with 1,000 tokens. If we use list for storing the tokens, the 1,000,000 lists will each be attributed internal memory that can support up to 1,120 elements, meaning a total of 120,000,000 elements worth of internal memory overhead. If we use tuple instead, we will be using exactly 1,000,000,000 tokens worth of internal memory, as well as benefiting from the lower overhead for tuple. In fact, that can save us over 930 MB worth of RAM. Although tuple is immutable in nature, we can still index and concatenate tuples, making the flexibility compromise less significant than on paper.", "Pre-allocating list of Known Dimensions: Using the same case as above, what if we still want to benefit from the flexibility of list, especially when we are still in a model development process? This can be achieved if we know in advance the number of elements that will be in the list. We can first pre-allocate sufficient internal memory for a list of 1,000 tokens; and assign the values to each of the element. This will save us about 915 MB, not too shabby.", "Re-instantiate set and dict: If we have been manipulating our set and dict significantly, it may be a good idea to regularly re-instantiate it. For example, let\u2019s say we have a set with 1,229 elements that we have been adding elements into. It will take up 131,288 bytes of internal memory, supporting up to 4,914 records in the hash table. If we re-instantiate it with the following, we can reduce the internal memory to about half that.", "This however does not always help. If we dive into Python\u2019s implementation of set, number of allocated elements for set is estimated by left-shifting bit by bit starting from PySet_MINSIZE which is 8. As we insert elements into the set, if load factor has been reached, size will be increase by shifting bits such that the new size is 4 times that of the number of elements if the set has less than 50,000 elements, or 2 times that otherwise. If the set has less than 50,000 elements, and that number of elements <= 30% of current allocated limit, then this resizing operation should be helpful.", "In this blog, we have covered the followings on memory efficiency of Python data structures:", "And that is about it for this time. Let me know if you have learnt anything new or if there are anything that I have missed or misunderstood.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Learn from your own mistakes today makes you a better person tomorrow."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F88f0f720421&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----88f0f720421--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----88f0f720421--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://louis-chan.medium.com/?source=post_page-----88f0f720421--------------------------------", "anchor_text": ""}, {"url": "https://louis-chan.medium.com/?source=post_page-----88f0f720421--------------------------------", "anchor_text": "Louis Chan"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F6d585e26760a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&user=Louis+Chan&userId=6d585e26760a&source=post_page-6d585e26760a----88f0f720421---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F88f0f720421&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F88f0f720421&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://unsplash.com/@thefredyjacob?utm_source=medium&utm_medium=referral", "anchor_text": "Fredy Jacob"}, {"url": "https://unsplash.com?utm_source=medium&utm_medium=referral", "anchor_text": "Unsplash"}, {"url": "https://wiki.python.org/moin/TimeComplexity", "anchor_text": "how Python has implemented the data structure"}, {"url": "https://en.wikipedia.org/wiki/Geometric_progression", "anchor_text": "geometric progression"}, {"url": "https://en.wikipedia.org/wiki/Arithmetic_progression", "anchor_text": "arithmetic progression"}, {"url": "https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Objects/dictobject.c#L398", "anchor_text": "three changes"}, {"url": "https://www.linkedin.com/in/louis-chan-b55b9287/", "anchor_text": "Louis Chan \u2014 Director, Data Science \u2014 FTI Consulting | LinkedInAmbitious, curious and creative individual with a strong belief in inter-connectivity between branches knowledge and a\u2026www.linkedin.com"}, {"url": "https://towardsdatascience.com/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce", "anchor_text": "Efficient Conditional Logic on Pandas DataFramesTime to stop being too dependent on .iterrows() and .apply()towardsdatascience.com"}, {"url": "https://towardsdatascience.com/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2", "anchor_text": "7 Easy Ways for Improving Your Data Science WorkflowTips I have learnt from working as a Data Scientisttowardsdatascience.com"}, {"url": "https://towardsdatascience.com/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72", "anchor_text": "Cookiecutter Plugin for Jupyter: Easily Organise Your Data Science EnvironmentA Jupyter extension that helps organise project folders with 1 buttontowardsdatascience.com"}, {"url": "https://towardsdatascience.com/mastering-root-searching-algorithms-in-python-7120c335a2a8", "anchor_text": "Efficient Root Searching Algorithms in PythonImplementing efficient searching algorithms for finding roots, and optimisation in Pythontowardsdatascience.com"}, {"url": "https://github.com/python/cpython/blob/master/Include/setobject.h", "anchor_text": "Python\u2019s Set Object Header"}, {"url": "https://github.com/python/cpython/blob/master/Objects/setobject.c", "anchor_text": "Python\u2019s Set Object Implementation"}, {"url": "https://github.com/python/cpython/blob/e42b705188271da108de42b55d9344642170aa2b/Objects/dictobject.c", "anchor_text": "Python\u2019s Dictionary Implementation"}, {"url": "https://github.com/python/cpython/blob/master/Objects/listobject.c", "anchor_text": "Python\u2019s List Implementation"}, {"url": "https://github.com/python/cpython/blob/master/Modules/_collectionsmodule.c", "anchor_text": "Python\u2019s Deque Implementation"}, {"url": "https://github.com/python/cpython/blob/master/Objects/tupleobject.c", "anchor_text": "Python\u2019s Tuple Implementation"}, {"url": "https://amzn.to/38BV3Xu", "anchor_text": "High Performance Python"}, {"url": "https://medium.com/tag/machine-learning?source=post_page-----88f0f720421---------------machine_learning-----------------", "anchor_text": "Machine Learning"}, {"url": "https://medium.com/tag/python?source=post_page-----88f0f720421---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/data-science?source=post_page-----88f0f720421---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/software-engineering?source=post_page-----88f0f720421---------------software_engineering-----------------", "anchor_text": "Software Engineering"}, {"url": "https://medium.com/tag/programming?source=post_page-----88f0f720421---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F88f0f720421&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&user=Louis+Chan&userId=6d585e26760a&source=-----88f0f720421---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F88f0f720421&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&user=Louis+Chan&userId=6d585e26760a&source=-----88f0f720421---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F88f0f720421&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----88f0f720421--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F88f0f720421&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----88f0f720421---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----88f0f720421--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----88f0f720421--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----88f0f720421--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----88f0f720421--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----88f0f720421--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----88f0f720421--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----88f0f720421--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----88f0f720421--------------------------------", "anchor_text": ""}, {"url": "https://louis-chan.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://louis-chan.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Louis Chan"}, {"url": "https://louis-chan.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "487 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F6d585e26760a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&user=Louis+Chan&userId=6d585e26760a&source=post_page-6d585e26760a--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fcce7b4f8b91&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemory-efficiency-of-common-python-data-structures-88f0f720421&newsletterV3=6d585e26760a&newsletterV3Id=cce7b4f8b91&user=Louis+Chan&userId=6d585e26760a&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}