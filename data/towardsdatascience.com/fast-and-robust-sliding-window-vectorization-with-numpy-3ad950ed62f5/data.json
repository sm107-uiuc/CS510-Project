{"url": "https://towardsdatascience.com/fast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5", "time": 1683009553.8078861, "path": "towardsdatascience.com/fast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5/", "webpage": {"metadata": {"title": "Fast and Robust Sliding Window Vectorization with NumPy | by Syafiq Kamarul Azman | Towards Data Science", "h1": "Fast and Robust Sliding Window Vectorization with NumPy", "description": "Sliding windows and time series go hand-in-hand but Python's for-loops make it slow. Leverage vectorization with NumPy and speed up your data pipeline."}, "outgoing_paragraph_urls": [{"url": "https://www.willyweather.com.au/graphs.html?graph=outlook:1,location:4950,series=order:0,id:sunrisesunset,type:forecast,station:349,series=order:1,id:temperature,series=order:2,id:wind,series=order:3,id:delta-t,series=order:4,id:humidity", "anchor_text": "weather station", "paragraph_index": 3}, {"url": "https://en.wikipedia.org/wiki/Electroencephalography", "anchor_text": "electroencephalograms", "paragraph_index": 3}, {"url": "https://syaffers-stuff.s3.amazonaws.com/datasets/IEEE-9Bus.tar.gz", "anchor_text": "on this link", "paragraph_index": 7}, {"url": "https://syaffers.xyz/", "anchor_text": "my website", "paragraph_index": 7}, {"url": "http://syaffers.xyz", "anchor_text": "syaffers.xyz", "paragraph_index": 52}], "all_paragraphs": ["Once in a while, you get to work with the underdog of the data world: time series (images and natural language have been in the limelight a lot, recently!). I\u2019ve been lucky (or unlucky) enough to have had to work on time series data for the most part of last year. Among my adventures in the wacky world of 1-dimensional machine learning, I found some very useful vectorization that allowed me through blaze through my data pre-processing stage. I wanted to share these tricks that were instrumental in accelerating my tasks in hopes that it could do so for you.", "We will be working with multivariate time-domain simulations in this article. Our goal here is to learn how to develop a component in a performant data pipeline. NumPy is my library of choice for executing the matrix operations. Let\u2019s get to it!", "More commonly, you will see time series as a single line that cuts through a plot while progressing up or down. On the horizontal axis, time proceeds gracefully, yet ever so regularly while on the vertical axis, measurements or values stand recorded. A unit in the horizontal axis is what we will term a timestep. Multivariate time series are similar with the difference being that the lonely line is now accompanied by other lines propagating through in parallel.", "One common example of a multivariate time series data is a weather station measuring temperature, humidity, pressure, and other facets of the environment at regular intervals. Another is electroencephalograms which capture the brain activity using multiple electrodes producing many readings in parallel. More abstractly, sheet music can be interpreted as multivariate time series: the instruments are different channels of information over a regular sampling time (tempo) of the piece.", "My research looks at transient stability in power systems when a fault occurs. During a fault in a power system, a measure is taken to mitigate the mishap. Depending on what state the system is in, where the fault happened and how long it took to clear away that fault, the system can go two ways: return to stability or diverge to instability. One way to determine this is to simulate a bunch of states, fault locations, and clearing times, then learn from the dynamics of the system to predict whether the system stabilizes or explodes (okay, not really).", "The data we capture comes from phasor measurements over a period of time at different buses (bold solid lines) in the power system. Since there are many buses and each bus measures different types of data, this naturally lends itself to multivariate time series data. We will be working with some of those simulation data for the purposes of this article. It is known that the transient stability phenomenon can be predicted by taking a small section of the entire data. Most of the remainder of the time series is superfluous.", "Our goal is to extract important regions of the signal for a training dataset.", "I will first introduce the core concept of a basic extraction before diving deeper and extending the functionality of the extractor. You can find the dataset for the 9 bus system on this link or on my website as a gzipped folder of NumPy matrix files along with some metadata. The metadata column which has particular importance here is the clearing time. Take a few minutes to digest the data if you want.", "The part of the signal that we want is around the clearing time of the simulation. We want a window of information before the clearing time and after the clearing time; called the main window. The main window can span up to some maximum timestep after the clearing time, we call this max time. Within the main window, we want a bunch of smaller windows, called sub-windows, that will make up our training examples. The main window should accommodate such that there is a sub-window-sized amount of timesteps before the clearing time. This is a lot to capture but maybe a figure can help us understand the structure of these windows. We will use the voltage magnitude for case 693 for all illustrations going forward.", "Essentially, we want to slide a sub-window across the main window, step by step, and collect the information at each timestep. The first sub-window must contain the first timestep after the clearing time. The rationale here is that we only know the time at which the fault is cleared in the system (the clearing time). Therefore, the earliest we can have any usable data is the next timestep after clearance.", "Let\u2019s capture a main window with a max time of 10 timesteps. Within the main window, we can take 11 sub-windows of size 5 timesteps. Visually:", "So if I have a max time T, and a sub-window of size K, I can get T+1 examples from one simulation (including the index at the max time). This scheme disregards K because we can increase K to whatever size we want which will in turn increase the size of the left half of the main window (assuming we don\u2019t underflow the data matrix). This means extracting data with a sub-window of either size 5 or size 8 gives you an identical number of sub-windows but of different sub-window sizes.", "Awesome! Now that we have the framework, we can roughly plan out the extraction function. We have the input information as a 2-dimensional (2D) matrix where timesteps propagate down the rows, and features are distributed across the columns. Visually, a sample input matrix with 4 features and 6 timesteps would look like this:", "Our target output matrix is a 3D matrix that looks something like this (assuming we want a sliding window of size 4):", "This should be trivial: just loop over the timesteps and slice the rows of the matrix to get the sub-windows.", "The function takes the array from which the data is extracted, the clearing time index which is the index of our clearing time, the max timesteps (T), and the sub-window size (K). First, we declare an empty list to store our output sub-windows. Then we define the start index which is the index at which the sliding window will begin. Using the T+1 rule explained earlier, we know how many data points we expect. All that\u2019s left is a for-loop to extract the data from the array using good old slicing.", "As our goal is to collect a bunch of 2D matrices, it would be wise to stack the data in a batch using a 3D matrix where the first dimension would tell you how many 2D matrices are available. Hence the use of expand_dims and vstack to achieve this.", "That looks like a good solution, right? That wasn\u2019t so bad. Or is it? Well, Python for-loops are notoriously slow and we are not exploiting the capabilities of NumPy\u2019s fancy indexing. At the moment, we don\u2019t really have anything to compare the for-loop method, but try to convince yourself that it is indeed bad and that we can do better. So, let\u2019s see a few tricks of fancy indexing that will help us reach a blazing fast sliding window extraction function.", "Trick #1: We can index any row of a 2D matrix arbitrarily using a 1D matrix of integer indices.", "What we did was pick the row indices 7, 4, 1, and 2 out of the 2D matrix X by using an array of indices. By knowing what indices we want, NumPy allows us to forgo loops and instead immediately index the rows that we need.", "The analog of a single sub-window in our sliding window is indexing an array of consecutive numbers.", "But, really, this isn\u2019t much more useful compared to the slicing that we have used in our original code since you would need to loop and create consecutive arrays of indices to extract all the sub-windows. However, Trick #1 is only the prelude to a more powerful trick.", "Trick #2: We can index any 2D sub-matrix of rows of a 2D matrix using a 2D matrix of integer indices (wow, that\u2019s a mouthful of 2Ds).", "This is a little harder to catch but let\u2019s understand what is going on. First, we created a matrix, I, which is a 3\u00d74 matrix of integers. Then, we indexed multiple rows of X together using NumPy\u2019s fancy indexing giving us a 3D matrix. The first index of the output 3D matrix is the 2D matrix as if we used Trick #1 on matrix X with the indices [7, 4, 1, 2]. Similarly, the second index of the 3D matrix is the output of applying Trick #1 on X with the indices [5, 6, 8, 9]. Can you figure out the third index of the output 3D matrix?", "Basically, we have found a way to vectorize the outer for-loop in the starter code: we can create a 2D matrix of integers that contains consecutive indices of our simulation data and apply Trick #2 to quickly extract a 3D array that contains those sub-windows. If instead, we replaced matrix I with the matrix below, we can quickly get our sliding window sub-windows.", "Now that we know we can index arbitrarily any 2D matrix, we can come up with a systematic way to compose matrix I so that we can generalize this indexing to any sub-window size and up to any max time to vectorize the sliding window extraction.", "This part is a little math-heavy with lots of symbols flying around so feel free to leave a comment if you don\u2019t follow anything.", "Knowing Trick #2, what we are looking to extract is a 2D matrix of consecutive indices equal to the width of the sub-window. The main window would span from the clearing time plus one (C) minus the sub-window size (K) until the max time (T). Specifically, we want to fancily index our data using the following (T+1)\u00d7K indexer matrix:", "Okay, I have to admit, I did spend some time making sense of this matrix (mainly because of Python\u2019s 0-indexing scheme). But, in essence, this is the application of Trick #2 to a generic situation in our sliding window extraction. Ideally, we would also generate this 2D indexer matrix without using for-loops too: they\u2019re just that slow! We can actually simplify this matrix significantly by calculating our starting index. The starting index (S) is calculated as S = C - K+1 = C - (K - 1). Thus, we can represent our index matrix in the simpler-to-understand version:", "Simply, we add an offset amount, S, to a (T+1)\u00d7K matrix. This matrix has rows of consecutive values across the columns from 0 up to K - 1, and each row starts with increasing consecutive values down the rows from 0 up to T. We know that we will have T+1 sub-windows, so we just need to have consecutive indices up to the size of the sub-window T+1 times. This would get the same matrix as we would above. In fact, we can represent this matrix in a yet simpler decomposition:", "The astute among you might\u2019ve seen this coming from the second matrix already but let\u2019s go through it. Since we know that each sub-window has size K, we really just need to make a matrix of consecutive indices once. Also, with the information of T+1 consecutive sub-windows, we just need to add the values [0, 1, 2, \u2026, T] to each of the sub-window indices one at a time.", "Using a clever vectorization technique called broadcasting, we don\u2019t even have to construct the whole middle and right 2D matrices of the addition. Rather, we only need to create a 1\u00d7K and a (T+1)\u00d71 matrix instead of two (T+1)\u00d7K matrices:", "By broadcasting the addition of the center row matrix and the right column matrix, we can get the original (T+1)\u00d7K matrix that we needed. Let\u2019s see this in code.", "If the elegance is not convincing enough for you, perhaps hard numbers will. To test the performance, I first created two matrices, X and Y, with equal size but different data using NumPy\u2019s random.randn function. This ensures that any computation between the two functions is not cached between the runs. Then I run the loop-based extractor on X and the vectorized extractor on Y. The extraction yields a matrix of size 1201\u00d710\u00d7200.", "What a significant speed up! Our vectorized implementation drove circles around the loop-based extractor. This is particularly useful when you are processing multiple files and want to extract lots of windows from many different files one at a time. There are however some caveats to this method. With the for-loop, we extract data without having to create a 2D matrix to index the original matrix. This is definitely \u201ceasier\u201d on the memory, but I argue that since our output matrix is much larger than the indexer matrix, ultimately that\u2019s the decisive memory consumer.", "That\u2019s pretty much the core of it. Now let\u2019s explore how to make full use of this vectorization to perform other manipulations to the time series data.", "Alright, let\u2019s add more features to our window extractor. Of course, we\u2019ll keep the vectorization flavor going.", "What if we wanted to slide the window over more than one timestep? Like this:", "Borrowing the terminology of convolutional neural network filter operations, we call this striding windows. You can imagine this to be a relatively simple augmentation to our indexing matrix. Specifically, we are looking at an indexing matrix like this:", "I\u2019m running out of clever symbol names so I\u2019m going to denote the number of spaces as V for the stride size. When V is 1, this is the basic sliding-window code we have above. Any larger integer values will determine how much it jumps resulting in a smaller set of output sub-windows. We need to be careful: since our max time (T) hasn\u2019t changed, we will need to account for reducing the size of the rightmost vector. There are two ways around this:", "Not sure which one is better? Let\u2019s do a similar test as we did before and measure the performance.", "The only difference in the arguments that I pass to the function now is the stride size which is 3. As you can see, there isn\u2019t much difference, but variant 1 is slightly (but, negligibly) slower than variant 2. I attribute this slow down in variant 1 to the fact that it has to make a full (T+1)\u00d7K matrix and then slice it. In contrast, variant 2 creates the stride indices immediately which could save time and memory in the long run.", "In my research, the simulator is able to generate signals at a frequency much higher than what is practically possible. The real-world devices usually sample at around 50Hz or 60Hz (50/60 timesteps per second) while the simulator can generate data above 1kHz (>1000 timesteps per second). Downsampling the simulation data can be useful for training models that are deployable in a production environment.", "We can easily downsample the sub-windows using the same technique presented in the striding windows part earlier, with the exception that we create a striding sub-windows vector. But this can only work if our downsampling rate is evenly divisible. For example, if we have to downsample 1kHz to 100Hz, we just take every 10 timesteps in the sub-window (we have a downsampling ratio (R) of 10). However, if we are downsampling 1kHz to 60Hz, we need to take every 16.667 timesteps which is not an integer downsampling ratio.", "We can cheat a bit without too much issue by rounding the steps multiplied by the downsampling ratio (R). When R is equal to 1, this is, yet again, our basic sliding window. More importantly, we also need to consider how the data window is spaced out. We wanted a certain sub-window size which now has an interval of the sampling ratio. Also, the max timesteps that we need to capture are also similarly spaced. Let\u2019s view this in our good friend, the matrix:", "There are a few things to note here. S\u2019 is a new starting point index accounting for the spaced-out sub-window, R is our downsampling ratio, and accordingly, we have to adjust the spacing to capture the desired max timesteps. Caveat: R should not be less than 1; otherwise you\u2019re sampling data in between unit timesteps which entails interpolation.", "Calculating S\u2019 is relatively simple, we just need to subtract from the clearing time (C) the size of the sub-window (K) minus one multiplied by the sampling rate; mathematically, we have S\u2019 = C - (K - 1)R. This will ensure that the first timestep after clearance is the last data point in the first index. Okay, enough maths, let\u2019s code.", "Downsampled windows maintain the same output window size as a standard sliding window but occupy a greater time scale. This can be useful if you want to keep your data similar in size but cover timesteps that are more spaced-out.", "I hope you\u2019ve found some awesome tricks to help you vectorize your sliding window pre-processing workflows. Changing your mindset to approach matrix manipulation without for-loops can be tough but once you get the hang of it, it feels more natural. My biggest challenge was thinking of the outputs in high dimensional matrices which feels so foreign (and still does sometimes).", "The only gripe with this technique that I have is the maintainability factor of the code decreases since you\u2019d have to ensure that the people using your code can understand what the vectorization is doing. This means having solid documentation alongside the function is crucial and naming your variables sensibly is paramount for other\u2019s understanding.", "The extensions to the basic sliding window vectorization will hopefully inspire you to try out your own complex vectorization to speed up your data pipeline. When you get it running, you\u2019ll feel like a NumPy ninja, honest! Nevertheless, the increased performance will leave you waiting a lot less for files to process. What better way to keep working more and minimizing your idle time. Right?", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "A data engineer at AIQ, a JV between ADNOC and G42. Started in web, went into bioinformatics and is now crazy about deep learning. See more at syaffers.xyz"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F3ad950ed62f5&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@syaffers?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@syaffers?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": "Syafiq Kamarul Azman"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fdc6c04d87443&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&user=Syafiq+Kamarul+Azman&userId=dc6c04d87443&source=post_page-dc6c04d87443----3ad950ed62f5---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3ad950ed62f5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3ad950ed62f5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://unsplash.com/@fochs?utm_source=medium&utm_medium=referral", "anchor_text": "bin foch"}, {"url": "https://unsplash.com?utm_source=medium&utm_medium=referral", "anchor_text": "Unsplash"}, {"url": "https://www.willyweather.com.au/graphs.html?graph=outlook:1,location:4950,series=order:0,id:sunrisesunset,type:forecast,station:349,series=order:1,id:temperature,series=order:2,id:wind,series=order:3,id:delta-t,series=order:4,id:humidity", "anchor_text": "weather station"}, {"url": "https://en.wikipedia.org/wiki/Electroencephalography", "anchor_text": "electroencephalograms"}, {"url": "https://syaffers-stuff.s3.amazonaws.com/datasets/IEEE-9Bus.tar.gz", "anchor_text": "on this link"}, {"url": "https://syaffers.xyz/", "anchor_text": "my website"}, {"url": "https://medium.com/tag/numpy?source=post_page-----3ad950ed62f5---------------numpy-----------------", "anchor_text": "Numpy"}, {"url": "https://medium.com/tag/vectorization?source=post_page-----3ad950ed62f5---------------vectorization-----------------", "anchor_text": "Vectorization"}, {"url": "https://medium.com/tag/time-series-data?source=post_page-----3ad950ed62f5---------------time_series_data-----------------", "anchor_text": "Time Series Data"}, {"url": "https://medium.com/tag/data-manipulation?source=post_page-----3ad950ed62f5---------------data_manipulation-----------------", "anchor_text": "Data Manipulation"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F3ad950ed62f5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&user=Syafiq+Kamarul+Azman&userId=dc6c04d87443&source=-----3ad950ed62f5---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F3ad950ed62f5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&user=Syafiq+Kamarul+Azman&userId=dc6c04d87443&source=-----3ad950ed62f5---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3ad950ed62f5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F3ad950ed62f5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----3ad950ed62f5---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----3ad950ed62f5--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@syaffers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@syaffers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Syafiq Kamarul Azman"}, {"url": "https://medium.com/@syaffers/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "141 Followers"}, {"url": "http://syaffers.xyz", "anchor_text": "syaffers.xyz"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fdc6c04d87443&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&user=Syafiq+Kamarul+Azman&userId=dc6c04d87443&source=post_page-dc6c04d87443--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fbb7dfc13cb5e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ffast-and-robust-sliding-window-vectorization-with-numpy-3ad950ed62f5&newsletterV3=dc6c04d87443&newsletterV3Id=bb7dfc13cb5e&user=Syafiq+Kamarul+Azman&userId=dc6c04d87443&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}