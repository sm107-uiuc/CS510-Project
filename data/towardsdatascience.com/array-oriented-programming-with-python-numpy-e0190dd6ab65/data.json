{"url": "https://towardsdatascience.com/array-oriented-programming-with-python-numpy-e0190dd6ab65", "time": 1683005451.850867, "path": "towardsdatascience.com/array-oriented-programming-with-python-numpy-e0190dd6ab65/", "webpage": {"metadata": {"title": "Array Oriented Programming with Python NumPy | by Semi Koen | Towards Data Science", "h1": "Array Oriented Programming with Python NumPy", "description": "How to use Python's NumPy to optimise performance and readability and eliminate for-loops and if-else branches."}, "outgoing_paragraph_urls": [{"url": "https://libraries.io/pypi/numpy/dependents", "anchor_text": "libraries.io", "paragraph_index": 0}, {"url": "https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs", "anchor_text": "official documentation", "paragraph_index": 64}, {"url": "https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html#numpy.vectorize", "anchor_text": "vectorize", "paragraph_index": 105}, {"url": "https://medium.com/@semika", "anchor_text": "\u2018Follow\u2019 me", "paragraph_index": 125}], "all_paragraphs": ["NumPy is the most popular Python library for high-performance array implementation: operations on arrays are a lot faster than those on lists, which in the world of big-data it can make an amplified runtime difference. According to libraries.io (as of Apr 2020) over 4K libraries depend on NumPy, including the most popular Data Science packages, Pandas and SciPy.", "The beauty of NumPy is the array-oriented programming style it offers. That is, instead of processing the array elements using conditional for-loops (or nested for-loops when it comes to n-dimensions), it provides functional-style, vectorised operations with internal iterations, which make the array manipulations less elaborative and more succinct.", "In this tutorial you will discover all you need to know to get from total beginner to advanced, over 10 comprehensive topics. But if you are already advanced, fear not! You may jump straight to the last two sections (Advanced & Expert) where the \u2018crux\u2019 of array orientation will be addressed, together with essential performance tips. By the end you will be able to change your procedural programming style to the elegant, fast and loop-free, array-based style.", "After importing NumPy import numpy as np, we are ready to roll:", "\ud83d\udccc Can you notice something interesting in the output?", "All the comma separated values are of the same width and right aligned. Since the maximum number, 21, occupies 2 positions, all the other values are formatted as two-character fields. So now you know why there is a leading space between the [ and the 1. \ud83d\ude0f", "The format of the output is based on the number of dimensions, aligning the columns within each row: as we can see the 1 and 10 are aligned, the 2 and 20 etc.", "We can determine the array\u2019s shape with the shape attribute, which returns a tuple with the dimensions:", "And the number of dimensions (i.e. the array\u2019s rank) with the ndim attribute, like so:", "The ndim is the same as the number of axes or the length (len) of the output of the array\u2019s shape:", "Using the attribute size we can get the array\u2019s total number of elements:", "As NumPy is written in C, it uses its data types. As such integers are stored as int64 values \u2014 which correspond to 64-bit (i.e. 8-byte) integers in C.", "Determining the array\u2019s element type is easy, by accessing the dtype attribute:", "and the number of bytes required to store each element, by accessing the itemsize:", "The memory footprint (nbytes)is the number of elements times the number of bytes.", "To fill an array with specific values, NumPy provides three special functions: zeros, ones and full, which respectively create arrays containing 0s, 1s or a specified value. Please note that zeros and ones contain float64 values, but we can obviously customise the element type.", "NumPy provides optimised functions for creating arrays from ranges. The two most important functions to create evenly spaced ranges are arange and linspace, for integers and floating points respectively.", "\u25fc\ufe0f Integers: Given the intervalnp.arange(start, stop, step): Values are generated within the half-open interval [start, stop) \u2014 i.e. the interval including start but excluding stop. The default start value is 0 and the default step size is 1.", "\u25fc\ufe0f Floats: Given the number of elementsnp.linspace(start, stop, num, endpoint): Returns num evenly spaced samples, calculated over the interval [start, stop]. The endpoint of the interval can optionally be excluded. The default num value is 50 and the default endpoint is True.", "\ud83d\udca1 Although we can create arrays by passing ranges as arguments, always prefer the built-in functions as they are optimised for performance.", "To generate random ranges, NumPy provides a few options, but here are the most popular:", "\u25fc\ufe0f Random samples from a uniform distribution over [0, 1)np.random.rand(d0, d1, ...) where dn are the array dimensions:", "\u25fc\ufe0f Random integersnp.random.randint(low, high, size): Returns random integers from low (inclusive) to high (exclusive). If high is None (the default), then results are from [0, low).", "We can reference an array element using its zero based index enclosed in square brackets, so for instance in a five element array, the first element is accessed by [0] and the last one is accessed by [4].", "Arrays can also be accessed from the end by using negative indices, starting from -1 for the last element. So in the previous example, the last element ([4]), can be accessed with [-1] and its first element ([0]) with [-5]:", "we can select the 3rd element: array1D[2]", "or starting from the end: array1D[-3]", "2D arrays can be accessed with this notation: [row_index, column_index].", "we can select the element at the 2nd row and 3rd column by: array2D[1, 2]", "Slicing arrays results to a subset of the original elements, using the [first:last] notation, which returns a sub array with elements from index first to last-1.", "\u2192 If first is omitted, 0 is assumed, so the elements from the beginning till the last-1 are returned.\u2192 If last is omitted, the array\u2019s length is assumed, so the elements from first till the end are returned.\u2192 If both first and last are omitted, the whole array is returned.", "Carrying on the previous array1D example:", "Similar principles are applied in the 2D arrays, so slicing uses this notation:[row_first:row_last, column_first:column_last].", "\u2192 To select multiple rows we use: [row_first:row_last, :].\u2192 To select multiple columns we use: [:, column_first:column_last].", "Carrying on the previous array2D example:", "Moving to the next section we will explain why, Numpy Sub Arrays are just views!", "Slicing does not modify the original array. The newly created array makes shallow copies (or views) of the original elements \u2014 that means it copies the elements\u2019 references but not the objects they point to.", "In other words, any modification to the newly created array will be reflected in the original array too.", "Here is a newly created array with 10 elements:originalArray = np.arange(0, 10)", "We slice it by selecting the last 5 elements:subArray = originalArray[5:]", "We observe that the original array and the sliced one are indeed two different objects, by using the built-in id function:display(id(originalArray)) and display(id(subArray)).", "To prove that subArray views the same data as originalArray, we will modify the first element of the subArray:subArray[0] = subArray[0] * 10", "then display both arrays \u2014 the original value has also changed:", "Although shallow copies save memory as they share data, sometimes it is necessary to create independent copies of the original data. This operation is called deep copying and is useful in multi-threading programming where separate parts of our program could attempt to modify the data at the same time \u2014 possibly corrupting it.", "NumPy provides the method copy, which returns a new array object with a deep copy of the original array object\u2019s data.", "Repeating the previous example, we can see that the original array is not impacted when modifying the sub array.", "We first copy the originalArray to a newArray:newArray = originalArray.copy()", "and finally we display both arrays \u2014 see how original array\u2019s value is unchanged?", "NumPy provides many operators which enable us to write simple expressions that perform operations on entire arrays. This is our stepping stone to becoming advanced later and eliminate for-loops in our programs!", "We can perform element-wise arithmetic operations with arrays and scalars. During these operations the scalar is applied to every array element, so this snippet adds 5 to every element: array + 5.", "Each operation returns a new array containing the result (i.e. does not modify the original array).", "Augmented assignments modify every element in the left operand. In this example: array += 1, the elements of the original array are now incremented by 1. No memory allocation happens here, contrary to the previous case, as such in-place operations are preferred.", "Multiplication, subtraction, division and exponentiation are as easy as the previous addition.", "\ud83d\udccc Operating with scalars is the simplest form of Broadcasting that we will be discussing in the next section.", "We can perform element-wise arithmetic operations between arrays of the same shape. The result is a new formed array with the elements of both arrays combined.", "In this example, we have two arrays with 5 elements each:", "When we add them: arrayA + arrayB, we can see the new combined array:", "\ud83d\udccc Please note that array multiplication is not matrix multiplication. The elements are solely component-wise multiplied. Using the previous arrays, we can calculate the matrix multiplication by using the dot function:np.dot(arrayA, arrayB)", "When comparing two arrays, we get a Boolean array in which each element is True or False, indicating the respective comparison result.", "Given two arrays of random integers:", "we can check whether the elements of the 1st array are greater than the elements of the second one: compA > compB.", "\ud83d\udccc To compare complete arrays for equality we use the array_equal function, which returns True if two arrays have the same shape and same elements:np.array_equal(compA, compB)", "Additionally, we can apply logical OR and AND to arrays element-wise, by using the logical_or and logical_and functions respectively.", "Moreover, NumPy offers many standalone universal functions (or ufuncs) that perform various element-wise operations. Each returns a new array containing the results.", "The official documentation lists five categories \u2014 math, trigonometry, bit manipulation, comparison and floating point. A quick browse is recommended so you know what is available.", "Well done! You made it to the next level!", "So far these operations require as operands two arrays of the same size and shape. Broadcasting relaxes these constraints when the arrays\u2019 shapes are compatible, enabling some concise and powerful manipulations.", "The smaller array becomes \u2018broadcast\u2019 across the larger array. It allows us to avoid loops and also create unnecessary copies of our data.", "When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing dimensions, and works its way forward.Two dimensions are compatible when:\u2022 they are equal, or\u2022 one of them is 1If these conditions are not met, a ValueError: operands could not be broadcast together exception is thrown.", "We will demonstrate the operating principles of broadcasting in a few of step-by-step multiplication examples. Pretty much, the smaller array \u2018stretches\u2019 so that it is multiplied with each row of the larger array.", "It is not literally stretched in memory; it is the computation that is repeated.", "In this example we have a 3x3 table and a 1x3 table.", "We can observe that the broadcasting conditions are met and both dimensions are compatible:", "\u2022 Row dimension: Although they differ (i.e. 3 vs. 1), one of them is 1.\u2022 Column dimension: Both are the same (i.e. 3)", "So the result of the multiplication (ex1A * ex1B) is:", "In the 2nd example we have a 3x3 table and a 3x1 table.", "So the result of the multiplication (ex2A * ex2B) is:", "In the 3rd example we have a 1x3 table and a 3x1 table.", "So the result of the multiplication (ex3A * ex3B) is:", "In this example, the number of rows is different (i.e. 3 vs. 2) and none of them is 1.", "Similarly, the second from last dimensions mismatch:", "After understanding broadcasting, another important concept is to manipulate the shape. Let\u2019s see a few techniques:", "It is common practice to create a NumPy array as 1D and then reshape it to multiD later, or vice versa, keeping the total number of elements the same.", "\ud83d\udccc The reshape returns a new array, which is a shallow copy of the original.", "If we need to change the total number of elements, then we need to resize the array. If we are enlarging it, it will add trailing zeroes, until it reaches the new size. Otherwise it is truncated to the new size.", "\ud83d\udccc The resize modifies the original array.", "Carrying on this example, we can enlarge the 9-element array to 15 elements:array09.resize(15, refcheck = False).", "or we can truncate it down to 5 elements:array09.resize(5, refcheck = False).", "\ud83d\udccc Another desired behaviour of enlarging an array is to have it repeat itself until it reaches the new size. In this case we can use this \u2018static\u2019 version of resize, which takes the original array as an input:np.resize(array09, 10)", "Inserting a new axis into an array increases its dimensionality. newaxis is usually used to make arrays compatible for broadcasting.", "In this example we will see how we can transpose a 1-row table to a 1-column:", "Flattening is the inverse operation to reshaping. We can flatten a multidimensional array into a single dimension with the methods flatten and ravel. Method flatten deep copies the original array\u2019s data, while ravel shallow copies it, [as such flatten is slower].", "We flatten it \u2014 deep copy: array2x2.flatten()", "and then unravel it again \u2014 shallow copy: array2x2.ravel()", "Transposing an array i.e. permuting its dimensions (meaning turning its shape from (X,Y) to (Y,X)) is also very straight forward.", "\ud83d\udccc The transpose returns a new array, which is a shallow copy of the original.", "and here is its transposed copy:toBeTransposed.transpose()", "Joining or Concatenating means putting contents of two or more arrays in a single array, along a specified axis, by \u2018stacking\u2019 them under (axis = 1) or next to (axis = 0) each other. There are a few options to do that, but the concatenate function is the most popular.", "Here are two 3x3 arrays, arr1 and arr2 :", "Splitting is the reverse operation of Joining, i.e. we split the contents of an array to multiple sub-arrays, along a specified axis.We can either split them into arrays of the same shape or indicate the position after which the split should occur.", "Using this nine element array (arr3), we will see these two variations (on axis = 0):", "\u25fc\ufe0f Uneven Split, based on the positions indicated in a 1D arraynp.split(arr3, [2, 7]))will produce 3 sub-arrays, split after the 2nd and 7th elements:", "To apply a transformation into NumPy arrays, we will employ the vectorize function. A new array is returned with the mapping taken effect.", "We will now double all the elements of the array, by passing a lambda anonymous function:np.vectorize(lambda x: x * 2)(toBeMapped)", "If we had a more complex calculation (with many lines of code), we can pass a function instead.", "\ud83d\udccc According to the documentation, \u2018the vectorize function is provided primarily for convenience, not for performance. The implementation is essentially a for loop\u2019. Nevertheless readability is key here, so although under the hood it uses a for loop, our code doesn't!", "Filter, tests each element with a unary predicate. NumPy provides the extract function for this. Elements that satisfy the predicate are kept; those that don\u2019t are removed. A new array is returned; filter doesn\u2019t modify the original array.", "We would like to select the odd numbers:np.extract(toBeFiltered % 2 == 1, toBeFiltered)", "An equivalent way of achieving the same result is as follows:toBeFiltered[toBeFiltered % 2 == 1]", "When faced with a large amount of data, a desired step is to reduce the dimensions by applying a calculation across the whole array or over one of its axis.", "\u25fc\ufe0f Over the whole arraytoBeReduced.sum()will produce a scalar representing the sum of all the elements:", "\u25fc\ufe0f Column-wise [axis = 0]toBeReduced.sum(axis = 0)will produce a 1x3 array, where each element is the sum of the respective column:", "\u25fc\ufe0f Row-wise [axis = 1]toBeReduced.sum(axis = 1)will produce a 3x1 array, where each element is the sum of the respective row:", "They all work the same way. For example:", "\u25fc\ufe0f OtherTwo other important categories include:", "which I suggest you skim through and then learn as you go.", "My compliments! You are ready to bid for-loops Adieu!", "To optimise the performance of our programs the first thing we do is to move computations or memory allocations outside a for-loop. We have already covered a lot of material on NumPy techniques, but let\u2019s distill these tips and tricks and make them explicit, to help you write more performant code.", "Vectorised are the operations that process entire arrays in an element-wise fashion. They turn the Python explicit for-loops into implicit, low-level, optimised and compiled C implementations, and therefore you should prefer them.", "You should avoid unnecessary deep copies; use shallow copies (or views) and in-place operations whenever possible.", "You should use broadcasting to do operations on arrays as small as possible before combining them; the smallest dimension is internally stretched to match the other dimension, but this operation does not involve any memory copy.", "Numpy arrays are stored in row-major order \u2014 i.e. the flattened memory is represented row-by-row. As such, storing data in a contiguous block of memory ensures that the architecture of modern CPUs is used optimally, in terms of memory access patterns and CPU cache.Consequently, accessing or traversing an array in a contiguous way is much faster than random access, so you should choose wisely how to represent the data in n-dimensions. As an illustrative example, summing elements along rows is faster than along columns.", "You should use Map, Filter, Reduce to avoid for-loops and conditional programming.", "Wonderful! You made it to the end!", "I hope you feel enlightened by how powerful NumPy is and the flexibility it evokes. You are now equipped with knowledge and skills needed to help you optimise the performance of your code and eliminate the for-loops as much as possible. All you need to do is:Practise \u2014 Practise \u2014 Practise!", "I regularly write about Leadership, Technology & Data on Medium \u2014 if you would like to read my future posts then please \u2018Follow\u2019 me!", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Passionate about creating elegant software. Fuelled by iced coffees & witty words. Currently in Japan. Opinions are my own; often flawed"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fe0190dd6ab65&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://semika.medium.com/?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": ""}, {"url": "https://semika.medium.com/?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": "Semi Koen"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Faabf98f9b9a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&user=Semi+Koen&userId=aabf98f9b9a&source=post_page-aabf98f9b9a----e0190dd6ab65---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe0190dd6ab65&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe0190dd6ab65&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://libraries.io/pypi/numpy/dependents", "anchor_text": "libraries.io"}, {"url": "https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs", "anchor_text": "official documentation"}, {"url": "https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html", "anchor_text": "official documentation"}, {"url": "https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html#numpy.vectorize", "anchor_text": "vectorize"}, {"url": "https://docs.scipy.org/doc/numpy/reference/routines.logic.html#truth-value-testing", "anchor_text": "Logical Reductions (Truth Value Testing)"}, {"url": "https://docs.scipy.org/doc/numpy/reference/routines.statistics.html", "anchor_text": "Statistics"}, {"url": "https://github.com/rougier/numpy-100/blob/master/100_Numpy_exercises_with_solutions.md", "anchor_text": "100 Numpy Exercises"}, {"url": "https://realpython.com/numpy-array-programming/", "anchor_text": "Real Python: Array Programming With NumPy"}, {"url": "https://hal.inria.fr/inria-00564007/document", "anchor_text": "The NumPy array: a structure for efficient numerical computation"}, {"url": "http://scipy-lectures.org/advanced/advanced_numpy/", "anchor_text": "SciPy Lectures: Advanced NumPy"}, {"url": "https://www.amazon.co.uk/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047", "anchor_text": "Beautiful Code"}, {"url": "https://medium.com/@semika", "anchor_text": "\u2018Follow\u2019 me"}, {"url": "https://medium.com/tag/python?source=post_page-----e0190dd6ab65---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/programming?source=post_page-----e0190dd6ab65---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/tag/data-science?source=post_page-----e0190dd6ab65---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/technology?source=post_page-----e0190dd6ab65---------------technology-----------------", "anchor_text": "Technology"}, {"url": "https://medium.com/tag/women-in-tech?source=post_page-----e0190dd6ab65---------------women_in_tech-----------------", "anchor_text": "Women In Tech"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe0190dd6ab65&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&user=Semi+Koen&userId=aabf98f9b9a&source=-----e0190dd6ab65---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe0190dd6ab65&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&user=Semi+Koen&userId=aabf98f9b9a&source=-----e0190dd6ab65---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe0190dd6ab65&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2Fe0190dd6ab65&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----e0190dd6ab65---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----e0190dd6ab65--------------------------------", "anchor_text": ""}, {"url": "https://semika.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://semika.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Semi Koen"}, {"url": "https://semika.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "7.7K Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Faabf98f9b9a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&user=Semi+Koen&userId=aabf98f9b9a&source=post_page-aabf98f9b9a--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F31f7468ed9ff&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Farray-oriented-programming-with-python-numpy-e0190dd6ab65&newsletterV3=aabf98f9b9a&newsletterV3Id=31f7468ed9ff&user=Semi+Koen&userId=aabf98f9b9a&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}