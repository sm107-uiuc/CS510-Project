{"url": "https://towardsdatascience.com/sql-order-based-calculations-b924e79401a0", "time": 1683014467.322987, "path": "towardsdatascience.com/sql-order-based-calculations-b924e79401a0/", "webpage": {"metadata": {"title": "SQL Order-based Calculations. The union of field values in SQL is\u2026 | by Jerry Zhang | Towards Data Science", "h1": "SQL Order-based Calculations", "description": "The union of field values in SQL is common, such as firstname+lastname and year (birthday). No matter how many fields an expression contains, they come from the same row. We call this intra-row\u2026"}, "outgoing_paragraph_urls": [{"url": "https://www.linkedin.com/in/witness998", "anchor_text": "https://www.linkedin.com/in/witness998", "paragraph_index": 53}], "all_paragraphs": ["The union of field values in SQL is common, such as firstname+lastname and year (birthday). No matter how many fields an expression contains, they come from the same row. We call this intra-row calculation.", "Correspondingly, there are inter-row calculations. Examples include getting the difference between the result of the champion and the runner-up and calculation of the accumulative sales amount starting from January to the current month. To identify the champion and the runner-up requires data be ordered by results. To do an accumulative sum from a certain point to another point also requires that data be ordered. So we call them ordered-based calculations. An intra-row calculation takes care of values within a single record, while an inter-row calculation handles the difference between ordered records.", "The simplest and the most common order-based calculation is the reference of a value in the previous or next record when records are already sorted in a certain order. Below are three scenarios:", "1.Calculate the growth rate of a stock per day (link relative ratio)", "Sort records by date and reference the closing price of the previous day.", "2. Calculate the average price of a stock within three days, which are the previous day, the current day and the next day (moving average)", "Sort records by date, and reference the closing price of the previous day and that of the next day.", "3. There are multiple stocks. Calculate the growth rate of each stock in each trading day (intra-group link relative ratio)", "Group records by stocks, sort each group by date and reference the closing price of the previous day.", "Now let\u2019s look at how SQL handles this type of order-based calculation.", "Early SQL doesn\u2019t have window functions. To reference a value in a neighboring record, the language JOINS the two records into a single one.", "Below is the program for handling task 1:", "Perform a self-join over the table through the current day and the previous day to put the closing price of the previous day and that of the current day into a single record, and then perform an intra-row calculation to get the growth rate. You can see that subqueries are used for a simple task.", "SQL calculates the moving average in task 2 using JOIN, too:", "One more subquery to be JOINed for one more day. Imagine the program for getting the moving average of the past 10 days and the next 10 days. You will surely be bothered to death by writing 20 JOINs.", "Task 3 is more complicated. Since there is more than one stock, SQL adds a code column to differentiate different stocks. The growth rate is thus calculated within one group of stock records:", "There are two points I want to talk about. You have to do a composite sorting over a table using \u201ccode,day\u201d. The code walks ahead because you need to first put records of same stock together and then sort them. You need to put code matching in the joining condition too because if you don\u2019t the growth rate will be calculated between neighboring records of different stocks. That will produce useless dirty data.", "SQL 2003 introduced window functions to express the concept of order. It\u2019s easier to implement an order-based calculation in SQL. The above three tasks can be achieved in simpler ways:", "The following program calculates link relative ratio in task 1. I write the window function in several indentations for easier understanding:", "LAG function implements the reference of the previous record. It two parameters find the price of the record directly previous to it. OVER is the substatement within LAG function. Each window function has an OVER substatement. Its role is to define a to-be-analyzed ordered set. In this example, the to-be-analyzed data set is already ordered by date.", "The program below calculates moving average in task 2. One way is LAG function to get the previous value followed by LEAD function to get the next value. The other way is the AVG function used by this program, which is more desirable. The AVG function can get an average in the specified range at once, such as one that covers the previous 10 records and the next 10 records, while the LAG/LEAD functions can only get one value at a time\u3002", "In this way, it\u2019s easier to get a moving average from covering the previous n records and the next n records. You just need to change the range parameter defined by RANGE BETWEENT.", "This program performs the intra-group order-based calculation required in task 3. Records of all closing prices of same stock are put into a group, which can be implemented by the window function \u3002", "The PARTITION BY substatement within OVER function defines the way of grouping records and limits each LAG operation in a group. It\u2019s more intuitive than the earlier JOIN method. The JOIN method sorts records by multiple fields, which is equivalent to PARTITION BY but difficult to understand.", "It\u2019s a relative location to get a value in a neighboring record in an ordered set. At times we need to find the absolute position of a record, as calculation of the difference between the debut price and the closing price in each day requires:", "Or as the calculation of the difference between the highest closing price, which is on the 10th trading day, and the closing price in each day requires:", "There are more complex scenarios, where the sequence number for locating a record is unknown and needs to be generated from the existing values:", "4. There are stock records ordered by closing prices, and we want to find the price in the middle place (the median)", "Let\u2019s start from the simple one stock scenario. After records are sorted by prices, we still don\u2019t know where the middle place is. So we need to calculate the sequence number in the middle place according to the number of the records:", "The subquery in FROM statement uses ROW_NUMBER() to generate a sequence number for each row. Another subquery in WHERE statement gets the sequence number in the middle place. There are two points worthy of your attention in this SQL query. One is that you cannot perform filtering directly over the first subquery because WHERE clause cannot use a calculated field from the same-level SELECT clause. This is determined by the SQL execution order. The other is that the result of the subquery in WHERE clause is a one-column, one-row table with a one value. It can be treated as a single value to be compared with Seq.", "Below is the SQL program for getting the median of records of multiple stocks:", "Except for embedding PARTITION BY in the window function, you should make sure that the query condition is set for one stock when calculating the sequence number in the middle place.", "5. Calculate the growth rate of the day with the highest closing price compared with the previous day", "Two sorting operations are needed to locate the record with the highest closing price. Let\u2019s start from a single stock:", "The continuous two levels of subqueries add useful new data to the original table. ROW_NUMBER indexes closing prices in ascending order. LAG function calculates the growth rate for each day. Finally, we get the day with the highest closing price (seq=1) through the filtering operation.", "The filtering operation should be after the calculation of growth rate because you cannot calculate the growth rate if you filter away the day before the day with the highest closing price.", "The order is also useful in performing grouping. Here is an example:", "6. Find the maximum number of trading days when a stock rises consecutively.", "It\u2019s slightly complicated. The logic is this: divide stock records that are ordered by date into a number of groups by putting those that rise consecutively into same group. That is to say, if a record where the closing price is higher than that in the previous record, then put them into the same group; if a record has a lower closing price compared with the previous one, then put it into a new group. After all records are grouped, count the records in every group and get the maximum count, which is the result we want.", "This type of grouping is performed based on the order of the records. Since SQL supports equi-grouping only, it needs to transform the order-based grouping into an equi-grouping. It does it in this way:", "1) Sort records by date, and for each date get the closing price of the previous date;", "Here\u2019s the complete SQL program for getting this done:", "This SQL solution includes 4 levels of subqueries. Different from Java and C language, SQL is set-based. It offers methods that work directly over sets without explicitly controllable circularly operations and the temporarily intermediate variables. Far from the intuitive way of thinking, the SQL implementation takes a roundabout way to use standard set operations to achieve the result. Java or C language, however, is nearer to our natural way of thinking by processing each record circularly. It\u2019s intuitive to generate a new group or append data to an existing one. But they don\u2019t support set-operations. From this perspective, both SQL and Java/C have their own advantages and disadvantages.", "A real-world computing scenario can be more complicated than you can imagine:", "7. Find the stocks that rise consecutively for 3 days.", "This scenario requires order-based grouping, operations over post-grouping subsets, a standard grouping and a HAVING clause. First we get all rising groups for each stock using the implementation method in the previous query task, enclose it by a grouping operation to calculate the maximum number of consecutively rising days, and then find the stocks that rising consecutively for 3 days through the HAVING clause:", "The SQL program is nearly unintelligible.", "SQL had been extremely awkward in handling order-based calculations before window functions were introduced (Even now some databases still don\u2019t support the window functions). In theory it can manage all scenarios but actually all is nothing because the implementations are too complicated. Window functions greatly improve SQL\u2019s dilemma, though it\u2019s still roundabout when it handles complicated scenarios.", "SQL\u2019s problems are rooted in its theoretical basis \u2014 the unordered-set-based relational algebra. Window functions are useful but cannot deal with the fundamental issue.", "Actually an array (set) in a computing language is naturally ordered (they have natural sequence numbers). It\u2019s easy to understand and implement the feature with a high-level language like Java and C++. The problem is they have weak ability in handling set-operations. This means that they also produce lengthy program for handling order-based calculations (though the logic is not complicated).", "An excellent player in doing this is esProc SPL. esProc is a professional data computing engine. It is based on ordered sets and offers all-round functions for performing set operations. It inherits the merits of both Java and SQL. It\u2019s rather easy to do an order-based calculation in SPL, to implement the above scenarios, for example, SPL has its own easy solutions:", "SPL provides syntax for achieving cross-row reference and gives solid support for all those calculations above. It enables programmers to phrase the logic in an intuitive, simple, and graceful way.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Products and resources that simplify hard data processing tasks. If you have any questions, send me a message. https://www.linkedin.com/in/witness998"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fb924e79401a0&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----b924e79401a0--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----b924e79401a0--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://simplifydataprocessing.medium.com/?source=post_page-----b924e79401a0--------------------------------", "anchor_text": ""}, {"url": "https://simplifydataprocessing.medium.com/?source=post_page-----b924e79401a0--------------------------------", "anchor_text": "Jerry Zhang"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F1a807787661b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&user=Jerry+Zhang&userId=1a807787661b&source=post_page-1a807787661b----b924e79401a0---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fb924e79401a0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fb924e79401a0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fb924e79401a0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&user=Jerry+Zhang&userId=1a807787661b&source=-----b924e79401a0---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fb924e79401a0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&user=Jerry+Zhang&userId=1a807787661b&source=-----b924e79401a0---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fb924e79401a0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----b924e79401a0--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2Fb924e79401a0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----b924e79401a0---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----b924e79401a0--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----b924e79401a0--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----b924e79401a0--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----b924e79401a0--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----b924e79401a0--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----b924e79401a0--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----b924e79401a0--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----b924e79401a0--------------------------------", "anchor_text": ""}, {"url": "https://simplifydataprocessing.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://simplifydataprocessing.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Jerry Zhang"}, {"url": "https://simplifydataprocessing.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "236 Followers"}, {"url": "https://www.linkedin.com/in/witness998", "anchor_text": "https://www.linkedin.com/in/witness998"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F1a807787661b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&user=Jerry+Zhang&userId=1a807787661b&source=post_page-1a807787661b--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F38074cfc7c09&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fsql-order-based-calculations-b924e79401a0&newsletterV3=1a807787661b&newsletterV3Id=38074cfc7c09&user=Jerry+Zhang&userId=1a807787661b&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}