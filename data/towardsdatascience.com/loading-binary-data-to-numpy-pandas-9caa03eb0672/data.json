{"url": "https://towardsdatascience.com/loading-binary-data-to-numpy-pandas-9caa03eb0672", "time": 1683010406.683627, "path": "towardsdatascience.com/loading-binary-data-to-numpy-pandas-9caa03eb0672/", "webpage": {"metadata": {"title": "Loading binary data to NumPy/Pandas | by Chris Maierle | Towards Data Science", "h1": "Loading binary data to NumPy/Pandas", "description": "In the real world, data doesn\u2019t always come packaged in tidy, easy-to-load files. Sometimes your data is going to live in obscure binary or irregularly structured text formats and will arrive at your\u2026"}, "outgoing_paragraph_urls": [{"url": "https://github.com/maierman/binbuffer", "anchor_text": "here", "paragraph_index": 1}, {"url": "https://numpy.org/devdocs/reference/arrays.dtypes.html", "anchor_text": "here", "paragraph_index": 8}, {"url": "https://numpy.org/doc/stable/reference/generated/numpy.frombuffer.html", "anchor_text": "np.frombuffer", "paragraph_index": 11}, {"url": "https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html", "anchor_text": "np.fromfile", "paragraph_index": 11}, {"url": "https://github.com/maierman/binbuffer/blob/master/WorkingWithBytes.ipynb", "anchor_text": "notebook", "paragraph_index": 11}, {"url": "https://docs.python.org/3/c-api/buffer.html", "anchor_text": "buffer protocol", "paragraph_index": 18}, {"url": "https://towardsdatascience.com/use-cython-to-get-more-than-30x-speedup-on-your-python-code-f6cb337919b6", "anchor_text": "here", "paragraph_index": 20}, {"url": "https://towardsdatascience.com/speed-up-your-python-code-with-cython-8879105f2b6f", "anchor_text": "here", "paragraph_index": 20}, {"url": "https://github.com/maierman/binbuffer/blob/master/SimpleBuffer.ipynb", "anchor_text": "notebook", "paragraph_index": 35}], "all_paragraphs": ["In the real world, data doesn\u2019t always come packaged in tidy, easy-to-load files. Sometimes your data is going to live in obscure binary or irregularly structured text formats and will arrive at your doorstep without any efficient Python-based loaders. For modest amounts of data, it\u2019s usually easy to put together a custom loader using simple native Python. But for larger data, pure Python solutions can become unacceptably slow, and at that point, it\u2019s time to invest in building something faster.", "In this article, I\u2019ll show you how to use a combination of built-in functions, the C-API, and Cython to quickly and easily put together your own super-fast custom data loader for NumPy/Pandas. First, we\u2019ll review a common structure that\u2019s often used for storing binary data, and then write code to load some sample data. Along the way, we\u2019ll take brief detours into the C-API and the Python buffer protocol so that you understand how all the pieces work. There\u2019s a lot here, but don\u2019t worry \u2014 it\u2019s all very straightforward and we\u2019ll make sure that the most important parts of the code are generic and reusable. You can also follow along with a working notebook here. When we\u2019re done, you\u2019ll be able to easily adapt the code to your specific data format and get back to analysis!", "For our purposes, a binary data file is nothing more than a large array of bytes that encodes a series of data elements such as integers, floats, or character arrays. While there are many formats for the binary encoding, one common format consists of a series of individual \u2018records\u2019 stored back-to-back one after another. Within each record, the first bytes typically encode a header which specifies the length (in bytes) of the record, as well as other identifying information that allows the user to decode the data.", "Generally, there will be multiple record types in the file, all of which share a common header format. For example, binary data from a car\u2019s computer might have one record type for driver controls such as the brake pedal and steering wheel positions, and another type to record engine statistics such as fuel consumption and temperature.", "In order to load binary data, you need to refer to documentation for your binary format to know exactly how the bytes encode data. For the purposes of demonstration, we\u2019ll work with sample data laid out like this:", "In the next section, we\u2019ll see how to deal with the simple case where the data contains only a single record type", "Say we have some data with the record layout given above where all records have an identical 9-byte message body:", "We\u2019ll first load our data to a NumPy array and with that done, it\u2019s just a one liner to create a Pandas DataFrame.", "The only tricky part here is that NumPy arrays can only hold data of a single type, while our data has both integers and character arrays. Fortunately, numpy lets us define structured types with multiple subcomponents. So what we do is construct a NumPy dtype which has the same structure as our binary records. If you want to read the NumPy dtype docs you can do that here, but specifying the dtype is really pretty simple. Here\u2019s a dtype which matches the format for our sample binary data:", "With our dtype defined, we can go ahead and load the data with just a few lines:", "And that\u2019s it! Couldn\u2019t be easier, right? One little thing to take care of is that the name column in our data is holding objects of type bytes. We\u2019d probably rather have strings, so let\u2019s use the Series.str.decode() method to do the conversion from bytes to str objects:", "In the snippets above, we first loaded our binary file to a bytes array and then created a NumPy array with the function np.frombuffer. Alternatively you can combine these two steps by using the function np.fromfile, but it\u2019s sometimes useful to manually dig into your binary data and poke around. If you need a quick introduction or refresher on how to manipulate and view byte data in Python, have a look at this notebook which I set up as a quick tutorial reference for this article.", "Loading data as we did above was super easy, but unfortunately binary data is usually not structured so nicely. Typically there are many different record types all mixed together in a single file, and we need a way to load these into one or more DataFrames.", "The challenge here is that NumPy only knows how to load binary data that is stored in a \u2018simple\u2019 format, where the data exists in a contiguous block of memory consisting of identical records stacked back-to-back. In the example above, our data had only a single fixed-length record type, and that made it very easy to load.", "In general, in order to load binary data to NumPy we\u2019ll need to split it into one or more homogeneous arrays as shown below:", "One way to do the split above is to write some pre-processing code (pick any language you want) to split the binary data into one or more files. If you go that route then you can simply do your pre-processing and then load the individual files like we did above. The downside to this approach is that the pre-processing will create multiple copies of your data on disk, which isn\u2019t very elegant and could potentially be a hassle.", "So instead of writing out separate files, we\u2019ll show how to set up memory arrays in Cython, one for each record type that we\u2019re interested in, and efficiently fill them with our binary records. We\u2019ll then expose these arrays to NumPy by using the buffer protocol from the Python C-API. We could do all of this in native Python, but we\u2019ll use Cython because we want our solution to be fast (binary files are sometimes quite large).", "The Python C-API is the doorway into a lower-level implementation of Python. It allows programmers to extend Python with code written in C/C++, and also lets you embed Python into other programming languages. We won\u2019t need to know much about the C-API, though. All we need is a high level understanding of the buffer protocol.", "The buffer protocol operates at the C-API level and defines a way that Python objects can access and share each others memory. When we call np.frombuffer on an object that implements the buffer protocol, NumPy goes down into the C-API and asks the object for a view of its internal memory. If successful, NumPy goes on to set up an array using the shared data. Note that there is no copying going on here! After the call to np.frombuffer, both the original buffer object and the NumPy array are sharing the same underlying memory. A simplified version of the process looks something like this:", "Rather than use the C-API directly, we\u2019re going to interact with the C-API via Cython because it\u2019s a lot easier than writing code directly in C/C++. As you\u2019ll see, it\u2019s also very easy to implement the buffer protocol from Cython.", "Cython is an extension to Python which is a combination of Python and C/C++. Code compiled from Cython often runs much faster than native Python and gives you the ability to use functions and classes from C/C++ libraries. We won\u2019t give an introduction to Cython in this article, but there are a number of introductory tutorials \u2014 for example here and here.", "Implementing the buffer protocol from Cython is fortunately very easy. All we need to do is implement the two methods __getbuffer__ and __releasebuffer__. Behind the scenes, Cython has some special handling of these so that they get correctly tied to our object in the C-API, but we don\u2019t need to worry about that. All we need to do is implement the two methods and they\u2019re both pretty simple in our case. Here\u2019s what they do:", "__getbuffer__(self, Py_buffer *, int) This method will be called by any consumer object that wants a view of our memory. It has two arguments: an integer of bit flags, and a pointer to an object of type Py_buffer, which is a simple C struct containing fields which we need to fill in. The flags indicate details about the data format that the consumer is expecting. In our case, we\u2019ll support just the simplest type, which is one-dimensional data stored in a contiguous block of memory. So all we have to do in __getbuffer__ is check that the flags indicate a simple buffer, and then fill in a few self-explanatory fields in the Py_buffer struct (see code below).", "__releasebuffer__(self, Py_buffer *) The purpose of __releasebuffer__ is to allow reference counting so that our code knows when it can release and/or reallocate memory in the Py_buffer structure. However, NumPy doesn\u2019t respect this, and expects that buffers maintain their data even after calls to __releasebuffer__. So in our case, we don\u2019t actually have to do anything here.", "The easiest way to use Cython from a Jupyter notebook is to first load Cython as shown below. You may need to pip install Cython first. As always, consider using a virtual environment.", "Next, you enter Cython code in a separate cell starting with the IPython magic %%cython -cplus.Here we\u2019re defining a class SimplestBuffer, which implements the buffer protocol and can also be used from Python. This class is a generic reusable container that simply holds binary data and allows access via the buffer protocol so that NumPy can share the data.", "With our shiny new class SimplestBuffer we can redo our previous example like this:", "If you\u2019ve made it this far, congratulations! All the hard work is done. We\u2019ve learned how to load structured binary data to NumPy and also used Cython to create a container for data that can be efficiently accessed via np.frombuffer.", "As our final task, we\u2019ll use Cython to build a fast data-parsing function fan_bytes which is specialized to our binary data format. The function takes our input binary data as a byte array and two additional SimplestBuffer objects. It uses some simple C pointer arithmetic to step through our binary file and fans out the records to one or the other of the SimplestBuffer objects depending on the value of msg_type. If there are any records in the file with msg_type not equal to 1 or 2, these will be skipped. Note that we\u2019ve also repeated the SimplestBuffer definition in this cell so that Cython can find it.", "For this next example, I\u2019ve set up some sample binary data that contains the same records we loaded before, plus some new records which use the same header but have a message body consisting of four 32-bit integers. To see this new code in action you can do something like this:", "So that\u2019s progress!!! At this point, we\u2019ve successfully loaded a binary file containing mixed record types into two DataFrames, one for each record type.", "The code above is a complete working example, but there are a few improvements that are probably a good idea.", "First, we should improve the memory safety of SimplestBuffer so that the underlying memory can\u2019t get reallocated while NumPy or Pandas is sharing the memory.", "Secondly, we should allow for preallocation of memory on the buffer and for the ability to read bytes directly from a file. Note however that the C++ vector is already reasonably efficient about reallocating memory, and with regard to reading from files, it\u2019s often faster to read all the binary data into an intermediate buffer before processing rather than making many small reads on the file system. Nevertheless, both of these features are easy to implement and can lead to speedups.", "And finally, it\u2019s often useful to generate loadable modules from Cython rather than putting all of the Cython into Jupyter notebooks.", "In order to save space we won\u2019t show code for these improvements here, but have a look at the notebook referenced earlier, which has complete code for all of the examples and extensions above.", "I hope you\u2019ve found this notebook useful and that it helps you to load your binary data and get back to analysis!!! But before wrapping up, I want to add just a few more remarks.", "Evaluation Speed: We didn\u2019t do any benchmarking here, but in my tests, I\u2019ve found that loading binary data using the above methods is about as fast as loading equivalent DataFrames from pickled binaries, and sometimes it\u2019s even faster! One area that is not fast, however, is the conversion of byte arrays to strings using pd.Series.str.decode(\u2018utf-8\u2019). In my experience, this conversion is often the slowest part of loading binary data. So you might want to consider just leaving some or all of your character data as byte arrays rather than converting to native string objects.", "Variable Record Lengths: In the examples here, our record types all had fixed lengths. But in the wild, binary records often have variable lengths, due either to the presence of variable-length character arrays, or repeating groups within the record. In order to handle records of this type, you\u2019ll have to truncate the character arrays to some fixed length and find a way to deal with any repeating groups. The general tools above are all you really need, so just be aware that this is something you may have to deal with and you\u2019ll have no problems coming up with a solution that works for you in your situation.", "Irregularly Structured text data: In this article, we focused on binary data, but I just want to note that if you have large quantities of irregularly structured text data, you can use the same techniques demonstrated here to efficiently process and load your data. Again, just figure out a final structure that works as a DataFrame, and then write some Cython to parse your text file into one or more buffers as we did above.", "Thanks for reading and please let me know if you have any comments or suggestions.", "Your home for data science. A Medium publication sharing concepts, ideas and codes."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F9caa03eb0672&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@chrismaierle?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@chrismaierle?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": "Chris Maierle"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F5e2b281ec279&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&user=Chris+Maierle&userId=5e2b281ec279&source=post_page-5e2b281ec279----9caa03eb0672---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F9caa03eb0672&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F9caa03eb0672&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4791836", "anchor_text": "Gerd Altmann"}, {"url": "https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4791836", "anchor_text": "Pixabay"}, {"url": "https://github.com/maierman/binbuffer", "anchor_text": "here"}, {"url": "https://numpy.org/devdocs/reference/arrays.dtypes.html", "anchor_text": "here"}, {"url": "https://numpy.org/doc/stable/reference/generated/numpy.frombuffer.html", "anchor_text": "np.frombuffer"}, {"url": "https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html", "anchor_text": "np.fromfile"}, {"url": "https://github.com/maierman/binbuffer/blob/master/WorkingWithBytes.ipynb", "anchor_text": "notebook"}, {"url": "https://docs.python.org/3/c-api/buffer.html", "anchor_text": "buffer protocol"}, {"url": "https://towardsdatascience.com/use-cython-to-get-more-than-30x-speedup-on-your-python-code-f6cb337919b6", "anchor_text": "here"}, {"url": "https://towardsdatascience.com/speed-up-your-python-code-with-cython-8879105f2b6f", "anchor_text": "here"}, {"url": "https://github.com/maierman/binbuffer/blob/master/SimpleBuffer.ipynb", "anchor_text": "notebook"}, {"url": "https://medium.com/tag/python?source=post_page-----9caa03eb0672---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/pandas?source=post_page-----9caa03eb0672---------------pandas-----------------", "anchor_text": "Pandas"}, {"url": "https://medium.com/tag/numpy?source=post_page-----9caa03eb0672---------------numpy-----------------", "anchor_text": "Numpy"}, {"url": "https://medium.com/tag/data?source=post_page-----9caa03eb0672---------------data-----------------", "anchor_text": "Data"}, {"url": "https://medium.com/tag/programming?source=post_page-----9caa03eb0672---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F9caa03eb0672&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&user=Chris+Maierle&userId=5e2b281ec279&source=-----9caa03eb0672---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F9caa03eb0672&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&user=Chris+Maierle&userId=5e2b281ec279&source=-----9caa03eb0672---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F9caa03eb0672&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F9caa03eb0672&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----9caa03eb0672---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----9caa03eb0672--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----9caa03eb0672--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----9caa03eb0672--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----9caa03eb0672--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@chrismaierle?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@chrismaierle?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Chris Maierle"}, {"url": "https://medium.com/@chrismaierle/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "12 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F5e2b281ec279&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&user=Chris+Maierle&userId=5e2b281ec279&source=post_page-5e2b281ec279--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F29cc9ab482fd&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Floading-binary-data-to-numpy-pandas-9caa03eb0672&newsletterV3=5e2b281ec279&newsletterV3Id=29cc9ab482fd&user=Chris+Maierle&userId=5e2b281ec279&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}