{"url": "https://towardsdatascience.com/stateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d", "time": 1683017724.5318458, "path": "towardsdatascience.com/stateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d/", "webpage": {"metadata": {"title": "Stateful model serving: how we accelerate inference using ONNX Runtime | by Lester Solbakken | Towards Data Science", "h1": "Stateful model serving: how we accelerate inference using ONNX Runtime", "description": "Stateless model serving is what one usually thinks about when using a machine-learned model in production. For instance, a web application handling live traffic can call out to a model server from\u2026"}, "outgoing_paragraph_urls": [{"url": "https://medium.com/@lester.solbakken", "anchor_text": "Lester Solbakken", "paragraph_index": 0}, {"url": "https://medium.com/@sharmapranav", "anchor_text": "Pranav Sharma", "paragraph_index": 0}, {"url": "https://blog.vespa.ai/the-hardest-problem-in-computing/", "anchor_text": "can quickly become a scalability bottleneck", "paragraph_index": 3}, {"url": "https://vespa.ai/", "anchor_text": "Vespa.ai", "paragraph_index": 5}, {"url": "https://tech.okcupid.com/vespa-vs-elasticsearch/", "anchor_text": "even for finding love", "paragraph_index": 5}, {"url": "https://github.com/microsoft/onnxruntime", "anchor_text": "ONNX Runtime", "paragraph_index": 7}, {"url": "https://docs.vespa.ai/documentation/features.html", "anchor_text": "many features", "paragraph_index": 12}, {"url": "https://docs.vespa.ai/documentation/ranking-expressions-features.html", "anchor_text": "ranking features", "paragraph_index": 15}, {"url": "https://docs.vespa.ai/documentation/tensor-user-guide.html", "anchor_text": "tensors", "paragraph_index": 15}, {"url": "https://docs.vespa.ai/documentation/reference/ranking-expressions.html#tensor-functions", "anchor_text": "tensor operations", "paragraph_index": 24}, {"url": "https://github.com/onnx/onnx/blob/master/docs/Operators.md", "anchor_text": "ONNX operators", "paragraph_index": 26}, {"url": "https://github.com/microsoft/onnxruntime", "anchor_text": "ONNX Runtime", "paragraph_index": 30}, {"url": "https://github.com/microsoft/onnxruntime/tree/master/onnxruntime/core/mlas", "anchor_text": "MLAS", "paragraph_index": 34}, {"url": "https://github.com/microsoft/onnxruntime/blob/master/docs/ONNX_Runtime_Perf_Tuning.md#thread-management", "anchor_text": "thread management", "paragraph_index": 39}, {"url": "https://medium.com/microsoftazure/accelerate-your-nlp-pipelines-using-hugging-face-transformers-and-onnx-runtime-2443578f4333", "anchor_text": "Exporting a HuggingFace model to ONNX", "paragraph_index": 52}, {"url": "https://towardsdatascience.com/efficient-open-domain-question-answering-on-vespa-ai-72562121dcd8", "anchor_text": "open-domain question-answering application", "paragraph_index": 52}, {"url": "https://towardsdatascience.com/from-research-to-production-scaling-a-state-of-the-art-machine-learning-system-6efad0141865", "anchor_text": "drastically increasing performance", "paragraph_index": 52}], "all_paragraphs": ["By Lester Solbakken from Verizon Media and Pranav Sharma from Microsoft.", "There\u2019s a difference between stateless and stateful machine-learned model serving.", "Stateless model serving is what one usually thinks about when using a machine-learned model in production. For instance, a web application handling live traffic can call out to a model server from somewhere in the serving stack. The output of this model service depends purely on the input. This is fine for many tasks, such as classification, text generation, object detection, and translation, where the model is evaluated once per query.", "There are, however, some applications where the input is combined with stored or persisted data to generate a result. We call this stateful model evaluation. Applications such as search and recommendation need to evaluate models with a potentially large number of items for each query. A model server can quickly become a scalability bottleneck in these cases, regardless of how efficient the model inference is.", "In other words, stateless model serving requires sending all necessary input data to the model. In stateful model serving, the model should be computed where the data is stored.", "At Vespa.ai, we are concerned with efficient stateful model evaluation. Vespa.ai is an open-source platform for building applications that do real-time data processing over large data sets. Designed to be highly performant and web-scalable, it is used for such diverse tasks as search, personalization, recommendation, ads, auto-complete, image and similarity search, comment ranking, and even for finding love.", "It has become increasingly important for us to be able to evaluate complex machine-learned models efficiently. Delivering low latency, fast inference and low serving cost is challenging while at the same time providing support for the various model training frameworks.", "We eventually chose to leverage ONNX Runtime (ORT) for this task. ONNX Runtime is an accelerator for model inference. It has vastly increased Vespa.ai\u2019s capacity for evaluating large models, both in performance and model types we support. ONNX Runtime\u2019s capabilities within hardware acceleration and model optimizations, such as quantization, has enabled efficient evaluation of large NLP models like BERT and other Transformer models in Vespa.ai.", "In this post, we\u2019ll share our journey on why and how we eventually chose ONNX Runtime and share some of our experiences with it.", "Vespa.ai has a rich history. Its lineage comes from a search engine born in 1997. Initially powering the web search at alltheweb.com, it was flexible enough to be used in various more specialized products, or verticals, such as document search, mobile search, yellow pages, and banking. This flexibility in being a vertical search platform eventually gave rise to its name, Vespa.", "The technology was acquired by Yahoo in 2003. There, Vespa cemented itself as a core piece of technology that powers hundreds of applications, including many of Yahoo\u2019s most essential services. We open-sourced Vespa in 2017 and today it serves hundreds of thousands of queries per second worldwide at any given time, with billions of content items for hundreds of millions of users.", "Although Yahoo was eventually acquired by Verizon, it is interesting to note that our team has stayed remarkably stable over the years. Indeed, a few of the engineers that started working on that initial engine over 20 years ago are still here. Our team counts about 30 developers, and we are situated in Trondheim in Norway.", "Building upon experience gained over many years, Vespa.ai has evolved substantially to become what it is today. It now stands as a battle-proven general engine for real-time computation over large data sets. It has many features that make it suitable for web-scale applications. It stores and indexes data with instant writes so that queries, selection, and processing over the data can be performed efficiently at serving time. It\u2019s elastic and fault-tolerant, so nodes can be added, removed, or replaced live without losing data. It\u2019s easy to configure, operate, and add custom logic. Importantly, it contains built-in capabilities for advanced computation, including machine learned models.", "Vespa.ai is a distributed application consisting of stateless nodes and a set of stateful content nodes containing the data. A Vespa.ai application is fully defined in an application package. This is a single unit containing everything needed to set up an application, including all configuration, custom components, schemas, and machine-learned models. When the application package is deployed, the admin layer takes care of configuring all the services across all the system\u2019s nodes. This includes distributing all models to all content nodes.", "Application packages contain one or more document schemas. The schema primarily consists of:", "The ranking profiles contain ranking expressions, which are mathematical expressions combining ranking features. Some features retrieve data from sources such as the query, stored data, or constants. Others compute or aggregate data in various ways. Ranking profiles support multi-phased evaluation, so a cheap model can be evaluated in the first phase and a more expensive model for the second. Both sparse and dense tensors are supported for more advanced computation.", "After the application is deployed, it is ready to handle data writes and queries. Data feeds are first processed on the stateless layer before content is distributed (with redundancy) to the content nodes. Similarly, queries go through the stateless layer before being fanned out to the content nodes where data-dependent computation is handled. They return their results back to the stateless layer, where the globally best results are determined, and a response is ultimately returned.", "A guiding principle in Vespa.ai is to move computation to the data rather than the other way around. Machine-learned models are automatically deployed to all content nodes and evaluated there for each query. This alleviates the cost of query-time data transportation. Also, as Vespa.ai takes care of distributing data to the content nodes and redistributing elastically, one can scale up computationally by adding more content nodes, thus distributing computation as well.", "In summary, Vespa.ai offers ease of deployment, flexibility in combining many types of models and computations out of the box without any plugins or extensions, efficient evaluation without moving data around and a less complex system to maintain. This makes Vespa.ai an attractive platform.", "In the last few years, it has become increasingly important for Vespa.ai to support various types of machine learned models from different frameworks. This led to us introducing initial support for ONNX models in 2018.", "The Open Neural Network Exchange (ONNX) is an open standard for distributing machine learned models between different systems. The goal of ONNX is interoperability between model training frameworks and inference engines, avoiding any vendor lock-in. For instance, HuggingFace\u2019s Transformer library includes export to ONNX, PyTorch has native ONNX export, and TensorFlow models can be converted to ONNX. From our perspective, supporting ONNX is obviously interesting as it would maximize the range of models we could support.", "To support ONNX in Vespa.ai, we introduced a special onnx ranking feature. When used in a ranking expression this would instruct the framework to evaluate the ONNX model. This is one of the unique features of Vespa.ai, as one has the flexibility to combine results from various features and string models together. For instance, one could use a small, fast model in an early phase, and a more complex and computationally expensive model that only runs on the most promising candidates. For instance:", "This is an example of configuring Vespa.ai to calculate the euclidean distance between a query vector and the stored text_embedding vector in the first stage. This is usually used together with an approximate nearest neighbor search. The top 10 candidates are sent to the ONNX model in the second stage. Note that this is per content node, so with 10 content nodes, the model is running effectively on 100 candidates.", "The model is set up in the onnx-model section. The file refers to an ONNX model somewhere in the application package. Inputs to the model, while not actually shown here for brevity, can come from various sources such as constants, the query, a document, or some combination expressed through a user-defined function. While the output of models are tensors, the resulting value of a first or second phase expression needs to be a single scalar, as documents are sorted according to this score before being returned.", "Our initial implementation of the onnx ranking feature was to import the ONNX model and convert the entire graph into native Vespa.ai expressions. This was feasible because of the flexibility of the various tensor operations Vespa.ai supports. For instance, a single neural network layer could be converted like this:", "Here, weights and bias would be stored as constant tensors, whereas the input tensor could be retrieved either from the query, a document field, or some combination of both.", "Initially, this worked fine. We implemented the various ONNX operators using the available tensor operations. However, we only supported a subset of the 150+ ONNX operators at first, as we considered that only certain types of models were viable for use in Vespa.ai due to its low-latency requirement. For instance, the ranking expression language does not support iterations, making it more challenging to implement operators used in convolutional or recurrent neural networks. Instead, we opted to continuously add operator support as new model types were used in Vespa.ai.", "The advantage of this was that the various optimizations we introduced to our tensor evaluation engine to efficiently evaluate the models benefitted all other applications using tensors as well.", "Unfortunately, we ran into problems as we started developing support for Transformer models. Our first attempt at supporting a 12-layer BERT-base model failed. This was a model converted from TensorFlow to ONNX. The evaluation result was incorrect, with relatively poor performance.", "We spent significant efforts on this. Quite a few operators had to be rewritten due to, sometimes very subtle, edge cases. We introduced a dozen or so performance optimizations, to avoid doing silly stuff such as calculating the same expressions multiple times and allocating memory unnecessarily. Ultimately, we were able to increase performance by more than two orders of magnitude.", "During this development we turned to ONNX Runtime for reference. ONNX Runtime is very easy to use:", "This was invaluable, providing us with a reference for correctness and a performance target.", "At one point, we started toying with the idea of actually using ONNX Runtime directly for the model inference instead of converting it to Vespa.ai expressions. The Vespa.ai content node is written in C++, so this entailed integrating with the C++ interface of ONNX Runtime. It should be mentioned that adding dependencies to Vespa.ai is not something we often do, as we prefer to avoid dependencies and thus own the entire stack.", "Within a couple of weeks, we had a proof of concept up and running which showed a lot of promise. So we decided to go ahead and start using ONNX Runtime to evaluate all ONNX models in Vespa.ai.", "This proved to be a game-changer for us. It vastly increases the capabilities of evaluating large deep-learning models in Vespa.ai in terms of model types we support and evaluation performance. We can leverage ONNX Runtime\u2019s use of MLAS, a compute library containing processor-optimized kernels. ONNX Runtime also contains model-specific optimizations for BERT models (such as multi-head attention node fusion) and makes it easy to evaluate precision-reduced models by quantization for even more efficient inference.", "Here we have a single ONNX model that has two inputs. During application deployment, Vespa.ai distributes this ONNX model to all content nodes. There, the ranking expressions are parsed, and the feature executors that implement the ranking features are set up in preparation for handling traffic. Here we have 4 features:", "These features are wired together during initialization, so the outputs of query and attribute are used as inputs to onnx, and the output of the onnx feature is the input to the sum feature. The onnx feature basically sets up ONNX Runtime to evaluate the model.", "Vespa.ai\u2019s scoring framework is written in C++, so we use the C/C++ API provided by ONNX Runtime. While the integration with ONNX Runtime worked smoothly out of the box, there are two areas worth mentioning here: multi-threading and input/output tensor allocations.", "During setup, we initialize an ONNX Runtime session for each onnx feature and thread:", "The session includes options for thread management. ONNX Runtime supports 2 modes of execution: sequential and parallel. This controls whether the operators in a graph run sequentially or in parallel. Parallel execution of operators is scheduled on an inter-op thread pool. The execution of an individual operator is parallelized using an intra-op thread pool. A heavily home-optimized variant of an Eigen thread pool is used for inter-op parallelism, while OpenMP is used for intra-op.", "Vespa.ai handles several queries in parallel. In addition, Vespa.ai can be configured to use several threads per query. Because of this Vespa.ai needs to tightly manage thread usage. Using additional threads inside an ONNX Runtime session causes system-level throughput to become unpredictable, with large deviations in performance. Since Vespa.ai has thread control outside of ONNX Runtime, we need to instruct ONNX Runtime to only use a single thread. By ensuring that the total number of threads do not exceed the number of physical cores in a machine, we can improve cache utilization. Vespa also supports processor pinning.", "As we instruct ONNX Runtime to in effect run sequentially, inference times increase but total throughput also increases. For instance, we measured a 50% improvement in throughput on a BERT ranking application. We have not yet exposed ONNX Runtime\u2019s thread management settings for cases where users would like to tune this themselves. This is an option we might consider in the future. In that case, each session having their own set of thread pools would be inefficient. However, ONNX Runtime provides an option to share thread pools between sessions. This is achieved using the CreateEnvWithGlobalThreadPools C API to set up the shared_env object, which in Vespa.ai is shared between all feature executors.", "When we started using ONNX Runtime, its C++ distribution was bundled with OpenMP. This was problematic for us as the intra-operation thread setting was overridden by OpenMP, so we ended up compiling our own ONNX Runtime without OpenMP enabled. However, starting from version 1.6, ONNX Runtime ships a version without OpenMP.", "As much as possible, memory allocation and ownership of input and output tensors happen within Vespa.ai. Consider the following types:", "The input values come from other ranking features using Vespa.ai\u2019s tensor framework. The values in the input vector are wrappers for Vespa.ai tensors. So ONNX Runtime accepts the memory layout from Vespa.ai without copying to internal buffers. The values in the output vector are pre-allocated ONNX Runtime vectors which are wrapped when used subsequently in other ranking features.", "We use these directly when evaluating the model:", "This zero-copying of tensors is obviously desirable from a performance perspective. This works for outputs as tensors in Vespa.ai currently are fixed size, meaning that the dimensions are known during application deployment. So even though models accept inputs with dynamic sizes, from a Vespa.ai perspective, they must currently be fixed. Supporting dynamic sizes is future work.", "One limitation here is that Vespa.ai currently only supports double and float value types in tensors. If possible, Vespa.ai takes care of converting to the type that ONNX Runtime expects. For instance, inputs to Transformer models are token sequences usually of type int64. Since Vespa.ai does not currently support int types, they must be represented as for instance float32. Converting from float32 to int64 can be lossy, but we haven\u2019t met any inaccuracies yet. Models that accept strings as input are not yet supported in Vespa.ai.", "Integrating with ONNX Runtime was relatively painless. Even though we initially had to compile our own ONNX Runtime distribution due to OpenMP, we had no significant issues with dependencies. We are looking forward to the next release so we don\u2019t have to have to do this.", "While ONNX Runtime\u2019s C/C++ API documentation is currently relatively scarce we found it to be sufficient. The ONNX Runtime API is concrete, clean and works as one would expect. We didn\u2019t have any issues here at all, really.", "All in all, our experience with ONNX Runtime has been great. It has shown itself to be a fantastic fit for Vespa.ai, delivering superior performance and easy to work with. One example here is the BERT model optimizations in ONNX Runtime. Also of particular note is the evaluation of quantized models, which would have been laborious to implement in Vespa.ai given the current tensor types we support.", "Going forward, there are other features of ONNX Runtime we would like to experiment with. One of these is GPU support. While we are currently unsure if this is beneficial from a ranking point of view, there are other cases where this is interesting. One example is calculating vector representations of documents during data writing from a Transformer model.", "Vespa.ai\u2019s use case so far has mostly been focused on natural language understanding using Transformers such as BERT. Exporting a HuggingFace model to ONNX is easy and using it in Vespa is straightforward. ONNX Runtime was essential for us when implementing an open-domain question-answering application. Also, quantization had the effect of drastically increasing performance of this application, where a key takeaway there was that a larger model with weights with reduced precision outperformed smaller models with normal precision.", "We\u2019re excited to see what our users will use this for in the future.", "Your home for data science. A Medium publication sharing concepts, ideas and codes."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fa2875a77478d&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----a2875a77478d--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----a2875a77478d--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@lester.solbakken?source=post_page-----a2875a77478d--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@lester.solbakken?source=post_page-----a2875a77478d--------------------------------", "anchor_text": "Lester Solbakken"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F344c89cb19cc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&user=Lester+Solbakken&userId=344c89cb19cc&source=post_page-344c89cb19cc----a2875a77478d---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fa2875a77478d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fa2875a77478d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://medium.com/@lester.solbakken", "anchor_text": "Lester Solbakken"}, {"url": "https://medium.com/@sharmapranav", "anchor_text": "Pranav Sharma"}, {"url": "https://blog.vespa.ai/the-hardest-problem-in-computing/", "anchor_text": "can quickly become a scalability bottleneck"}, {"url": "https://vespa.ai/", "anchor_text": "Vespa.ai"}, {"url": "https://tech.okcupid.com/vespa-vs-elasticsearch/", "anchor_text": "even for finding love"}, {"url": "https://github.com/microsoft/onnxruntime", "anchor_text": "ONNX Runtime"}, {"url": "https://docs.vespa.ai/documentation/features.html", "anchor_text": "many features"}, {"url": "https://docs.vespa.ai/documentation/ranking-expressions-features.html", "anchor_text": "ranking features"}, {"url": "https://docs.vespa.ai/documentation/tensor-user-guide.html", "anchor_text": "tensors"}, {"url": "https://docs.vespa.ai/documentation/reference/ranking-expressions.html#tensor-functions", "anchor_text": "tensor operations"}, {"url": "https://github.com/onnx/onnx/blob/master/docs/Operators.md", "anchor_text": "ONNX operators"}, {"url": "https://github.com/microsoft/onnxruntime", "anchor_text": "ONNX Runtime"}, {"url": "https://github.com/microsoft/onnxruntime/tree/master/onnxruntime/core/mlas", "anchor_text": "MLAS"}, {"url": "https://github.com/microsoft/onnxruntime/blob/master/docs/ONNX_Runtime_Perf_Tuning.md#thread-management", "anchor_text": "thread management"}, {"url": "https://medium.com/microsoftazure/accelerate-your-nlp-pipelines-using-hugging-face-transformers-and-onnx-runtime-2443578f4333", "anchor_text": "Exporting a HuggingFace model to ONNX"}, {"url": "https://towardsdatascience.com/efficient-open-domain-question-answering-on-vespa-ai-72562121dcd8", "anchor_text": "open-domain question-answering application"}, {"url": "https://towardsdatascience.com/from-research-to-production-scaling-a-state-of-the-art-machine-learning-system-6efad0141865", "anchor_text": "drastically increasing performance"}, {"url": "https://medium.com/tag/machine-learning?source=post_page-----a2875a77478d---------------machine_learning-----------------", "anchor_text": "Machine Learning"}, {"url": "https://medium.com/tag/ai?source=post_page-----a2875a77478d---------------ai-----------------", "anchor_text": "AI"}, {"url": "https://medium.com/tag/search?source=post_page-----a2875a77478d---------------search-----------------", "anchor_text": "Search"}, {"url": "https://medium.com/tag/big-data?source=post_page-----a2875a77478d---------------big_data-----------------", "anchor_text": "Big Data"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fa2875a77478d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&user=Lester+Solbakken&userId=344c89cb19cc&source=-----a2875a77478d---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fa2875a77478d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&user=Lester+Solbakken&userId=344c89cb19cc&source=-----a2875a77478d---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fa2875a77478d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----a2875a77478d--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2Fa2875a77478d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----a2875a77478d---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----a2875a77478d--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----a2875a77478d--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----a2875a77478d--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----a2875a77478d--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----a2875a77478d--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----a2875a77478d--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----a2875a77478d--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----a2875a77478d--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@lester.solbakken?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@lester.solbakken?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Lester Solbakken"}, {"url": "https://medium.com/@lester.solbakken/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "39 Followers"}, {"url": "http://Vespa.ai", "anchor_text": "Vespa.ai"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F344c89cb19cc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&user=Lester+Solbakken&userId=344c89cb19cc&source=post_page-344c89cb19cc--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fcbf2841f937f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fstateful-model-serving-how-we-accelerate-inference-using-onnx-runtime-a2875a77478d&newsletterV3=344c89cb19cc&newsletterV3Id=cbf2841f937f&user=Lester+Solbakken&userId=344c89cb19cc&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}