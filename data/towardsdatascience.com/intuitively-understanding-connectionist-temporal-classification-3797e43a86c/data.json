{"url": "https://towardsdatascience.com/intuitively-understanding-connectionist-temporal-classification-3797e43a86c", "time": 1682993432.0090072, "path": "towardsdatascience.com/intuitively-understanding-connectionist-temporal-classification-3797e43a86c/", "webpage": {"metadata": {"title": "An Intuitive Explanation of Connectionist Temporal Classification | by Harald Scheidl | Towards Data Science", "h1": "An Intuitive Explanation of Connectionist Temporal Classification", "description": "If you want a computer to recognize text, neural networks (NN) are a good choice as they outperform all other approaches at the moment. The NN for such use-cases usually consists of convolutional\u2026"}, "outgoing_paragraph_urls": [{"url": "https://www.cs.toronto.edu/~graves/icml_2006.pdf", "anchor_text": "Original paper containing all the math", "paragraph_index": 18}, {"url": "https://towardsdatascience.com/5a889a3d85a7", "anchor_text": "Vanilla beam search decoding", "paragraph_index": 18}, {"url": "https://towardsdatascience.com/b051d28f3d2e", "anchor_text": "Word beam search decoding", "paragraph_index": 18}, {"url": "https://github.com/githubharald/CTCDecoder", "anchor_text": "Python implementation of decoders", "paragraph_index": 18}, {"url": "https://github.com/githubharald/CTCWordBeamSearch", "anchor_text": "Implementation of word beam search decoding", "paragraph_index": 18}, {"url": "https://towardsdatascience.com/2326a3487cd5", "anchor_text": "Text recognition system", "paragraph_index": 18}, {"url": "https://harald-scheidl.medium.com/c4683d776120", "anchor_text": "other Medium articles", "paragraph_index": 19}, {"url": "https://githubharald.github.io", "anchor_text": "https://githubharald.github.io", "paragraph_index": 21}], "all_paragraphs": ["If you want a computer to recognize text, neural networks (NN) are a good choice as they outperform all other approaches at the moment. The NN for such use-cases usually consists of convolutional layers (CNN) to extract a sequence of features and recurrent layers (RNN) to propagate information through this sequence. It outputs character-scores for each sequence-element, which simply is represented by a matrix. Now, there are two things we want to do with this matrix:", "Both tasks are achieved by the CTC operation. An overview of the handwriting recognition system is shown in Fig. 1.", "Let\u2019s have a closer look at the CTC operation and discuss how it works without hiding the clever ideas it is based on behind complicated formulas. At the end, I will point you to references where you can find Python code and the (not too complicated) formulas, if you are interested.", "We could, of course, create a data-set with images of text-lines, and then specify for each horizontal position of the image the corresponding character as shown in Fig. 2. Then, we could train a NN to output a character-score for each horizontal position. However, there are two problems with this naive solution:", "CTC solves both problems for us:", "As already discussed, we don\u2019t want to annotate the images at each horizontal position (which we call time-step from now on). The NN-training will be guided by the CTC loss function. We only feed the output matrix of the NN and the corresponding ground-truth (GT) text to the CTC loss function. But how does it know where each character occurs? Well, it does not know. Instead, it tries all possible alignments of the GT text in the image and takes the sum of all scores. This way, the score of a GT text is high if the sum over the alignment-scores has a high value.", "There was the issue of how to encode duplicate characters (you remember what we said about the word \u201ctoo\u201d?). It is solved by introducing a pseudo-character (called blank, but don\u2019t confuse it with a \u201creal\u201d blank, i.e. a white-space character). This special character will be denoted as \u201c-\u201d in the following text. We use a clever coding schema to solve the duplicate-character problem: when encoding a text, we can insert arbitrary many blanks at any position, which will be removed when decoding it. However, we must insert a blank between duplicate characters like in \u201chello\u201d. Further, we can repeat each character as often as we like.", "As you see, this schema also allows us to easily create different alignments of the same text, e.g. \u201ct-o\u201d and \u201ctoo\u201d and \u201c-to\u201d all represent the same text (\u201cto\u201d), but with different alignments to the image. The NN is trained to output an encoded text (encoded in the NN output matrix).", "We need to calculate the loss value for the training samples (pairs of images and GT texts) to train the NN. You already know that the NN outputs a matrix containing a score for each character at each time-step. A minimalistic matrix is shown in Fig. 3: there are two time-steps (t0, t1) and three characters (\u201ca\u201d, \u201cb\u201d and the blank \u201c-\u201d). The character-scores sum to 1 for each time-step.", "Further, you already know that the loss is calculated by summing up all scores of all possible alignments of the GT text, this way it does not matter where the text appears in the image.", "The score for one alignment (or path, as it is often called in the literature) is calculated by multiplying the corresponding character scores together. In the example shown above, the score for the path \u201caa\u201d is 0.4\u00b70.4=0.16 while it is 0.4\u00b70.6=0.24 for \u201ca-\u201d and 0.6\u00b70.4=0.24 for \u201c-a\u201d. To get the score for a given GT text, we sum over the scores of all paths corresponding to this text. Let\u2019s assume the GT text is \u201ca\u201d in the example: we have to calculate all possible paths of length 2 (because the matrix has 2 time-steps), which are: \u201caa\u201d, \u201ca-\u201d and \u201c-a\u201d. We already calculated the scores for these paths, so we just have to sum over them and get 0.4\u00b70.4+0.4\u00b70.6+0.6\u00b70.4=0.64. If the GT text is assumed to be \u201c\u201d, we see that there is only one corresponding path, namely \u201c--\u201d, which yields the overall score of 0.6\u00b70.6=0.36.", "We are now able to compute the probability of the GT text of a training sample, given the output matrix produced by the NN. The goal is to train the NN such that it outputs a high probability (ideally, a value of 1) for correct classifications. Therefore, we maximize the product of probabilities of correct classifications for the training dataset. For technical reasons, we re-formulate into an equivalent problem: minimize the loss of the training dataset, where the loss is the negative sum of log-probabilities. If you need the loss value for a single sample, simply compute the probability, take the logarithm, and put a minus in front of the result. To train the NN, the gradient of the loss with respect to the NN parameters (e.g., weights of convolutional kernels) is computed and used to update the parameters.", "When we have a trained NN, we usually want to use it to recognize text in previously unseen images. Or in more technical terms: we want to calculate the most likely text given the output matrix of the NN. You already know a method to calculate the score of a given text. But this time, we are not given any text, in fact, it is exactly this text we are looking for. Trying every possible text would work if there are only a few time-steps and characters, but for practical use-cases, this is not feasible.", "A simple and very fast algorithm is best path decoding which consists of two steps:", "An example is shown in Fig. 4. The characters are \u201ca\u201d, \u201cb\u201d and \u201c-\u201d (blank). There are 5 time-steps. Let\u2019s apply our best path decoder to this matrix: the most likely character of t0 is \u201ca\u201d, the same applies for t1 and t2. The blank character has the highest score at t3. Finally, \u201cb\u201d is most likely at t4. This gives us the path \u201caaa-b\u201d. We remove duplicate characters, this yields \u201ca-b\u201d, and then we remove any blank from the remaining path, which gives us the text \u201cab\u201d which we output as the recognized text.", "Best path decoding is, of course, only an approximation. It is easy to construct examples for which it gives the wrong result: if you decode the matrix from Fig. 3, you get \u201c\u201d as the recognized text. But we already know that the probability of \u201c\u201d is only 0.36 while it is 0.64 for \u201ca\u201d. However, the approximation algorithm often gives good results in practical situations. There are more advanced decoders such as beam-search decoding, prefix-search decoding or token passing, which also use information about language structure to improve the results.", "First, we looked at the problems arising with a naive NN solution. Then, we saw how CTC is able to tackle these problems. We then examined how CTC works by looking at how it encodes text, how loss calculation is done and how it decodes the output of a CTC-trained NN.", "This should give you a good understanding of what is happening behind the scenes when you e.g. call functions like ctc_loss or ctc_greedy_decoder in TensorFlow. However, when you want to implement CTC yourself, you need to know some more details, especially to make it run fast. Graves et al. [1] introduce the CTC operation, the paper also shows all the relevant math. If you are interested in how to improve decoding, take a look at the articles about beam search decoding [2][3]. I implemented some decoders and the loss function in Python and C++, which you can find on github [4][5]. Finally, if you want to look at the bigger picture of how to recognize (handwritten) text, look at my article on how to build a handwritten text recognition system [6].", "[1] Original paper containing all the math[2] Vanilla beam search decoding[3] Word beam search decoding[4] Python implementation of decoders[5] Implementation of word beam search decoding[6] Text recognition system", "And finally, an overview of my other Medium articles.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Interested in computer vision, deep learning, C++ and Python. https://githubharald.github.io"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F3797e43a86c&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----3797e43a86c--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----3797e43a86c--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://harald-scheidl.medium.com/?source=post_page-----3797e43a86c--------------------------------", "anchor_text": ""}, {"url": "https://harald-scheidl.medium.com/?source=post_page-----3797e43a86c--------------------------------", "anchor_text": "Harald Scheidl"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F5ecdb9e8b3fc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&user=Harald+Scheidl&userId=5ecdb9e8b3fc&source=post_page-5ecdb9e8b3fc----3797e43a86c---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3797e43a86c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3797e43a86c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://www.cs.toronto.edu/~graves/icml_2006.pdf", "anchor_text": "Original paper containing all the math"}, {"url": "https://towardsdatascience.com/5a889a3d85a7", "anchor_text": "Vanilla beam search decoding"}, {"url": "https://towardsdatascience.com/b051d28f3d2e", "anchor_text": "Word beam search decoding"}, {"url": "https://github.com/githubharald/CTCDecoder", "anchor_text": "Python implementation of decoders"}, {"url": "https://github.com/githubharald/CTCWordBeamSearch", "anchor_text": "Implementation of word beam search decoding"}, {"url": "https://towardsdatascience.com/2326a3487cd5", "anchor_text": "Text recognition system"}, {"url": "https://harald-scheidl.medium.com/c4683d776120", "anchor_text": "other Medium articles"}, {"url": "https://medium.com/tag/deep-learning?source=post_page-----3797e43a86c---------------deep_learning-----------------", "anchor_text": "Deep Learning"}, {"url": "https://medium.com/tag/text-recognition?source=post_page-----3797e43a86c---------------text_recognition-----------------", "anchor_text": "Text Recognition"}, {"url": "https://medium.com/tag/speech-recognition?source=post_page-----3797e43a86c---------------speech_recognition-----------------", "anchor_text": "Speech Recognition"}, {"url": "https://medium.com/tag/recurrent-neural-network?source=post_page-----3797e43a86c---------------recurrent_neural_network-----------------", "anchor_text": "Recurrent Neural Network"}, {"url": "https://medium.com/tag/ocr?source=post_page-----3797e43a86c---------------ocr-----------------", "anchor_text": "Ocr"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F3797e43a86c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&user=Harald+Scheidl&userId=5ecdb9e8b3fc&source=-----3797e43a86c---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F3797e43a86c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&user=Harald+Scheidl&userId=5ecdb9e8b3fc&source=-----3797e43a86c---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3797e43a86c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----3797e43a86c--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F3797e43a86c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----3797e43a86c---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----3797e43a86c--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----3797e43a86c--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----3797e43a86c--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----3797e43a86c--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----3797e43a86c--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----3797e43a86c--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----3797e43a86c--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----3797e43a86c--------------------------------", "anchor_text": ""}, {"url": "https://harald-scheidl.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://harald-scheidl.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Harald Scheidl"}, {"url": "https://harald-scheidl.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "1.1K Followers"}, {"url": "https://githubharald.github.io", "anchor_text": "https://githubharald.github.io"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F5ecdb9e8b3fc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&user=Harald+Scheidl&userId=5ecdb9e8b3fc&source=post_page-5ecdb9e8b3fc--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fb95d23199e63&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintuitively-understanding-connectionist-temporal-classification-3797e43a86c&newsletterV3=5ecdb9e8b3fc&newsletterV3Id=b95d23199e63&user=Harald+Scheidl&userId=5ecdb9e8b3fc&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}