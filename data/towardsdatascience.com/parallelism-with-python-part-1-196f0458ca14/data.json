{"url": "https://towardsdatascience.com/parallelism-with-python-part-1-196f0458ca14", "time": 1683017875.0381708, "path": "towardsdatascience.com/parallelism-with-python-part-1-196f0458ca14/", "webpage": {"metadata": {"title": "Parallelism with Python (Part 1). How to Muli-thread with Python to Speed\u2026 | by Louis Chan | Towards Data Science", "h1": "Parallelism with Python (Part 1)", "description": "As Python was first developed 29 years ago, it is unsurprisingly that it was designed more as a linear programming language when single-core CPUs are still dominating the market. In fact, CPython\u2026"}, "outgoing_paragraph_urls": [], "all_paragraphs": ["As Python was first developed 29 years ago, it is unsurprisingly that it was designed more as a linear programming language when single-core CPUs are still dominating the market. In fact, CPython developer may still be feeling the heat when it comes to concurrency. Luckily, we Python noobs can lay back and enjoy the fruits of PEP 371, where multiprocessing was officially added to the standard libraries back in 2008, and PEP 3156 where asyncio made its way to standard libraries in 2012. In the first part of the series on parallelism with Python, we are going to look into multithreading, how to implement it with multiprocessing.", "TL;DR: Parallelise a CPU-bound task with multiprocessing, and a I/O-bound task with multithreading", "Thread is a separate flow of execution. When you have a pool of worker threads, they will be executing close-to concurrently. These threads will share a common data space, hence the concept of Global Interpretor Lock (GIL) is important when you try to multi-thread your python script. What GIL does is, in short limit one Python thread to run at a time to avoid inconsistent changes in shared memories, or in long is to create a thread-safe memory management environment for including C libraries that are not thread-safe into the Python ecosystem (or go read more on CPython, unfortunately this is out of my realm of knowledge). As such, threads will be locking the caller thread when they need to use the CPU for computations. This makes threads less efficient for CPU-bound tasks and more so for I/O-bound tasks, e.g. networking, issuing database operations, etc.", "Process can be understood as a separate Python process that has been forked from the parent process and has its own Python interpretor. Because of that, each process will has its own GIL, and will not lock other processes out when executing on a CPU core. The price for avoiding the GIL bottleneck is to have a larger memory overhead as a copy of the address space, or copy-on-write if supported is needed for every process. Because of that, processes are usually more preferable when conducting CPU-bound tasks e.g. matrix manipulations.", "Python\u2019s standard library, multiprocessing has an interface for threading available via multiprocessing.pool.Pool. For seasoned Python veterans, threading was the original library for this. This interface provides the following functionalities, but each method has different restrictions on how arguments can be passed and without easy way for us to track progress:", "Before we will dive into these methods, discuss the pros and cons, let\u2019s set the scene first:", "When running it with %time func(0), we have got the following results:", "Let\u2019s say we want to, for some reason, run it a hundred times:", "Pass a function to the pool of threads. This comes in two variants: .apply() and .apply_async(). When using the apply() method, you will need to pass a callable, together with some optional args and/or kwargs. When executing the function, it would block the calling thread until the result is ready or an exception has been raised. Hence, apply_async() is usually preferred.", "When using apply_async(), instead of the actual result, it would return a multiprocessing.pool.ApplyResult which is essentially a promise of a result that you can obtain using multiprocessing.pool.ApplyResult.get() function. you can also pass in a callback and a error_callback function which will be executed when the thread has finished it job and when it has failed like it has always been in my code respectively.", "A major disadvantage for apply and apply_async is that we will need to iterative execute pool.apply or the asynchronous variant for each of the set of args and/or kwargs. Un-optimised iteration is almost always nightmares when it comes to scalability. In this case, pool.map is our dreamcatcher. All we need to do is pass in the iterable, and viola.", "Just like apply, map has an asynchronous variant which usually performs better as map would block the calling thread until results have been returned.", "Another very handy argument is chunksize, which accepts a natural number with a default of 1. Our iterable will be splitted into sections, called tasks, of length roughly the length of chunksize. Each of the thread will be a task, which they would need to finish before they ask for a new task. In essense, chunksize == 1 gives you better flexibility on scheduling each task, while having a chunksize > 1 gives you (in general) better throughput and reduces number of inter-thread communications. A general rule of thumb is to have chunksize=1 if you do not know how long each task would take to finish (e.g. optimisation), and have chunksize=len(iterable) // n_job if you are expecting the tasks to finish in roughly the same time.", "map and map_async also come with some disadvantages. One that is particularly annoying is that it only allows one arg. If your function accepts multiple args or kwargs, here are three ways (in general) to walk around it:", "You will need to specify every argument even if they are optional, and may also need to wrap your target function to make it happen.", "Only if the varying argument is the first argument accepted by the function.", "3. Don\u2019t use map or map_async", "Yes, there are better alternatives, like starmap", "imap is officially defined as a lazier version of map, meaning that it would be cast your input iterable into a list before chopping it into tasks, nor would it cast the results into list before returning. Instead it uses iter() and .next() to delegate tasks. Unlike map which would return a list of results or map_async which returns a promise of a result, imap and imap_unordered return results as soon as the worker threads yield results. Because of this difference, results cannot be casted into a list and instead would need to be in a generator, where users can use next() to fetch the latest results. This will be particularly if your program do not need to wait for all the results to start any post-processing. On top of that if order of execution is not important to you, imap_unordered would theoretically be better as it would yield results as soon as the execution is done regardless of the order of input iterable (i.e. if you pass in (1, 2, 3), you may get the results (3, 2, 1), with the result order completely determined by run time).", "Just like map and map_async, imap and its variant also have chunksize, which accepts a natural number with a default of 1. A general rule of thumb is to have chunksize=1 if you do not know how long each task would take to finish (e.g. optimisation), and have chunksize=len(iterable) // n_job if you are expecting the tasks to finish in roughly the same time.", "In short, don\u2019t use imap and imap_unordered if you are not comfortable with generator or if you need to complete result before proceeding, and don't use imap_unordered if order is important to you. If you want to convert the generator back to a list, shoo, go use map and map_async instead.", "To walk around the restriction of one arg, please refer to map and map_async.", "starmap and starmap_async were introduced in Python 3.3 to address exactly the issue where multiple args cannot be easily passed to the target function. Instead of passing in an iterable of arg, we will need to pass in an iterable of iterable of args i.e. if we pass in [(0, 1), (1, 2)] into function f, it would execute f(0, 1), and f(1, 2). So remember to wrap your args into a tuple (memory does not grow on trees) even if it has only one arg (we don't judge). For cases where you will have a mix of constant arguments and varying arguments, there are two ways in general to treat it:", "Only if the varying arguments are the first arguments accepted by the function.", "By defining all the arguments for each of the function call, this would work for varying argument at different position.", "From the table above, we can see that when used correctly, multithreading has been able to speed up our simple I/O heavy task. These numbers were obtained on an EC2 instance at its idle state, which means it will most likely be different from what you will get. That being said, apply and apply_async have been consistently outperforming the rest based on my experience and experiment, so if you would like to try multithreading, apply and apply_async should be your best shout.", "In the next part of this series, we are going to look into why multiprocessing may not be good enough for our daily routine and also walk through some other alternatives that would hopefully help you speed up your code. Let me know if you have learnt something new from this! And please also let me know if there are other neat tricks that I have missed!", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Learn from your own mistakes today makes you a better person tomorrow."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F196f0458ca14&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----196f0458ca14--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----196f0458ca14--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://louis-chan.medium.com/?source=post_page-----196f0458ca14--------------------------------", "anchor_text": ""}, {"url": "https://louis-chan.medium.com/?source=post_page-----196f0458ca14--------------------------------", "anchor_text": "Louis Chan"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F6d585e26760a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&user=Louis+Chan&userId=6d585e26760a&source=post_page-6d585e26760a----196f0458ca14---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F196f0458ca14&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F196f0458ca14&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://pixabay.com/illustrations/man-office-businessman-business-1633667/", "anchor_text": "Man Office Businessman \u2014 Free image on Pixabay"}, {"url": "https://commons.wikimedia.org/wiki/File:Single_vs_multithreaded_processes.jpg", "anchor_text": "Wikimedia Commons"}, {"url": "https://towardsdatascience.com/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce", "anchor_text": "Efficient Conditional Logic on Pandas DataFramesTime to stop being too dependent on .iterrows() and .apply()towardsdatascience.com"}, {"url": "https://towardsdatascience.com/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2", "anchor_text": "7 Easy Ways for Improving Your Data Science WorkflowTips I have learnt from working as a Data Scientisttowardsdatascience.com"}, {"url": "https://towardsdatascience.com/mastering-root-searching-algorithms-in-python-7120c335a2a8", "anchor_text": "Efficient Root Searching Algorithms in PythonImplementing efficient searching algorithms for finding roots, and optimisation in Pythontowardsdatascience.com"}, {"url": "https://www.linkedin.com/in/louis-chan-b55b9287", "anchor_text": "Louis Chan - Director, Data Science - FTI Consulting | LinkedInAmbitious, curious and creative individual with a strong belief in inter-connectivity between branches knowledge and a\u2026www.linkedin.com"}, {"url": "https://medium.com/tag/data-science?source=post_page-----196f0458ca14---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/machine-learning?source=post_page-----196f0458ca14---------------machine_learning-----------------", "anchor_text": "Machine Learning"}, {"url": "https://medium.com/tag/programming?source=post_page-----196f0458ca14---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/tag/software-development?source=post_page-----196f0458ca14---------------software_development-----------------", "anchor_text": "Software Development"}, {"url": "https://medium.com/tag/python?source=post_page-----196f0458ca14---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F196f0458ca14&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&user=Louis+Chan&userId=6d585e26760a&source=-----196f0458ca14---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F196f0458ca14&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&user=Louis+Chan&userId=6d585e26760a&source=-----196f0458ca14---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F196f0458ca14&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----196f0458ca14--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F196f0458ca14&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----196f0458ca14---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----196f0458ca14--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----196f0458ca14--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----196f0458ca14--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----196f0458ca14--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----196f0458ca14--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----196f0458ca14--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----196f0458ca14--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----196f0458ca14--------------------------------", "anchor_text": ""}, {"url": "https://louis-chan.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://louis-chan.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Louis Chan"}, {"url": "https://louis-chan.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "487 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F6d585e26760a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&user=Louis+Chan&userId=6d585e26760a&source=post_page-6d585e26760a--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fcce7b4f8b91&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fparallelism-with-python-part-1-196f0458ca14&newsletterV3=6d585e26760a&newsletterV3Id=cce7b4f8b91&user=Louis+Chan&userId=6d585e26760a&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}