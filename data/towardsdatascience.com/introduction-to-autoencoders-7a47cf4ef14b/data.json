{"url": "https://towardsdatascience.com/introduction-to-autoencoders-7a47cf4ef14b", "time": 1683017647.4981709, "path": "towardsdatascience.com/introduction-to-autoencoders-7a47cf4ef14b/", "webpage": {"metadata": {"title": "Introduction To Autoencoders. A Brief Overview | by Abhijit Roy | Towards Data Science", "h1": "Introduction To Autoencoders", "description": "Autoencoders are neural network-based models that are used for unsupervised learning purposes to discover underlying correlations among data and represent data in a smaller dimension. The\u2026"}, "outgoing_paragraph_urls": [{"url": "https://abhijitroy1998.wixsite.com/abhijitcv", "anchor_text": "https://abhijitroy1998.wixsite.com/abhijitcv", "paragraph_index": 67}], "all_paragraphs": ["Autoencoders are neural network-based models that are used for unsupervised learning purposes to discover underlying correlations among data and represent data in a smaller dimension. The autoencoders frame unsupervised learning problems as supervised learning problems to train a neural network model. The input only is passed a the output. The input is squeezed down o a lower encoded representation using an encoder network, then a decoder network decodes the encoding to recreate back the input.", "The encoding produced by the encoder layer has a lower-dimensional representation of the data and shows several interesting complex relationships among data.", "An Autoencoder has the following parts:", "The bottleneck layer is the lower dimension layer. In the diagram, we have the neural networks encoder and decoder. Phi and Theta are the representing parameters of the encoder and decoder respectively.", "The target of this model is such that the Input is equivalent to the Reconstructed Output. To achieve this we minimize a loss function named Reconstruction Loss. Basically, Reconstruction Loss is given by the error between the input and the reconstructed output. It is usually given by the Mean Square error or Binary Crossentropy between the input and reconstructed output. Binary Crossentropy is used if the data is binary.", "Now, we have a basic understanding of encoders. So, let\u2019s understand a basic tradeoff we need to know while designing an autoencoder. We have to keep in mind that the reason behind using an autoencoder is that we want to understand and represent only the deep correlations and relationships among data. We need a generalized lower-dimensional representation. That is why, if the features of the data are not correlated at all then it is hard for an autoencoder to represent the data in a lower dimension. If while designing the neural network, we use a very large number of nodes in the bottleneck layer, it will create a large dimensional encoding. The problem that exists here is, the network might cheat and overfit to the input data by simply remembering the input data. In this case, we will not be able to get the correct relationships in our encodings. Again, if we use a shallow network with a very less number of nodes, it will be very hard to capture all the relationships. So, we must be very careful during designing the network.", "Now, a question may arise, why go for autoencoder, when we have methods like PCA for dimensionality reduction?", "Well, here goes the explanation. PCA or principal component analysis tries to find lower-dimensional orthogonal hyperplanes that describe the original data by capturing the maximum possible variance in the data and the important correlations consequently. We need to focus on the fact that we are talking about finding a hyperplane, so it's linear. But often correlations are non-linear, which are not covered by PCA.", "As we can see in the above diagram autoencoders cover non-linear data dependencies, thus are a better way than PCA for dimensionality reduction.", "Let\u2019s look at some of the applications of autoencoders:", "Several kinds of Autoencoders have been developed to answer the different tradeoffs. Let\u2019s look at some of them.", "The undercomplete autoencoders are the simplest architecture for autoencoders. The architecture depends on putting constraints on the number of nodes that can be added to the hidden layers and the central bottleneck. The theory behind this is, the approach tries to restrict the flow of information through the network. The architecture depends on the fact, that if the flow of information is less and the network needs to learn the encoding the best way, it will only consider the most important dependencies and reject the rest. Thus we will be able to create the encoding for best reconstruction.", "The loss function used is normal reconstruction error loss, which is MSE or Binary Crossentropy. As we are restricting the flow of information using the bottleneck, there is no chance that the model memorizes the input and cheats.", "The above diagram shows an undercomplete autoencoder. We can see the hidden layers have a lower number of nodes.", "Let\u2019s see the application of TensorFlow for creating undercomplete autoencoder.", "The models created by the above code are:", "The first model is the decoder, the second is the full autoencoder and the third is the encoder model. The bottleneck layer is the place where the encoded image is generated.", "We use the autoencoder to train the model and get the weights that can be used by the encoder and the decoder models.", "If we send image encodings through the decoders, we will see that the images are reconstructed back.", "The upper row is the original images and the lower row is the images created from the encodings by the decoder.", "Now, the images are of dimensions 28x28, and we have created encodings of dimensions of 32. if we represent the encodings as 16x2, it will look something like this:", "The lower row represents the corresponding encodings.", "As we can see here, we have built a very shallow network, we can build a deep network, as the shallow networks may not be able to uncover all the underlying features, but we need to be very careful about restricting the number of hidden nodes.", "The above implemented as a deep undercomplete network.", "When we were talking about the undercomplete autoencoders, we told we restrict the number of nodes in the hidden layer to restrict the data flow. But often this approach creates issues because the limitation on the nodes of the hidden layers and shallower networks prevent the neural network to uncover complex relationships among the data items. So, we need to use deeper networks with more hidden layer nodes. Again, if we use more hidden layer nodes, the network may just memorize the input and overfit, which will make our intentions void. So, to solve this we use regularizers. The regularizers prevent the network from overfitting to the input data and prevent the memorization problem.", "During regularization, we normally regularize weights but in this case, we regularize activations that are actually passed from one hidden layer to another. In simpler words, the idea is we won\u2019t let all the nodes in the hidden layers learn. Now, if we go to the basics of neural networks, an activation function controls how much information a particular node passes. The activation function works like a gate. If the activation for a particular node is 0, then the node is not contributing its information. The idea of sparse autoencoders is something like that.", "Now, one thing to note is, the activations are dependent on the input data ad will change with the change in input. So, we let our model decide the activations and penalize their activation values. We usually do this in two ways:", "L1 Regularization: L1 regularizers restrict the activations as discussed above. It forces the network to use only the nodes of the hidden layers that handle a high amount of information and block the rest.", "The reconstruction loss is given by L and the second part is the regularizers that penalize the activations. As we can see the regularizer part is a summation of activations of all nodes in the hidden layer h. So, when we try to minimize the loss function we decrease the activations. Again, we use a tuning parameter lambda. Lambda helps to ensure how much attention we want to pay for the regularization aspect.", "KL Divergence: Kullback-Leibler Divergence is a way to measure the difference and similarity between two mathematical probability distributions. It is given by:", "So, basically, it tells us how similar p and q are. This method uses a sparsity parameter \u03c1 (Rho). Rho is said to be the average activation of a neuron over a set of samples. The idea is to use a very low Rho value such that the neuron or the nodes keep a low value as average and in order to achieve that the node will have just 0 activations for some of the samples in the collection, where it is not essential.", "Now, the question is how does the KL divergence help. For this, we will need to know what is a Bernoulli Distribution.", "In probability theory and statistics, the Bernoulli distribution, is the discrete probability distribution of a random variable which takes the value 1 with probability p and the value 0 with probability q=1-p", "So, basically it a binary level probability distribution. We want something similar to our nodes. We want it to fire with a probability and so its distribution can be similar to a Bernoulli distribution. Now, for a particular neuron j we can calculate Rho as:", "where m is the number of observations and a is the activation of the neuron in the hidden layer h. The loss is given by:", "A visualization will look like this:", "The above image shows the light red nodes do not fire.", "Let\u2019s see the application of TensorFlow for creating a sparse autoencoder.", "The above code uses an L1 regularizer.", "The images represent the full autoencoder, followed by the encoder and the decoder.", "We already have talked about autoencoders used as noise removers. So, the idea is in order to represent the underlying relations and represent in the small size encoding the autoencoders only look at the object image and not the noise, which is eliminated. Again, here we do not need to restrict the number of nodes or use a regularizer as we have a different input and output and the memorization problems do not exist anymore.", "The above network represents denoising autoencoders.", "The above code can be used to create the autoencoder.", "The results on datasets are as follows:", "The above are the results of the fashion mnist datasets.", "As you can see, I have used a convolutional network to create the autoencoder.", "The model structure is as below:", "The principle that the contractive autoencoders are based on is pretty similar to the denoising encoders. The idea is that the encodings produced for similar inputs will be similar. In other words, if we change the inputs or tweak them by just a little the encodings will remain the same and show no changes. They are used for feature extractions.", "Autoencoders can be implemented using any kind of neural network, like for image data we can use Convolutional Neural Nets and for time series data we can use Recurrent Neural Nets.", "There exists another type of autoencoders that are a bit different from the above-stated ones which are called Variational Autoencoders.", "To understand the concept we need to dive into a bit of basic. Actually, what do we mean by the lower dimensional encoding? The answer is, as we have seen above our above input had 784x1 or 28x28 dimension, when we encode it to a say much smaller 32x1 dimension, we basically mean that now we have 32 features which are the most important features and reflect most of the information in the data, or image.", "So, say for a face, when we encode a face image of say 32x32 dimension, it has the full facial two-dimensional image, now, if we encode it to 6x1 dimension, i.e, send it through a bottleneck layer of 6 nodes, we will basically get 6 features which contribute most or the major information about the facial image. Say, for the 6 features we have a smile, skin tone, gender, beard, wears glasses, and hair color. Our encoding has a numerical value for each of these features for a particular facial image. By sending the encodings through a decoder we can reconstruct back the image.", "The 6 features we talked about in the lower dimension encoding are called latent features/attributes and the set of values feature can take is its latent space.", "Now, different values of the latent attributes represent different images as the feature varies as shown below.", "We have seen that the values of the latent attributes are always discrete. This is where the variational autoencoders are different. Instead of considering to pass discrete values, the variational autoencoders pass each latent attribute as a probability distribution. Some thing as shown below.", "So, our representing face example becomes as follows:", "Now, we can see each latent attribute is passed as a probability distribution. The decoder samples from each latent distribution and decodes to reconstruct the image. So, as the sampling is random and not backpropagated the reconstructed image is similar to the input but is not actually present in the input set. This is the reason for variational autoencoders to be known as a generative network.", "The above image defines the situation. Now, to create a distribution for each latent vector, the encoder in place of passing the value, pass the mean and standard deviation of the distribution, which is used to create construct the normal distribution.", "The above image shows the structure of a variational autoencoder. The Probabilistic encoder is called the recognition model and the decoder is called the generative model.", "Now, as the z or the latent values are sampled randomly, they are unknown and hence called hidden variables. Again, we know the goal is such that our reconstructed output is equivalent to the input. So, our goal is to find out what is the probability of a value to be in z or the latent vector given that it is similar to x, P(z|x), because actually we need to reconstruct x from z. In simpler words, we can see x but we need to estimate z.", "We obtain the above equation, using bayes theorem. This method requires finding p(x), given by:", "This problem is untractable or it won\u2019t complete in polynomial time as, it is a multiple integral problem and the number of integral increases with the increase in latent attributes or encoding dimensions.", "In order to solve this problem, we use another distribution q(z|x) which is the approximation of p(z|x) and is designed to be a tractable solution. Now, again to determine the fact that q(z|x) is similar to p(z|x) we use KL divergence between the two distributions.", "The variational autoencoders use a loss function as:", "The first term is the reconstruction error and the second term is the KL divergence between the two distributions. It ensures that distributions are similar, as it minimizes the KL divergence to minimize the loss. We use a trick called the Reparameterization Trick to resample latent points from distributions without using back propagation.", "We have seen all types of autoencoders there exist and their uses.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "I am a Computer Science and Technology Graduate from NIT, Durgapur. Find Me at https://abhijitroy1998.wixsite.com/abhijitcv"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F7a47cf4ef14b&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@myac.abhijit?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@myac.abhijit?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": "Abhijit Roy"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4c235a4f4b95&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&user=Abhijit+Roy&userId=4c235a4f4b95&source=post_page-4c235a4f4b95----7a47cf4ef14b---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7a47cf4ef14b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7a47cf4ef14b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://unsplash.com/@maxcodes?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText", "anchor_text": "Maxwell Nelson"}, {"url": "https://unsplash.com/s/photos/machine-learning?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText", "anchor_text": "Unsplash"}, {"url": "https://www.jeremyjordan.me/author/jeremy/", "anchor_text": "Source"}, {"url": "https://www.jeremyjordan.me/author/jeremy/", "anchor_text": "Source"}, {"url": "https://www.jeremyjordan.me/author/jeremy/", "anchor_text": "Source"}, {"url": "https://www.jeremyjordan.me/author/jeremy/", "anchor_text": "Source"}, {"url": "https://www.jeremyjordan.me/author/jeremy/", "anchor_text": "Source"}, {"url": "https://www.jeremyjordan.me/author/jeremy/", "anchor_text": "Source"}, {"url": "https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html", "anchor_text": "Source"}, {"url": "https://github.com/abr-98/Autoendcoders_implementation_tensorflow", "anchor_text": "here"}, {"url": "https://medium.com/tag/autoencoder?source=post_page-----7a47cf4ef14b---------------autoencoder-----------------", "anchor_text": "Autoencoder"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F7a47cf4ef14b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&user=Abhijit+Roy&userId=4c235a4f4b95&source=-----7a47cf4ef14b---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F7a47cf4ef14b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&user=Abhijit+Roy&userId=4c235a4f4b95&source=-----7a47cf4ef14b---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7a47cf4ef14b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F7a47cf4ef14b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----7a47cf4ef14b---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----7a47cf4ef14b--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@myac.abhijit?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@myac.abhijit?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Abhijit Roy"}, {"url": "https://medium.com/@myac.abhijit/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "458 Followers"}, {"url": "https://abhijitroy1998.wixsite.com/abhijitcv", "anchor_text": "https://abhijitroy1998.wixsite.com/abhijitcv"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4c235a4f4b95&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&user=Abhijit+Roy&userId=4c235a4f4b95&source=post_page-4c235a4f4b95--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F2ba8066c30a7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fintroduction-to-autoencoders-7a47cf4ef14b&newsletterV3=4c235a4f4b95&newsletterV3Id=2ba8066c30a7&user=Abhijit+Roy&userId=4c235a4f4b95&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}