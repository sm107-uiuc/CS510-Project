{"url": "https://towardsdatascience.com/how-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de", "time": 1683017455.845653, "path": "towardsdatascience.com/how-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de/", "webpage": {"metadata": {"title": "How to Implement the Hill Climbing Algorithm in Python | by Hein de Haan | Towards Data Science", "h1": "How to Implement the Hill Climbing Algorithm in Python", "description": "Hill climbing is a mathematical optimization algorithm, which means its purpose is to find the best solution to a problem which has a (large) number of possible solutions. Explaining the algorithm\u2026"}, "outgoing_paragraph_urls": [{"url": "https://en.wikipedia.org/wiki/Travelling_salesman_problem", "anchor_text": "Travelling salesman problem", "paragraph_index": 0}, {"url": "https://en.wikipedia.org/wiki/Hill_climbing", "anchor_text": "Hill climbing", "paragraph_index": 1}], "all_paragraphs": ["Hill climbing is a mathematical optimization algorithm, which means its purpose is to find the best solution to a problem which has a (large) number of possible solutions. Explaining the algorithm (and optimization in general) is best done using an example. In the Travelling salesman problem, we have a salesman who needs to visit a number of cities exactly once, after which he returns to the first city. The distances between each pair of cities are known, and we need to find the shortest route. As you can imagine, there is (often) a large number of possible solutions (routes) to a specific Travelling salesman problem; the goal is to find the best (i.e. the shortest) solution.", "Hill climbing tries to find the best solution to this problem by starting out with a random solution, and then generate neighbours: solutions that only slightly differ from the current one. If the best of those neighbours is better (i.e. shorter) than the current one, it replaces the current solution with this better solution. It then repeats the pattern by again creating neighbours. If at some point no neighbour is better than the current solution, it returns the then current solution. That\u2019s it! The algorithm is quite simple, but it needs to be said that it doesn\u2019t always find the best solution. It can get stuck in a local maximum: a place where the current solution isn\u2019t the best solution to the problem, but where none of the direct neighbours of the current solution are better than the current solution. As described, the algorithm will stop at such a point, unfortunately without returning the best solution. More complicated algorithms exist that have a higher chance of finding the best solution, but they often take more computational resources.", "Anyway, let\u2019s start coding the Travelling salesman problem and Hill climbing in Python!", "First, let\u2019s code an instantiation of the Travelling salesman problem. If you think about it, such an instantiation should be a list of cities, where each one has information about the distances from there to the other cities. Of course, the distance from each city to itself is zero, and the distance from city A to city B is the same as the distance from city B to city A. That gives us a list, containing n lists of size n (where in this case n equals 4):", "As we can see, the first city\u2019s distance to itself is, of course, 0, and, for example, its distance to the third city is 500. One can see that the third city\u2019s distance to the first is also 500 (the first entry of the third array), as it should.", "For Hill climbing to work, it has to start with a random solution to our Travelling salesman problem. From there, it can generate neighbouring solutions and start the optimization process. How should we design such a solution? Well, a solution to the Travelling salesman problem could simply be a list of identifiers of all cities, in the order the salesman should visit them. Each city has to be visited exactly once. Let\u2019s therefore first create a list of identifiers of all cities (called cities in the code below), and from there on iteratively pick a city from that list at random and add it to our solution. Python\u2019s range function is excellent for creating cities, as it creates a range of all numbers from 0 to the argument given, which in this case is the length of the problem itself, as the problem itself contains one entry for each city.", "Since every city can only be visited one, after its identifier is added to our solution we then remove that city\u2019s identifier from the city identifier list. Our function needs the Travelling salesman problem itself for information about the distances between cities. See the code below (note that you will need to import random for this to work):", "Since we want our Hill climber to find the shortest solution, we need a function calculating the length of a specific solution. This function needs the Travelling salesman problem itself (for information about the distances between cities) and of course the solution of which we need the route length. Since a solution is a list of all cities in a specific order, we can just iterate over a solution and use the tsp argument to add the distance to each new city to our total route length. The iterator i \u201cvisits\u201d each city, so i-1 is \u201cat\u201d the previous city or the last city when i equals 0 (which is exactly what we want, since we want to end up at the first city again). solution[i] thus gives us the current city, and solution[i-1] gives us the previous one. Then we simply use the tsp to get the distance between these cities, which we add to the total length of the route (routeLength).", "As explained before, Hill climbing works in part by generating all neighbouring solutions to the current solution. Let\u2019s create a function doing exactly that. A neighbouring solution is a solution that\u2019s only slightly different from the current solution. Note also that a neighbour still needs to be a correct solution: every city still needs to be visited exactly once. We can accomplish both by creating a neighbour as follows: copy the current solution, and then make two cities swap places! This way, we create a slightly different solution that\u2019s still correct. Since we want to create all neighbours to a solution, and need to make cities swap places, we need to create two for loops, one nested in the other, both iterating the current solution. Since swapping city A with city B is the same as swapping city B with city A, our second loop needs to only loop over those cities the first loop hasn\u2019t looped over yet. Inside the second loop, we create our neighbour with the swapped cities and add it to our neighbours list.", "Now that we have a function generating all neighbours to a solution, it\u2019s time we create one finding the best of these neighbours. This is a pretty straightforward function: it first sets the bestNeighbour to the first neighbour in the list of neighbours (and bestRouteLength to its route length), and then iterates over all neighbours; when a neighbour has a shorter route length, both bestNeighbour and bestRouteLength are updated. This way, the best neighbour is found:", "It\u2019s time for the core function! After creating the previous functions, this step has become quite easy:", "First, we make a random solution and calculate its route length. We then create the neighbouring solutions, and find the best one. From there on, as long as the best neighbour is better than the current solution, we repeat the same pattern with the current solution each time being updated with the best neighbour. When this process stops, we return the current solution (and its route length).", "Here\u2019s the complete Python file, with a main function defining a Travelling salesman problem and calling the Hill climber.", "Now that we have written the full code, it\u2019s time to try our algorithm! The example Travelling salesman problem I gave in lines 55\u201360 is \u201crectangular\u201d: we have four cities, each located in the corner of a rectangular shape. The long side of the rectangle is 400 kilometers (or whatever unit you like) long, while the short side is 300. That makes the diagonal 500 kilometers long. It seems obvious that the shortest routes actually travel the sides of this rectangle, which would make the length of the shortest route 2 x 400 + 2 x 300 = 1400 kilometers. Let\u2019s see if our Hill climber finds one of the shortest routes! There are multiple, since our salesman can start at any city.", "After running the code multiple times (results can differ because the initial solution is random), I consistently see a best route length of 1400. That\u2019s great! Our algorithm finds the best route. Of course, this was a very simple problem, consisting of only 4 cities. Let\u2019s expand on our code a bit, and add a problem generator that can generate larger problems for our Hill climber to solve and see how well it does that!", "As it turns out, it\u2019s quite straightforward to make a problem generator for our situation. Let\u2019s define a function taking one argument: nCities, which specifies the number of cities we want for our Travelling salesman problem. The problem generator can then simply loop nCities times, each time creating a list of distances (distances) for a new city. Such a distance list can be filled with random values, except where the value is already known: when the loop is adding the distance of the city to itself (which should be zero), and when it is adding a value it has already calculated. This last one is the case when the algorithm is adding the distance from city B to city A when it has already added the distance from city A to city B, since these distance should be the same. This requirement is fulfilled in lines 8 and 9.", "Each distances can be simply added to the initially empty tsp list, which in the end is returned.", "Now that we have a problem generator, let\u2019s find out how our Hill climber performs at bigger problems. I modified the main function a bit:", "As you can see, the tsp is now assigned a problem from the problem generator: one with ten cities. The main function calls the Hill climber ten times with this problem, to see whether it gives the same quality solution each time. If it doesn\u2019t, we know the Hill climber doesn\u2019t perform optimally each time! I get these results (remember, yours might be different due to the randomness of the initial solutions):", "As we can see, the score is not the same for each solution. This means our Hill climber isn\u2019t perfect, but I warned about this in the beginning. It would be interesting to compare Hill climbing to more sophisticated algorithms. They may perform better, but take more time to do so. However, this is something for a future post! For now, thanks for reading, and I hope you enjoyed the tutorial!", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "(Functional) decision theorist funded by the Machine Intelligence Research Institute. Top writer in Decision Theory and Game Theory."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F1c65c29469de&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----1c65c29469de--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----1c65c29469de--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@heindehaan?source=post_page-----1c65c29469de--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@heindehaan?source=post_page-----1c65c29469de--------------------------------", "anchor_text": "Hein de Haan"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4d819bf51f5b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&user=Hein+de+Haan&userId=4d819bf51f5b&source=post_page-4d819bf51f5b----1c65c29469de---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F1c65c29469de&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F1c65c29469de&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://en.wikipedia.org/wiki/Travelling_salesman_problem", "anchor_text": "Travelling salesman problem"}, {"url": "https://unsplash.com/@josephljy?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText", "anchor_text": "Joseph Liu"}, {"url": "https://unsplash.com/s/photos/hill?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText", "anchor_text": "Unsplash"}, {"url": "https://en.wikipedia.org/wiki/Hill_climbing", "anchor_text": "Hill climbing"}, {"url": "https://medium.com/tag/hill-climbing?source=post_page-----1c65c29469de---------------hill_climbing-----------------", "anchor_text": "Hill Climbing"}, {"url": "https://medium.com/tag/python?source=post_page-----1c65c29469de---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/optimization?source=post_page-----1c65c29469de---------------optimization-----------------", "anchor_text": "Optimization"}, {"url": "https://medium.com/tag/coding?source=post_page-----1c65c29469de---------------coding-----------------", "anchor_text": "Coding"}, {"url": "https://medium.com/tag/programming?source=post_page-----1c65c29469de---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F1c65c29469de&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&user=Hein+de+Haan&userId=4d819bf51f5b&source=-----1c65c29469de---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F1c65c29469de&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&user=Hein+de+Haan&userId=4d819bf51f5b&source=-----1c65c29469de---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F1c65c29469de&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----1c65c29469de--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F1c65c29469de&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----1c65c29469de---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----1c65c29469de--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----1c65c29469de--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----1c65c29469de--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----1c65c29469de--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----1c65c29469de--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----1c65c29469de--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----1c65c29469de--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----1c65c29469de--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@heindehaan?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@heindehaan?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Hein de Haan"}, {"url": "https://medium.com/@heindehaan/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "454 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4d819bf51f5b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&user=Hein+de+Haan&userId=4d819bf51f5b&source=post_page-4d819bf51f5b--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fa567813ac3a8&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-implement-the-hill-climbing-algorithm-in-python-1c65c29469de&newsletterV3=4d819bf51f5b&newsletterV3Id=a567813ac3a8&user=Hein+de+Haan&userId=4d819bf51f5b&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}