{"url": "https://towardsdatascience.com/understanding-dynamic-programming-75238de0db0d", "time": 1683014667.4960158, "path": "towardsdatascience.com/understanding-dynamic-programming-75238de0db0d/", "webpage": {"metadata": {"title": "Understanding Dynamic Programming | by Aniruddha Karajgi | Towards Data Science", "h1": "Understanding Dynamic Programming", "description": "Dynamic programming, or DP, is an optimization technique. It is used in several fields, though this article focuses on its applications in the field of algorithms and computer programming. Its a\u2026"}, "outgoing_paragraph_urls": [{"url": "http://polaris000.com", "anchor_text": "polaris000.com", "paragraph_index": 115}, {"url": "http://linkedin.com/in/polaris000/", "anchor_text": "linkedin.com/in/polaris000/", "paragraph_index": 115}], "all_paragraphs": ["Dynamic programming, or DP, is an optimization technique. It is used in several fields, though this article focuses on its applications in the field of algorithms and computer programming. Its a topic often asked in algorithmic interviews.", "Since DP isn\u2019t very intuitive, most people (myself included!) often find it tricky to model a problem as a dynamic programming model. In this post, we\u2019ll discuss when we use DP, followed by its types and then finally work through an example.", "There are two necessary conditions a problem must satisfy for DP to work.", "Let's go over these in a little more detail.", "This property is exactly what it sounds like: repeating sub-problems. But for this to make sense, we need to know what a sub-problem is.", "A sub-problem is simply a smaller version of the problem at hand. In most cases, this would mean smaller parameter values which you would pass to your recursive function.", "If you\u2019re looking for a particular page in a book, what would you do? You\u2019d open the book to a particular page and compare the page number you\u2019re on with the page number you\u2019re looking for.", "If the current page is smaller than the required page, you\u2019d start looking in between the current page and the last page. On the other hand, if the current page number is greater, you\u2019d start searching between the start of the book and the current page.", "You\u2019d continue this until you found the page.", "If you had to model this as a recursive function, what would that look like? Maybe something like this.", "Note: The following snippets have been written in a form of pseudocode to improve readability", "Pretty straightforward. There\u2019s a getpage function which returns the page (target_page, here) we\u2019re looking for. The function looks at the middle page between from_page and to_page and checks if we have a match.", "If not, the function looks at either the left half or the right half of the section we are looking at.", "But what do those two recursive calls to getpage represent? You\u2019ll notice that at each recursive call, we are reducing our search space by half. What we\u2019re doing is solving the same problem, that is, looking for a specific page, in a smaller space. We\u2019re solving sub-problems.", "Divide and Conquer, or DAC algorithms work through the principle of sub-problems. The \u201cdivide\u201d part refers to splitting a problem into sub-problems. Sorting algorithms like mergesort and quicksort are great examples. Note that binary search isn\u2019t exactly a DAC algorithm for the simple reason that it doesn\u2019t have a \u201ccombine\u201d step, whereas an actual divide and conquer algorithm would combine the results of its sub-problems to get the final solution.", "Now that we have answered the question of what a sub-problem is, we move on to the other word: \u201coverlapping\u201d.", "When these sub-problems have to be solved more than once, they are said to be overlapping. Look at the call graph for computing the value of the nth Fibonacci term.", "The calls have been shaded to represent overlapping subproblems. Compare this with something like binary search, where the subproblems aren\u2019t overlapping.", "The optimal substructure property is slightly more intricate: it refers to the scenario where optimal solutions to sub-problems can directly be considered when computed the overall optimal solution.", "A quick example? Say you want to find the shortest path from A to B. Let X be an intermediate point between A and B with a single edge connecting it to A.", "To solve this, we can find the shortest path from all intermediate nodes (X) to B, and then find the path from A to X plus the shortest path from X to B which is shortest for all X.", "What we\u2019re doing here is using an optimal intermediate solution (shortest(X, B)) and use that (as opposed to considering every solution for a sub-problem) to find the final optimal answer.", "In a top-down approach, we start from the highest level of our problem. In this approach, we initially check if have already solved the current sub-problem. If we have, we just return that value. If not, we solve that sub-problem. We use recursive calls to solve our sub-problem.", "Since those calls require solving smaller sub-problems which we haven\u2019t seen before, we continue this way, until we encounter a sub-problem we have either solved or know the answer to trivially.", "In this approach, we start at the very bottom and then work our way to the top. Since we start from the \u201cbase case\u201d, and use our recurrence relation, we don\u2019t really need recursion, and so, this approach is iterative.", "The main difference between the two approaches is that bottom-up calculates all solutions, while top-down computes only those that are required. For example, to find the shortest path between source and destination, using the top-down approach, we only compute the distances with intermediate points near the shortest path, choosing the minimum at each stage.", "On the other hand, in a bottom-up approach, we end up calculating the shortest distance between each point on the grid and the destination, finally returning the shortest distance from the start to the end.", "As a comparison, let's look at a possible top-down and bottom-up function that returns the nth Fibonacci term.", "While both approaches have the same asymptotic time complexities, the recursive calls in a top-down implementation may lead to a stack overflow, which is a non-issue owing to the iterative nature of the bottom-up approach.", "Remember that though we implement the latter iteratively, your logic would still use the recurrence relation from the very basic recursive approach, as we shall see in this example.", "Let's go over a problem which we\u2019ll solve using both approaches to dynamic programming.", "Find the maximum sum of elements in an array ensuring that no adjacent elements are included. Let\u2019s assume that no elements are negative.", "First, let's try a greedy approach.", "Since our goal is to maximize the sum of the elements we choose, we could hope to accomplish this by choosing the biggest elements, ignoring its neighbours, and then continuing this way. Here, we\u2019re ensuring that at each step of the way, we have a maximum sum. But this would be correct only in a local context, while we are, of course, looking for a global solution.", "This approach could work in certain cases.", "Here, we first choose 10, since it\u2019s the biggest element. We then ignore its neighbours, so that we don\u2019t violate the condition that we aren\u2019t allowed to choose adjacent elements.", "Next, we choose both the 5\u2019s, since they\u2019re the next biggest elements, and then ignore their neighbours. Our algorithm ends here since there aren\u2019t any elements left. The result we get \u2014 10 + 5 + 5 \u2014 is in fact, the right answer.", "But this won\u2019t always work. Take the following example:", "At every step, if you chose the maximum element, ignored its neighbours and continued that way, you\u2019d end up choosing 10, then 1 and then 1 again after ignoring both the 9's, which would add up to 12, but the right answer would be 1 + 9 + 9 + 1, which is 20.", "Its clear this approach isn\u2019t the right one. Let\u2019s start from a basic recursive solution and work up to one that uses dynamic programming one.", "This is the difference between the greedy and dynamic programming approaches. While a greedy approach focuses on doing its best to reach the goal at every step, DP looks at the overall picture. With a greedy approach, there\u2019s no guarantee you\u2019ll even end up with an optimal solution, unlike DP. Greedy algorithms often get trapped in local maxima, leading to sub-optimal solutions.", "After thinking for a bit, you can probably see that we have a condition to keep in mind: no adjacent elements. You can probably figure out that:", "For the sake of brevity, let f(a..b) represent a call to f our array from index a to index b (both inclusive). That function f would represent our recursive function which would solve the problem.", "So f(0..4) would mean running the function from index 0 to index 4.", "The two arrows pointing from a cell represent our choices of subsequent function calls. Since this is a maximization problem, we\u2019d have to choose the maximum out of these options.", "Let\u2019s come back to our array.", "Keeping the conditions discussed above in mind let\u2019s actually write down what we would be doing.", "Our first call would be on the entire array, which is of length 5 as can be seen above.", "For the element at index 0 (which happens to be 5 here), we can either choose to:", "The graph here visually explains this. As mentioned earlier, all arrows at a given level represent our choices, from which we choose the greatest one.", "So our final answer would be:", "Let\u2019s expand this for the next iteration.", "First, we\u2019ll do it for the left tree, which is f(2..4). This is just like what we did for the first call to f. Remember that the arr[0] + part is still there. It will be added to the value of f(2..4) on our way back up the call tree.", "Just like before, the value of f(2..4) would be the maximum of our two choices.", "What do you think f(4..4) would evaluate to? Following our notation, it is the result of our function call on the array from index 4 to \u2026 well, index 4. That means that we are calling the function on a single element. The maximum sum of a single element is itself.", "Another thing to keep in mind: in f(a..b), a should never be greater than b. Since this call represents starting from index a and going up to index b, we would have to return 0 if a ever gets bigger than b. There is no maximum sum if there are no elements.", "We have our base case here. Our function f, when called on a single element, would return that element directly and returns 0 if we are not in a valid range. There are no further recursive calls. That\u2019s why its called the base case.", "In our case, our call to f(3..4) leads to an invalid call to f(5..4), which we handle by returning 0. We\u2019ll generalize this later.", "Let\u2019s have another look at our results.", "Notice a pattern in the first two results? If we generalize these, we get:", "This still isn\u2019t the most simplified version of our relation. Notice the occurrences of b here. In fact, go back and look at our specific calls in the previous block.", "They don\u2019t change. There\u2019s no b + 1 or b + 2. It\u2019s always b. And what\u2019s the value of b in our first call? The last index. Since b is constant throughout our algorithm, we can remove it.", "where f(a) is a call on the array from index a onwards.", "Another thing to realize is that similar to how we removed b since it was always equal to the last index in the array, the base case, which refers to a single element, would only happen if that element was the last in the array.", "A generalized version of our base case is:", "Let\u2019s implement the recursive approach based on this relation.", "This function would be called like so:", "What would be the complexity of this?", "If we were to approximate the complexity based on the size of the array (n) we are operating on, we get something like this:", "Intuitively, every call to f on an array of size n \u2014 represented as T(n) \u2014 leads to two calls on f on arrays of size n-2 and n-1. That is, at each stage, we\u2019re doubling the number of calls to f.", "The asymptotic time complexity is exponential. With the above reasoning, we get O(2^n).", "This is a loose estimate on the upper bound, since the n-2 tree is bound to end before the n-1 tree, and so we are doing slightly less than doubling the calls. The actual complexity is O(phi^n) \u2014 phi is the golden ratio \u2014 or O(1.618^n), which is slightly lesser than our original estimate, but let's stick to O(2^n).", "Another thing to notice is that the recurrence relation above is similar to that of the nth Fibonacci term, which would hence give a similar complexity.", "Here\u2019s where dynamic programming comes into the picture.", "If you look closely, you\u2019ll see the overlapping sub-problems we were talking about earlier.", "Now comes the important part \u2014 converting this recursive implementation to a dynamic programming approach. What if we stored the values of the function calls that are being repeated?", "Let\u2019s maintain an array where the ith element is the value of f(i), which in turn, is the maximum sum of the array from index i to the end.", "And since we already have a result for f(i),", "Now that we have this relation, we can go two different ways. Either we go the top-down route, where our function is still recursive, like our result above, or we remove all recursive calls and go the bottom-up route.", "We\u2019ll focus on the bottom-up route, but let's discuss the top-down approach.", "That\u2019s all we need to implement the top-down approach. For any call to f, we\u2019ll first check in our array dp if we have already made that call earlier, and if we have, we use the pre-calculated value directly.", "On the other hand, if the call we are making has never been done before, we have to compute the entire thing. In that case, once we arrive at a value, we make sure to store it in our array dp so that we won\u2019t have to repeat the whole process.", "The call tree should look something like this:", "The additional space required to store the results of our sub-problems grows linearly with the size of the input array. Hence, apart from the O(n) space required due to the recursive stack, we have an O(n) space for the dp array, n being the size of the input array.", "The time complexity, though harder to compute, is linear to the input size. This is because we are storing the answers to the sub-problems we have already solved, and so, we have O(n) unique sub-problems that we have to solve. This result can also be verified with the complexity we get using the bottom-up approach.", "Recall that in this approach, we seek to eliminate all recursive calls by following an iterative approach, where we start from the base case, or the \u201cbottom\u201d and make our way up.", "Let\u2019s replace the other calls to f with accessing elements of dp.", "What about the base case, f(n-1) = arr[n-1]? This would be the last element of the array dp.", "And just like that, we have our solution for a bottom-up dp approach!", "Let\u2019s implement this, just like we did for the recursive approach.", "This function would be called like so:", "The complexity here would be linear in both space and time.", "We are running a single for-loop n-1 times, and in each iteration, we are performing constant time operations \u2014 a linear time complexity.", "Since the size of the array dp depends on the size of the input array \u2014 which, of course, is variable \u2014 our space complexity is also linear.", "But can we do better? Let\u2019s see.", "In terms of asymptotic time complexity, we can\u2019t do better. To find the answer, we have to check every element of the array. So we can\u2019t do better than linear time.", "But what about space complexity? Do we need to maintain an array of size n to solve the problem?", "Look closely at the line inside the for-loop:", "At any point of time, all we need to populate dp[i] is the next two elements in dp \u2014 at indices i +1 and i + 2. There\u2019s no reason to maintain all of our results. We just need to keep track of the last two iterations.", "Let\u2019s use three variables here. Let\u2019s name them i_0, i_1 and i_2 for make it easier to relate between them.", "Notice that in the next iteration of our loop, our loop counter i, becomes i + 1, since we\u2019re decrementing i in each iteration. dp[i +1] would be the next dp[i +2], dp[i] would be the next dp[i +1] and dp[i+2] \u2014 which we wouldn\u2019t need since dp[i +3] isn\u2019t required \u2014 can be reused as the next dp[i].", "Replacing this with our three new variables, the code inside our loop becomes:", "We initialize these variables just like our array implementation.", "One last thing to keep in mind: what if the input array has only a single element? Our loop, which runs from n-2 to 0, wouldn\u2019t run even once.", "Hence, we initialize i_0 with the value of i_1. So if the loop never runs \u2014 the input array has only one element \u2014 returning i_0 would return the value of i_1, which is the arrays only element.", "Thus, our final algorithm would look something like this.", "Just like the previous dynamic programming approach, this function would be called by simply passing in an array or a reference to one.", "For an array of any length, all we need is three variables. Thus, the space complexity of our algorithm is now O(1) \u2014 constant.", "Comparing the recursive approach with our top-down approach, it's clear that we are trading space complexity for better time complexity. Of course, since both are recursive, they have the additional space required for the recursive call stack.", "In a similar vein, the lowest two rows are the results of our bottom-up approaches. They are iterative, so they don\u2019t require storing function records recursively on the stack. And since they\u2019re essentially the same algorithm as the top-down approach, they have the same linear time complexity.", "The best case is the bottom up approach requiring O(1) space \u2014 meaning that the space our dp algorithm is using doesn\u2019t change with the input size n.", "Let's implement our final algorithm of constant space bottom-up dynamic programming in C++. The variable and function names are the same as before.", "Note: the final space complexity optimization step is slightly harder to look for, but drastically improves your space usage as we just saw. See if you can spot a similar relation for the bottom-up approach for the nth Fibonacci term.", "Dynamic Programming is not often very intuitive or straightforward. Then again, most complex things aren\u2019t. But things do get easier with practice. There are tonnes of dynamic programming practise problems online, which should help you get better at knowing when to apply dynamic programming, and how to apply it better. Hopefully, this post served as a good starting point.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Data Scientist at Tekion | Samsung Research | GSoC | CS at BITS Pilani \u201921 | polaris000.com | LinkedIn: linkedin.com/in/polaris000/"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F75238de0db0d&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----75238de0db0d--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----75238de0db0d--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://polaris000.medium.com/?source=post_page-----75238de0db0d--------------------------------", "anchor_text": ""}, {"url": "https://polaris000.medium.com/?source=post_page-----75238de0db0d--------------------------------", "anchor_text": "Aniruddha Karajgi"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fdda13b3bf503&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&user=Aniruddha+Karajgi&userId=dda13b3bf503&source=post_page-dda13b3bf503----75238de0db0d---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F75238de0db0d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F75238de0db0d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://app.diagrams.net/", "anchor_text": "draw.io"}, {"url": "https://app.diagrams.net/", "anchor_text": "draw.io"}, {"url": "https://app.diagrams.net/", "anchor_text": "draw.io"}, {"url": "https://app.diagrams.net/", "anchor_text": "draw.io"}, {"url": "https://app.diagrams.net/", "anchor_text": "draw.io"}, {"url": "https://app.diagrams.net/", "anchor_text": "draw.io"}, {"url": "https://app.diagrams.net/", "anchor_text": "draw.io"}, {"url": "https://app.diagrams.net/", "anchor_text": "draw.io"}, {"url": "https://medium.com/tag/programming?source=post_page-----75238de0db0d---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/tag/algorithms?source=post_page-----75238de0db0d---------------algorithms-----------------", "anchor_text": "Algorithms"}, {"url": "https://medium.com/tag/computer-science?source=post_page-----75238de0db0d---------------computer_science-----------------", "anchor_text": "Computer Science"}, {"url": "https://medium.com/tag/dynamic-programming?source=post_page-----75238de0db0d---------------dynamic_programming-----------------", "anchor_text": "Dynamic Programming"}, {"url": "https://medium.com/tag/editors-pick?source=post_page-----75238de0db0d---------------editors_pick-----------------", "anchor_text": "Editors Pick"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F75238de0db0d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&user=Aniruddha+Karajgi&userId=dda13b3bf503&source=-----75238de0db0d---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F75238de0db0d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&user=Aniruddha+Karajgi&userId=dda13b3bf503&source=-----75238de0db0d---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F75238de0db0d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----75238de0db0d--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F75238de0db0d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----75238de0db0d---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----75238de0db0d--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----75238de0db0d--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----75238de0db0d--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----75238de0db0d--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----75238de0db0d--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----75238de0db0d--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----75238de0db0d--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----75238de0db0d--------------------------------", "anchor_text": ""}, {"url": "https://polaris000.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://polaris000.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Aniruddha Karajgi"}, {"url": "https://polaris000.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "276 Followers"}, {"url": "http://polaris000.com", "anchor_text": "polaris000.com"}, {"url": "http://linkedin.com/in/polaris000/", "anchor_text": "linkedin.com/in/polaris000/"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fdda13b3bf503&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&user=Aniruddha+Karajgi&userId=dda13b3bf503&source=post_page-dda13b3bf503--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F2f3b7cea945a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-dynamic-programming-75238de0db0d&newsletterV3=dda13b3bf503&newsletterV3Id=2f3b7cea945a&user=Aniruddha+Karajgi&userId=dda13b3bf503&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}