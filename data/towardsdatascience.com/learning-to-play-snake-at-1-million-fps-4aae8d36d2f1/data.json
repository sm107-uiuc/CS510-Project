{"url": "https://towardsdatascience.com/learning-to-play-snake-at-1-million-fps-4aae8d36d2f1", "time": 1682996322.3576372, "path": "towardsdatascience.com/learning-to-play-snake-at-1-million-fps-4aae8d36d2f1/", "webpage": {"metadata": {"title": "Learning to play snake at 1 million FPS | by Oscar Knagg | Towards Data Science", "h1": "Learning to play snake at 1 million FPS", "description": "In this blog post I\u2019ll guide you through my most recent project, which combines two things I find fascinating \u2014 computer games and machine learning. For quite a while now I\u2019ve wanted to get to grips\u2026"}, "outgoing_paragraph_urls": [{"url": "https://pytorch.org/docs/stable/torch.html?highlight=einsum#torch.einsum", "anchor_text": "torch.einsum", "paragraph_index": 8}, {"url": "https://rockt.github.io/2018/04/30/einsum", "anchor_text": "this", "paragraph_index": 8}, {"url": "https://openreview.net/pdf?id=HkxaFoC9KQ", "anchor_text": "Deep reinforcement learning with relational inductive biases", "paragraph_index": 31}, {"url": "https://arxiv.org/abs/1706.03762", "anchor_text": "Transformer", "paragraph_index": 31}, {"url": "https://openai.com/blog/requests-for-research-2/", "anchor_text": "request for research", "paragraph_index": 42}], "all_paragraphs": ["In this blog post I\u2019ll guide you through my most recent project, which combines two things I find fascinating \u2014 computer games and machine learning. For quite a while now I\u2019ve wanted to get to grips with deep reinforcement learning and I thought there is no better way than to do my own project. To that end I implemented the classic mobile game \u201cSnake\u201d in PyTorch and trained a reinforcement learning algorithm to play it. This post is divided into three parts.", "For all it\u2019s impressive achievements, deep reinforcement learning is very slow. Incredible results have been achieved in complex games like DotA 2 and Starcraft but these have taken 1000s of years of gameplay. In fact even the work that sparked the current wave of interest in deep reinforcement learning, i.e. learning to play Atari games, required weeks of gameplay and 100s of millions of frames for each game.", "A lot of research since then has been done towards speeding up deep reinforcement learning, both in terms of wall clock time by parallelisation and improved implementation and also in terms of sample efficiency. Many state of the art reinforcement learning algorithms are trained in multiple copies of an environment simultaneously, typically one per CPU core. This yields a roughly linear speed up in how fast you can generate gameplay experience with more CPU cores.", "So in order to experiment with deep reinforcement learning you had better have either a lot of computational resources. a very fast/parallel environment or be willing to wait a long time. Since I don\u2019t have access to a large cluster and want to see results fast I decided to create a vectorized implementation of Snake which can achieve a much greater level of parallelisation than the number of CPU cores.", "Vectorization is a form of single instruction, multiple data (SIMD) parallelism. For those of you who are Python programmers this is the reason that numpy operations can often be orders of magnitude faster than explicit for-loops that perform the same calculations.", "Essentially, vectorization is possible because if a processor can perform operations on, say, 256 bits of data in a singe clock cycle and your program\u2019s real numbers are 32 bit single precision numbers then you can pack 8 of these numbers into 256 bits and perform 8 operations with each clock cycle. So if a program is clever enough to schedule instructions such that there are always 8 operands in place at the right time it should be able to achieve, in theory, an 8x speedup over executing instructions on one piece of data at a time.", "The key idea is to represent the full state of the environment as a single tensor. In fact multiple environments are represented as a single 4d tensor in the same way that a batch of images is represented. In the case of Snake each image/environment has three channels: one for food pellets, one for snake heads and one for snake bodies as shown above. Doing this lets us leverage the many features and optimizations that PyTorch already has for manipulating this kind of data.", "So now that we have a way of representing the game environment we need to implement the gameplay using only vectorized tensor operations. The first trick is that we can move the position of all the snake heads in every environment by applying a 2D convolution with a hand crafted filter to the head channel of our environment tensor.", "However PyTorch only lets us apply the same convolutional filter to the whole batch but we need to be able to take a different action in each environment. Hence I apply a second trick to work around this limitation. First apply a convolution with 4 output channels (1 for every direction of movement) to each environment then use the very useful torch.einsum to \u201cselect\u201d the correct action using a one-hot vector of actions. I\u2019d highly recommend reading this article for a very good introduction to Einstein summation and its uses in NumPy/PyTorch/Tensorflow.", "Now that we moved the head we need to move the body. Firstly we move the tail (i.e. the 1 position on the body) forwards by subtracting 1 from all body locations then applying the ReLu function to keep the other elements above 0. Secondly we make a copy of the head channel, multiply it by the maximum body value plus 1. We then add this copy to the head channel which creates a new front position for the body (position 8 in the diagram).", "There\u2019s a bit more logic required such as checking for collisions and food collection, resetting environments after death and checking snakes aren\u2019t trying to move backwards \u2014 it was very fun thinking of ways to implement all this in a way that is vectorized across multiple environments. The end result of all this optimisation is shown in the plots below. With a single 1080Ti and an environment of size 9 I can run a maximum of just over a million steps per second with a random agent and just over 70,000 steps/s while training a convolutional agent with A2C (using the same hyperparameters as for the later results).", "In this section I assume your familiar with the basic terminology of reinforcement learning e.g. value function, policy, rewards, returns etc\u2026", "The idea behind the actor-critic algorithm is simple. You train an actor network to map from observed states to a probability distribution over actions i.e. the policy. The aim of this network is to learn the best actions to take in a particular state.", "At the same time you also train a critic network that maps from states to their expected value i.e. the sum of future rewards expected after being in this state. The aim of this network is to learn how desirable it is to be in a particular state. This network also stabilizes the learning of the policy network by providing a baseline value for states as we\u2019ll see later.", "The loss of the value function is the squared difference between the predicted value of a particular state and the actual return generated from that state. Hence value function learning is a regression problem.", "In practice, calculating the true return for a particular state requires having the trajectory starting from that state until the end of time, or at least until the death of the agent. Due to finite computational resources we calculate the return from a trajectory of a fixed finite length, T, and use bootstrapping to estimate the distant returns after the final trajectory state. Bootstrapping is means we replace the final part of the sum with the predicted value of the final state in the trajectory \u2014 the predictions of the model are used as its targets.", "There is an important result in the field of reinforcement learning known as the Policy Gradient Theorem. This states that for a parametrised policy, (e.g. a neural network mapping from states to actions) their exists a gradient on the parameters that leads to an increase in the performance of the policy, on average. The performance of the policy is defined as the expected value of states over the distribution of states visited by that policy, as shown below.", "This is actually a more surprising result than it first seem. Given a particular state, computing the effect of changing the policy parameters on the actions and hence reward is relatively straightforward. However, we are interested in the expectation of the reward across the distribution of states visited by the policy, which will also change with the policy parameters. The effect of changing the policy on the distribution of states is usually unknown. Hence it is quite remarkable that we can calculate the gradient of the performance with respect to the policy parameters when the performance depends on the unknown effect of policy changes on the state distribution.", "Shown below is the general form of the policy gradient algorithm. A proof and a complete discussion of this theorem is out of scope but I would recommend Chapter 13 of \u201cReinforcement Learning: An introduction\u201d by Sutton and Barto if you\u2019re interested in digging deeper.", "With a little bit of math we can write this as an expectation over a states and actions visited by our policy.", "This expression is a little easier to get an intuition for. The first part in the expectation is the Q-values of state-action pairs seen by the policy i.e. a performance measure. The second part is the gradient that increases the log-probability of a particular action. Intuitively the overall policy gradient is the expectation of individual gradients that increase the probability of high reward actions. Conversely, if Q(s, a) is negative (i.e. bad actions) then individual gradients must decrease the probabilities of these actions.", "An important insight into the policy gradient theorem as stated earlier is that it doesn\u2019t change if an arbitrary action-independent baseline b(s) is added to the Q function.", "Adding this baseline function introduces a new term to the policy gradient, which given that is action-independent, is always equal to 0.", "Although adding a baseline doesn\u2019t affect the expectation of the policy gradient it does affect its variance, so a well chosen baseline can speed up the learning of a good policy.", "The baseline that is chosen in A2C is the advantage function (hence advantage actor-critic). This quantifies how much better a particular state-action pair is when compared to the average action from that state.", "Based on this expression it looks like we will need to learn another network to approximate Q(s, a). However we can rewrite this in a much simpler way.", "We can do this because the definition of the Q function for a particular policy is the reward from action a in state s plus expected return from following that policy for the rest of the episode. Hence the final advantage actor-critic gradient is as follows.", "Now that I\u2019ve sketched out the theoretical underpinnings of A2C its time to see the full algorithm. All we need to obtain an incremental improvement of our policy is a way to obtain samples such that the expectation of the gradient of those sample is proportional to the expression above. This can be achieved very simply by recording trajectories of experience generated by our policy. In order to accelerate this we can run multiple copies of our policy in parallel on the same environment to generate experience faster.", "This is the synchronous version of the famous asynchronous advantage actor-critic algorithm (A3C). The difference is that in A3C the parameter updates are calculated in many worker threads separately and used to update a master network which the other threads periodically synchronize with. In batched A2C the experience from all workers is combined periodically to update the master network.", "The reason that A3C is asynchronous is so that differences in environment speeds in different threads don\u2019t slow each other down. However in my snake environment the environment speeds are always exactly equal by design so a synchronous version of the algorithm makes more sense.", "Now that I\u2019ve described the implementation and theory its time to learn to play snake! In my experiments I compare the performance of three different architectures, pictured below.", "The first agent (left) is a smaller version of the agent from Deepmind\u2019s \u201cDeep reinforcement learning with relational inductive biases\u201d paper. This agent contains a \u201crelational module\u201d which is essentially the self-attention mechanism from the Transformer model applied to a 2D image. After this we apply channel-wise max pooling and a single fully connected layer before the value and policy outputs. For comparison I also implemented a convolutional agent (middle) which is otherwise the same except the relational modules are replaced with more convolutional layers.", "As a dark-horse competitor I introduced a simpler, purely feedforward agent (right) which only takes as input the local area around the head of the snake, making the environment partially observable. The input observation is flattened and passed through two feedforward layers. The value and policy outputs are linear projections of the final activations, just as the other two agents.", "All 3 agents were trained 5 times for 50 million steps on a size 9 environment. The training curves with 1 standard deviation are shown below.", "Its interesting to note that the feedforward agent that only has partial observability of the environment performs very well, achieving the highest average size of all agents. It also learns the quickest, probably due to having the smallest observation space. As you can see from the GIF below it has learnt to avoid the drawback of only having limited visibility by circling the environment so that all of it eventually passes into view. This allows it to find the rewards scattered around the environment but not as efficiently as the convolutional and relational agents.", "The other agents move more or less directly towards the rewards but also have a tendency to make some stupid mistakes, reflected in the fairly high edge collision rate compared to the feedforward agent. Its also interesting to note that for this task the relational agent performs no better than the convolutional agent. I hypothesis that the snake environment is too simple for the inductive biases incorporated into the relational module to be useful. The task on which Deepmind benchmarked the relational agent involved collecting multiple keys for multiple boxes in order to collect a final large reward \u2014 much more complex than snake!", "As a bonus experiment I decided to see what would happen if I transferred the agents from the small size 9 environment to a larger size 15 environment. I evaluated the performance of 5 instances of each type of agent for 1 million steps on the larger environment, with no further training.", "This table a huge variation in transfer performance between agent types and even within particular training runs. The convolutional agents generalise very well, achieving a large average size and high reward rate. In fact the convolutional agents perform better than the same agents trained from scratch in the larger environment. I believe this is because rewards are sparser in the larger environment and so learning is slowed down significantly in the larger environment.", "Some fairly clever behaviour can be observed. At large snake sizes the convolutional agent will sometimes be seen to perform a \u201ccoiling\u201d maneuver while it waits for its tail to move out of the way.", "The limited visibility agent continues the same strategy of circling around the edge of the environment. This can perform quite well until a food pellet spawns in the center of environment which the agent is not able to observe and from this point on the agent collects no more reward. This is consistent with the large size and small reward rate in the table above.", "The performance of the relational agent is unstable to say the least. In some runs it will perform quite well, while in others it will die almost immediately or get stuck in a loop.", "In this project I\u2019ve seen firsthand the slowness of deep reinforcement learning and come up with a neat, if brute-force way of getting around it. I\u2019ve also experienced the brittle nature of deep RL by observing failed transfer between quite similar environments.", "In future work I\u2019d like to implement more gridworld games in order to investigate transfer learning between games. Or perhaps I will implement a multi-agent snake environment in order to answer OpenAI\u2019s \u201cSlitherin\u2019\u201d request for research.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "I like to build novel things"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F4aae8d36d2f1&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@oknagg?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@oknagg?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": "Oscar Knagg"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc510ccc9027c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&user=Oscar+Knagg&userId=c510ccc9027c&source=post_page-c510ccc9027c----4aae8d36d2f1---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F4aae8d36d2f1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F4aae8d36d2f1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://github.com/oscarknagg/wurm/tree/medium-article-1", "anchor_text": "https://github.com/oscarknagg/wurm/tree/medium-article-1"}, {"url": "https://pytorch.org/docs/stable/torch.html?highlight=einsum#torch.einsum", "anchor_text": "torch.einsum"}, {"url": "https://rockt.github.io/2018/04/30/einsum", "anchor_text": "this"}, {"url": "https://gist.github.com/oscarknagg/863602483afc83d698ce399a67eb21d4", "anchor_text": "this gist"}, {"url": "https://gist.github.com/oscarknagg/627dbcfe020cc63dd47d57e1cf6b076c", "anchor_text": "this gist"}, {"url": "https://openreview.net/pdf?id=HkxaFoC9KQ", "anchor_text": "Deep reinforcement learning with relational inductive biases"}, {"url": "https://arxiv.org/abs/1706.03762", "anchor_text": "Transformer"}, {"url": "https://openai.com/blog/requests-for-research-2/", "anchor_text": "request for research"}, {"url": "https://github.com/oscarknagg/wurm/tree/medium-article-1", "anchor_text": "https://github.com/oscarknagg/wurm/tree/medium-article-1"}, {"url": "https://medium.com/tag/machine-learning?source=post_page-----4aae8d36d2f1---------------machine_learning-----------------", "anchor_text": "Machine Learning"}, {"url": "https://medium.com/tag/reinforcement-learning?source=post_page-----4aae8d36d2f1---------------reinforcement_learning-----------------", "anchor_text": "Reinforcement Learning"}, {"url": "https://medium.com/tag/gaming?source=post_page-----4aae8d36d2f1---------------gaming-----------------", "anchor_text": "Gaming"}, {"url": "https://medium.com/tag/data-science?source=post_page-----4aae8d36d2f1---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/towards-data-science?source=post_page-----4aae8d36d2f1---------------towards_data_science-----------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F4aae8d36d2f1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&user=Oscar+Knagg&userId=c510ccc9027c&source=-----4aae8d36d2f1---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F4aae8d36d2f1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&user=Oscar+Knagg&userId=c510ccc9027c&source=-----4aae8d36d2f1---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F4aae8d36d2f1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F4aae8d36d2f1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----4aae8d36d2f1---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----4aae8d36d2f1--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@oknagg?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@oknagg?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Oscar Knagg"}, {"url": "https://medium.com/@oknagg/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "654 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc510ccc9027c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&user=Oscar+Knagg&userId=c510ccc9027c&source=post_page-c510ccc9027c--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F3bb863a32894&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearning-to-play-snake-at-1-million-fps-4aae8d36d2f1&newsletterV3=c510ccc9027c&newsletterV3Id=3bb863a32894&user=Oscar+Knagg&userId=c510ccc9027c&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}