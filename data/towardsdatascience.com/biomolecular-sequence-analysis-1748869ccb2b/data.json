{"url": "https://towardsdatascience.com/biomolecular-sequence-analysis-1748869ccb2b", "time": 1683008807.6384141, "path": "towardsdatascience.com/biomolecular-sequence-analysis-1748869ccb2b/", "webpage": {"metadata": {"title": "Biomolecular Sequence Analysis. Part I: Sequence Similarity Searches | by Arun Jagota | Towards Data Science", "h1": "Biomolecular Sequence Analysis", "description": "At one level, biomolecular sequences are \u201cjust\u201d strings on a fixed alphabet. This might be appealing to computer scientists who, even if finding molecular biology mysterious and intriguing\u2026"}, "outgoing_paragraph_urls": [], "all_paragraphs": ["At one level, biomolecular sequences are \u201cjust\u201d strings on a fixed alphabet. This might be appealing to computer scientists who, even if finding molecular biology mysterious and intriguing, definitely understand strings and alphabets!", "In DNA and RNA this alphabet is A, C, T, and G. In protein sequences, this alphabet is the twenty amino acids that makeup proteins. Of course, a lot is happening inside and across the sequences. This is the realm of molecular biologists and bio technicians.", "In this post, we discuss the single most useful computational algorithm and tool in all of biomolecular sequence analysis: searching a new sequence against a database of known sequences to find similar ones.", "Why Sequence Similarity Searches Are Important", "Consider a database of known protein sequences, annotated with what is known about them, such as their functions and their evolutionary lineages. Consider a newly determined sequence. Searching the database to find sequences highly similar to this new sequence can be quite revealing. It might help shed light on where this sequence sits in the evolutionary hierarchy. It might also yield insights into the functional role of this sequence.", "Take the COVID-19 sequence. Who knows what we might discover by searching it against a database of known viral sequences.", "This will immensely help understand the similarity-search issues that follow. Trust me.", "We\u2019ll pick DNA sequences. Just because their alphabet is simpler to describe. The lessons from this game will apply equally well to protein sequences.", "The overall structure of the game is:", "We will focus on three types of mutation operations: inserting a new symbol at a certain position, deleting the symbol at a certain position, and substituting the symbol at a certain position with another symbol. The third one is done via a substitution matrix that captures replacement preferences. Let\u2019s call these three operations I, D, and S respectively.", "We\u2019ll assume each of I and D has a fixed probability that does not depend on the position in the sequence at which the mutation is done. (This assumption can be relaxed. In some specialized use cases, this can be very helpful. However, it has training data and algorithmic consequences.) The substitutions will also be modeled with probabilities.", "Let\u2019s see an example. (We\u2019ll express probabilities as percentages.) Say P(I) = 5% and P(D) = 8%. This means that at any position there is a 5% chance of inserting a character and an 8% chance of deleting a character. We assume the character to insert is randomly chosen. (More advanced models allow the distribution over the character to be inserted to depend on the position. In some use cases, this can be very helpful. However, it also complicates the modeling.)", "First, let\u2019s bring out its characteristics. Every row sums to 100%. This is because self-substitutions are included. So, at every position, some substitution must happen. Second, the diagonal terms are close to 100%. This models that self-substitutions are far more likely than ones that change the symbol. Finally, note that our substitution matrix is not symmetric. Symmetry is an extra unnecessary assumption at this stage.", "Let\u2019s run through a mental simulation of mutating a single sequence. We\u2019ll take an input sequence and probabilistically apply the three mutation operations at each position, starting from the left end. We will show all intermediate sequences in which there is a change.", "Our starting sequence is silly; nonetheless, it will do the job we have set for it.", "The first mutation is an insert, of T, immediately after position 2. The second one is the substitution A \u2192 G. We\u2019ve marked these two in bold. The third one is the deletion of the second last character in the sequence. We\u2019ve marked this deletion with a ^.", "Finally, we can simulate longer-term evolution by simply repeating this process multiple times. That is, we take multiple mutating passes over the sequence. Not surprisingly, the more passes we take, the more the final mutated sequence differs from the one we began with. Mutated sequences that result are called distant homologs (of the starting sequence).", "Now that we understand in detail what\u2019s involved in mutating a single sequence, let\u2019s move on to mutating several. This is of course what happens in reality. Equally important for our purposes, it will help us better understand why sequence similarity algorithms are as intricate as they are. Simply put, the more sequences we mutate, the harder it will get to discern which sequence a mutated sequence evolved from.", "To drive home the point of the previous sentence, we will start with an example even sillier than our first one!", "Each of the three sequences, AAA, ACC, and TTT, is mutated. Note that the first sequence undergoes two mutations.", "Now let\u2019s set our database of known sequences to be the one we started with: {AAA, ACC, TTT}. Consider searching ACA against it. It's reasonable to expect two results will be found: AAA and ACC, as they are both similar enough to ACA. Next, consider searching CTT against the database. In this case, only one result will be found, TTT, at the same level of similarity.", "What\u2019s the point we are trying to make with this comparison?", "The result ACA \u2192 AAA is not as statistically significant as the result CTT \u2192 TTT because there are two sufficiently similar results to the query ACA whereas only one to the query CTT. This also makes intuitive sense, right? We are somewhat more confident about the result of CTT \u2192 TTT because it is unique. Less so in ACA \u2192 AAA because it is not.", "The intuition becomes more convincing if we scale this example up to reality. When searching a database of millions of sequences under a sufficiently high similarity threshold, one query may return a unique result, a second one thousands of results. Clearly, the first query\u2019s result has a way higher significance than any of the second\u2019s.", "To this point, we have used the terms \u201csimilar\u201d and \u201csimilarity threshold\u201d loosely. Now let\u2019s formalize them. This will help us understand the aforementioned issues more concretely. It is also a bridge to more advanced similarity measures that we will see when we cover specific similarity algorithms.", "The edit distance of two sequences is the minimum number of mutations it takes to transform one into the other. Consider (AAA, ACA). Their edit distance is 1 as we can transform one to the other via a single substitution.", "Edit distance is a good approximate measure to quantify the similarity between two sequences. We say \u201capproximate\u201d for the following reasons. First, it is possible that more mutations happened than what edit distance suggests. Take our example AAA \u2192 \u2026 \u2192 ACA. This involved two mutations. The edit distance suggests one. Second, the edit distance does not capture the varying probabilities of the specific mutations: insertion, deletion, and specific substitutions.", "Okay, let\u2019s reexpress the example we saw a while back, in the language of edit distance. Our database was {AAA, ACC, TTT} . Searching ACA against it finds two results at edit distance 1. Searching CTT finds one result at an edit distance of 1.", "All three results have the same edit distance to the query. However, as discussed earlier, the third result is more statistically significant than the first two. That is, it is more trust-worthy.", "Clearly, edit distance is incapable of measuring statistical significance. We need a separate mechanism. We won\u2019t discuss it in detail. It embodies the principle we already discussed: the more results a query returns, the less trust should be assigned to anyone of them.", "Statistical significance of results goes from being \u201cvery important\u201d to \u201cextremely important\u201d in the setting of what is called \u201clocal alignment\u201d searches. We have not discussed \u201clocal alignment searches\u201d so far. So the reader may have no idea what we mean. However, we thought it important to make this point at this stage.", "We have seen the various mutation operators. Now let\u2019s describe the sequence similarity algorithms that take these into account.", "First, we need another key concept. The global alignment of two sequences (of the same type: DNA or protein) is a 1\u20131 correspondence between their symbols that respects sequence order. Let\u2019s see an example.", "We see two global alignments of the two sequences ACAT and AACT. The \u2018-\u2019 symbols in the alignment on the left denote \u201c\u2018nothing\u2019 aligned to a symbol\u201d. These achieve the effect of shifting one or the other sequence so that the aligned symbols are compatible. The second alignment does not use any \u2018-\u2019 symbols.", "Instinctively, the reader might guess that the alignment on the left is better than the one on the right. The reader would be right. This will come out below.", "Next, we describe the concept of the score of a global alignment. The form most commonly used, and indeed the one used by the algorithms we will describe, simply sums up the scores of the various aligned pairs in the alignment.", "Here is an example. Consider the alignment on the left, which may be expressed as {(A,A),(-,A),(C,C),(A,-),(T,T). The score of this alignment may be depicted as", "The bold-faced terms correspond to the substitutions we saw earlier in the mutation game. The italicized terms correspond to the insert and delete mutations.", "A key point is that although sequence similarity algorithms are at least partly motivated by the mutation game considerations, in practice when comparing two sequences we often don\u2019t know which plays the role of ancestor and which the descendant.", "In fact, in many use cases, there may not even be such a relationship. Imagine trying to discern whether two sequences are siblings of a not too distant ancestor. High sequence similarity may help here. Clearly, there is no ancestor-descendant relationship, only a sibling one.", "In view of the above, it makes sense for similarity algorithms to treat the two sequences symmetrically. A consequence of this is that an occurrence of \u2018-\u2019 in an alignment can no longer be resolved as an insert or a delete. Consider the aligned pair (X=A-,Y=AA). The \u2018-\u2019 may be viewed as a delete if we think of Y as the ancestor and an insert if we think of X as the ancestor. For this reason, from now on we call a \u2018-\u2019 an indel. In fact, we will take this one step further. We\u2019ll use the term gap for indel, as it sounds better.", "A further consequence of this is that the cost of aligning a gap with an actual character is the same, regardless of whether the gap is at the top or at the bottom.", "Next, let\u2019s refine our score example in light of the points we\u2019ve made in the above paragraph. S(A, A), S(C, C), and S(T, T) are all scores from a DNA substitution matrix. S(-, A) and S(A, -) are both specified by a single negative number, called gap cost. This number is negative because it is a cost.", "Let\u2019s now elaborate a bit on the DNA substitution matrix. This is qualitatively similar to the DNA substitution matrix we saw earlier, in the mutation game. Qualitatively similar but not identical.", "If you are curious as to why the two substitution matrices can differ, read the next paragraph, else skip it (it's a bit long, plus a bit off our main path in this post).", "For reasons discussed earlier, similarity algorithms treat the two sequences symmetrically. So this means that our substitution matrix also needs to be symmetric. By contrast, the evolutionary substitution matrix needn\u2019t be. A second reason is that we are summing up the scores of individual aligned pairs. In our example, restricting to terms involving substitutions, this is S(A, A) + S(C, C) + S(T, T). If the substitution matrix entries were probabilities (as they were in the mutation game setting) we would be multiplying instead. Actually there is more to it. We\u2019ll just state it without explanation. The score S(X, Y) of an aligned pair (X, Y) of symbols is defined as log [P(X, Y)/[P(X)P(Y)]] where P(X, Y) is the probability of seeing the aligned pair (X, Y) in a real global alignment and P(X) and P(Y) are the probabilities of seeing X and Y in real sequences.", "Okay, back to the main path. For illustration purposes, even the following substitution matrix will suffice:", "Given this substitution matrix, we\u2019d want to choose a gap cost whose absolute value is less than 1. Let\u2019s set it to -\u00bd.", "Okay, now we have everything in place to calculate the exact scores of our two global alignments:", "The first alignment scores higher, as desired!", "We now know how to score a global alignment. Next, we cover how to find a high-scoring alignment among the many there are. This is where more magic happens.", "We are given two DNA sequences X and Y, the substitution matrix M, and the gap cost C < 0. Our aim is to find the highest-scoring alignment of X and Y.", "The exhaustive search approach of generating every alignment, scoring each, and picking the one that scores the highest is excessively slow on long sequences. There are too many alignments to wade through!", "Fortunately, there is a clever algorithm that is guaranteed to find an optimal alignment much faster. It uses an approach called dynamic programming.", "The algorithm involves building a matrix S with n+1 rows and m+1 columns where n and m are the lengths of X and Y respectively.", "Next, comes a key point. Take the time to absorb it. Less than a minute, I promise.", "Why is this important? The key idea in the algorithm is to optimally solve smaller versions of the problem, and from these build-out optimal versions for larger versions. Specifically, we start filling in the matrix from the top-left corner and eventually stop when we reach the bottom-right corner. (We\u2019ll cover a full end-to-end example soon.)", "We start by setting S(0,0) to 0. This makes sense. There is nothing to align, so it scores \u201cnothing\u201d, whose numeric translation is 0. (Note that \u201cnothing\u201d is not the same as \u201cnot knowing\u201d.)", "Next, we set S(i,0) to i*C for all i > 0 and S(0,j) to j*C for all j > 0. Why? Consider S(i,0). It is the score of the best alignment of X[1..i] with the empty prefix of Y. There is only one such alignment, in which X[1..i] is aligned with i gaps. The score of this alignment is i*C. Similarly, we can see why S(0,j) is set to j*C.", "The next key point comes now. How to compute S(i,j) from the scores in the S matrix till then. Here is the formula", "The second term in the max corresponds to extending the best alignment of X[1..i] and Y[1..j-1] by adding the aligned pair (-,Y[j]). The X portion is a gap because the alignment being extended already has X[i] in it.", "The third term is the second one with i and j interchanged.", "S(i,j) is set to the \u201cbest of the best\u201d, i.e. to the maximum of these terms.", "The algorithm presented so far only finds the score of an optimal global alignment, not the alignment itself. Before we cover the latter topic, let\u2019s see an end-to-end example, first, as there is a lot to absorb even just in the scoring part.", "We\u2019ll use the substitution matrix S(x,y) = 1 if x equals y and -1 if not. We\u2019ll use the gap cost -\u00bd. We will compute the global alignment score of X = ACA and Y = AAC. (Even in this simple example, the score matrix that results will be surprisingly rich!)", "Before walking through explaining the various values in this matrix, let\u2019s check whether the final score, the bottom-right one of \u20181\u2019, is correct. For our substitution matrix and gap cost, the best alignment of ACA and AAC is", "The score of this alignment is indeed 1.", "Now let\u2019s discuss some of the various scores in this matrix. The scores in the first row and the first column correspond to aligning a contiguous string of gaps with a prefix of the other sequence. We\u2019ve seen this earlier, as an initialization step.", "Next, let\u2019s look at the score S(1,1). This represents the score of the best alignment of A with A. It is 1, as it should be. Its value comes from the term S(0,0) + M(A,A) = 0 + 1 = 1. It\u2019s easy to check that the scores coming from the other terms, i.e. those involving S(0,1) and S(1,0), are lower.", "Next, we\u2019ll look at the score S(3,2). This represents the score of the best alignment of ACA with AA. We can see that this alignment must be of the form (ACA, A-A). Its score is 2\u2013\u00bd =3/2 which is exactly what we see.", "Reconstructing the Best Alignment From The Score Matrix", "In many use cases, such as database similarity search, scoring two sequences for similarity suffices. The results of a similarity database search may be ranked using the query-result similarity scores alone.", "In other use cases, we also need to find the actual best-scoring alignment. We now cover this.", "The key idea is this: as we are building the scoring matrix, we record which of the terms was used in computing a cell\u2019s value. That is, in computing S(i,j), which of the values, S(i-1,j-1), S(i,j-1), or S(i-1,j) was used. (If multiple were used, we should record all if we want to find all optimal global alignments, or break ties arbitrarily if we only seek one.)", "Let\u2019s see a version of our example with this additional meta-data added in. In computing S(i,j), D denotes that S(i-1,j-1) was used, L denotes that S(i,j-1) was used, and U denotes that S(i-1,j) was used. D, L, and U correspond to diagonal, left, and up respectively.", "Traceback Phase: Once the full score matrix (including the meta-data) has been built, an actual optimal alignment is reconstructed by \u201ctracing back\u201d in reverse. This may be seen as just following the back pointers starting from the bottom-right cell in the matrix.", "Let\u2019s illustrate this in our example. We start from the cell (3,3). The metadata attached here is (L, U). Let\u2019s make an arbitrary choice: L. So we move left, ending up at cell (3,2). At cell (3,2) we have a D. So we move diagonally, to cell (2,1). At cell (2,1) we have a U. So we move up, to cell (1,1). At cell (1,1) we have a D, so we move diagonally to cell (0,0).", "We started from the end and reached the beginning. So we are done. (We still have to fill in some details, though \u2014 in fact, the actual alignment.) Let\u2019s see the actions we took in the order we took them.", "Great. But where is the alignment? This is what we discuss next. First let\u2019s see the sequences again, in their 2D arrangement, so we can visualize them as the explanation unfolds.", "The alignment will be layered on the scaffolding we have just seen. Our first move is L from the cell (3,3). Visualize it as moving left off Y[3] = C, while staying at X[3]. Next, think of this as creating the aligned pair (-,C), i.e. a gap in X aligned with Y[3].", "Our next move is D from the cell (3,2). Visualize this move as moving left off each of X[3] and Y[2]. Think of this as creating the aligned pair (X[3], Y[2]) = (A, A).", "Our next move is U from the cell (2,1). This is an up move. It creates the aligned pair (C,-). Our last move is a D from the cell (1,1). It creates the aligned pair (A, A).", "Okay, let\u2019s see all of this appended to our scaffolding.", "This is the alignment in reverse. Reversing it gives", "which we can see is an optimal alignment.", "Often we are interested in aligning two sequences locally rather than globally. In a local alignment, a contiguous slice of one sequence is aligned with a contiguous slice of another. This involves both finding similar slices and aligning them.", "Below is an example of a local alignment. This one does not have any gaps within the alignment.", "A common use case of local alignments involves identifying conserved regions in protein sequences. Such regions, called domains, can evolve and function independently of the rest of the protein. Most proteins have multiple domains. The domains determine the function of a protein. Therefore identifying the domains in a protein sequence is very useful. Typically this is done via local alignment searches of a protein sequence whose domain(s) are uncharacterized, against a database of protein sequences with known domains. Or against a database of domain sequences.", "Here is a second scenario involving local alignments. We have a sequence of a gene. We are interested in finding all genomes containing a gene highly similar to it. This involves doing a local alignment search with this gene\u2019s sequence as the query, and a suitable database of full genomic sequences as the target.", "Optimal Local Alignment Of Two Sequences", "The global alignment algorithm described earlier may be tweaked to find an optimal local alignment instead.", "The key change involves replacing the global alignment equation that computes a cell\u2019s score by", "The only difference is the bolded 0. How do we think of this? If all of the first three terms are negative, the algorithm stops extending the previous alignment and instead starts a new local alignment from (X[i],Y[j]). This option is not available in a global alignment \u2014 all one can do is extend. The global alignment must start at the cell (0,0). By contrast, a local alignment can start from any cell.", "For the same reason, the initialization step is also modified, as follows:", "A second change involves where to start reconstructing the best local alignment from. In the global alignment case, it was from S(m,n) where m and n are the lengths of X and Y respectively. In the local alignment case, the alignment can end anywhere. So instead the cell that represents the end of an optimal local alignment is the one containing the maximum value in the scoring matrix. The traceback phase starts from this cell. It then reconstructs an optimal alignment exactly as the global aligner did, except that it stops at the first cell it encounters during its reconstruction whose value is 0.", "Both the local and global alignment algorithms are computationally intensive. Using them to compare a query against each of the sequences in the database can be very slow.", "A tool called BLAST (Basic Local Alignment Search Tool) relinquishes the goal of finding an optimal alignment in favor of finding a \u201csufficiently good\u201d one, via an algorithm that is much faster. BLAST is the most widely-used software in all of biomolecular sequence analyses.", "At a high level, here is how BLAST works.", "First, it identifies the k-grams in the query sequence. (A k-gram is just a contiguous slice of length k in a sequence). The default value for k is much larger for DNA sequences than protein sequences.", "Next, it adds new k-grams to this list. This step is done especially for protein sequences. It involves finding k-grams that score sufficiently high for a suitably chosen substitution matrix. No gaps are permitted, so this involves just simple scoring. No score matrix; no traceback. The construction of sufficiently similar pairs of k-grams can be done off-line. This speeds up the process of finding k-grams similar to ones in the query.", "Next, BLAST finds all sequences in the database that contain at least one k-gram in this list. (Computer scientists, this is similar to finding candidate documents in a search engine using an inverted index on the words.)", "Next, it considers each such occurrence, called a hit, and tries to extend it in both directions. Think of this process as aiming to find an optimal local alignment anchored at that hit.", "Next, it computes a statistical significance score for the alignment. Although the details are sophisticated, the high-level aim is what we discussed earlier in this post. It is to take into account how likely the local alignment is to have arisen by chance. The score will be high when this (chance) likelihood is low.", "Finally, the local alignments are output in order ranked according to their statistical significance scores.", "Our aim is to illustrate the BLAST algorithm in the simplest way. The example is wholly unrealistic. For instance, its choice of k is too small to work well in practice.", "Say our query sequence is ACATGA. Say we choose k = 3. The k-grams in this sequence are", "For the next step, of adding more k-grams similar to these ones, imagine, just for illustration, that the chosen substitution matrix considers the substitutions C \u21d4 G and A \u21d4 T to be compatible, the rest not. Assuming the score threshold is chosen so that at most one of these substitutions is permitted, this would result in adding the following k-grams to the above list", "There are a few duplicates. Still, whew!", "Next, we search the database to find sequences containing at least one k-gram in our list above. Say one of the sequences we found is TTACAAGACC. Here the bold region flags one of the hits to our list of k-grams. Next, we anchor the alignment of the query to this sequence at this hit, as shown below.", "Next, we try to extend the alignment in both directions so long as the score keeps increasing. In our case, this alignment will cover the entire query sequence.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "PhD, Computer Science, neural nets. 14+ years in industry: data science algos developer. 24+ patents issued. 50 academic pubs. Blogs on ML/data science topics."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F1748869ccb2b&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://jagota-arun.medium.com/?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": ""}, {"url": "https://jagota-arun.medium.com/?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": "Arun Jagota"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fef9ed921edad&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&user=Arun+Jagota&userId=ef9ed921edad&source=post_page-ef9ed921edad----1748869ccb2b---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F1748869ccb2b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F1748869ccb2b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://unsplash.com/@5tep5?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText", "anchor_text": "Alexander Popov"}, {"url": "https://unsplash.com/s/photos/dna?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText", "anchor_text": "Unsplash"}, {"url": "https://blast.ncbi.nlm.nih.gov/Blast.cgi", "anchor_text": "Basic Local Alignment Search ToolThe Basic Local Alignment Search Tool (BLAST) finds regions of local similarity between sequences. The program compares\u2026blast.ncbi.nlm.nih.gov"}, {"url": "https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm#:~:text=The%20Smith%E2%80%93Waterman%20algorithm%20performs,acid%20sequences%20or%20protein%20sequences.&text=Like%20the%20Needleman%E2%80%93Wunsch%20algorithm,is%20a%20dynamic%20programming%20algorithm.", "anchor_text": "https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm#:~:text=The%20Smith%E2%80%93Waterman%20algorithm%20performs,acid%20sequences%20or%20protein%20sequences.&text=Like%20the%20Needleman%E2%80%93Wunsch%20algorithm,is%20a%20dynamic%20programming%20algorithm"}, {"url": "https://medium.com/tag/local-alignment?source=post_page-----1748869ccb2b---------------local_alignment-----------------", "anchor_text": "Local Alignment"}, {"url": "https://medium.com/tag/global-alignment?source=post_page-----1748869ccb2b---------------global_alignment-----------------", "anchor_text": "Global Alignment"}, {"url": "https://medium.com/tag/protein-sequences?source=post_page-----1748869ccb2b---------------protein_sequences-----------------", "anchor_text": "Protein Sequences"}, {"url": "https://medium.com/tag/dna-sequences?source=post_page-----1748869ccb2b---------------dna_sequences-----------------", "anchor_text": "Dna Sequences"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F1748869ccb2b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&user=Arun+Jagota&userId=ef9ed921edad&source=-----1748869ccb2b---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F1748869ccb2b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&user=Arun+Jagota&userId=ef9ed921edad&source=-----1748869ccb2b---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F1748869ccb2b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F1748869ccb2b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----1748869ccb2b---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----1748869ccb2b--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----1748869ccb2b--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----1748869ccb2b--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----1748869ccb2b--------------------------------", "anchor_text": ""}, {"url": "https://jagota-arun.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://jagota-arun.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Arun Jagota"}, {"url": "https://jagota-arun.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "685 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fef9ed921edad&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&user=Arun+Jagota&userId=ef9ed921edad&source=post_page-ef9ed921edad--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F1638f1de39a6&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbiomolecular-sequence-analysis-1748869ccb2b&newsletterV3=ef9ed921edad&newsletterV3Id=1638f1de39a6&user=Arun+Jagota&userId=ef9ed921edad&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}