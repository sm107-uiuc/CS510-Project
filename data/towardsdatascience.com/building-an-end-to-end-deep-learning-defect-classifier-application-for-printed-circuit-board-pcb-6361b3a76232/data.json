{"url": "https://towardsdatascience.com/building-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232", "time": 1683003565.728371, "path": "towardsdatascience.com/building-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232/", "webpage": {"metadata": {"title": "Building an End-to-End Defect Classifier Application for Printed Circuit Boards | by Sean McClure | Towards Data Science", "h1": "Building an End-to-End Defect Classifier Application for Printed Circuit Boards", "description": "The Printed Circuit Board (PCB) is in most electronic products, mechanically supporting and connecting components along conductive tracks. Their prevalence underlies the modern electronics industry\u2026"}, "outgoing_paragraph_urls": [{"url": "https://en.wikipedia.org/wiki/Printed_circuit_board", "anchor_text": "Printed Circuit Board", "paragraph_index": 0}, {"url": "https://github.com/sean-mcclure/defect_classifier", "anchor_text": "GitHub", "paragraph_index": 5}, {"url": "https://twitter.com/sean_a_mcclure", "anchor_text": "Twitter", "paragraph_index": 6}, {"url": "https://en.wikipedia.org/wiki/Transfer_learning", "anchor_text": "transfer learning", "paragraph_index": 20}, {"url": "https://colab.research.google.com", "anchor_text": "Google Colab", "paragraph_index": 22}, {"url": "https://github.com/sean-mcclure/defect_classifier", "anchor_text": "defect_classifier", "paragraph_index": 25}, {"url": "https://en.wikipedia.org/wiki/Graphics_processing_unit", "anchor_text": "Graphical Processing Units", "paragraph_index": 31}, {"url": "https://towardsdatascience.com/step-by-step-guide-to-creating-r-and-python-libraries-e81bbea87911", "anchor_text": "here", "paragraph_index": 32}, {"url": "https://github.com/tangsanli5201/DeepPCB", "anchor_text": "GitHub", "paragraph_index": 38}, {"url": "https://docs.opencv.org/trunk/d4/d73/tutorial_py_contours_begin.html", "anchor_text": "OpenCV", "paragraph_index": 48}, {"url": "https://github.com/sean-mcclure/defect_turker", "anchor_text": "GitHub", "paragraph_index": 66}, {"url": "http://localhost:8000/", "anchor_text": "http://localhost:8000/", "paragraph_index": 72}, {"url": "https://www.fast.ai/", "anchor_text": "fastai", "paragraph_index": 82}, {"url": "https://course.fast.ai/", "anchor_text": "courses", "paragraph_index": 83}, {"url": "https://www.fast.ai/2018/10/02/fastai-ai/", "anchor_text": "software", "paragraph_index": 83}, {"url": "https://www.theverge.com/2018/5/7/17316010/fast-ai-speed-test-stanford-dawnbench-google-intel", "anchor_text": "research", "paragraph_index": 83}, {"url": "https://forums.fast.ai/", "anchor_text": "community", "paragraph_index": 83}, {"url": "https://en.wikipedia.org/wiki/Oversampling_and_undersampling_in_data_analysis", "anchor_text": "downsample", "paragraph_index": 90}, {"url": "https://pytorch.org/docs/stable/torchvision/models.html", "anchor_text": "torchvision", "paragraph_index": 106}, {"url": "https://en.wikipedia.org/wiki/Transfer_learning", "anchor_text": "transfer learning", "paragraph_index": 106}, {"url": "https://arxiv.org/pdf/1512.03385.pdf?", "anchor_text": "paper", "paragraph_index": 107}, {"url": "https://en.wikipedia.org/wiki/CUDA", "anchor_text": "CUDA", "paragraph_index": 113}, {"url": "https://sgugger.github.io/the-1cycle-policy.html", "anchor_text": "here", "paragraph_index": 114}, {"url": "https://azlejs.com", "anchor_text": "Azle", "paragraph_index": 146}, {"url": "https://stackoverflow.com/questions/ask?tags=azle+javascript", "anchor_text": "Stack Overflow", "paragraph_index": 176}], "all_paragraphs": ["The Printed Circuit Board (PCB) is in most electronic products, mechanically supporting and connecting components along conductive tracks. Their prevalence underlies the modern electronics industry, with a world market exceeding $60 billion\u00b9.", "PCBs are prone to a variety of defects that impede proper manufacturing, costing companies money. Defects such as shorts, spurs, mousebites, and pinholes cause issues like current leakage and open circuits, quickly degrading performance or rendering PCBs useless. PCB manufacturers must strive to ship defect-free units to remain competitive and ensure customer satisfaction.", "Failure analysts are employed to ensure defects are kept to a minimum. But inspecting and diagnosing defects manually is challenging. There are multiple defects to detect, an extremely low tolerance for errors, and significant expertise required to reliably recognize and handle flawed units. Considering the time to train new analysts, and the cognitive load required to ensure reliability, an automated solution to detecting and classifying defects in PCBs is in demand.", "In this article we will build a full PCB Defect Classifier that automates the task of detecting and classifying defects in printed circuit boards. I always encourage AI practitioners to build full products rather than throwing models over the fence to developers and other engineers. Your machine learning must exist in concert with a full application; thus only through its survival inside a holistic product can you be certain you\u2019re building for users, not engineers.", "Play the following video to see the application we will be building in this article:", "In this article I will go over the application\u2019s back-end and front-end code. I will walk through all of the code related to defect detection, extraction, and prediction. Thus the machine learning aspects will be covered in full. However I will only review the high-level aspects of the actual application pipeline code and front-end code, in order to keep this article to a reasonable size. Note that the entire application and its code are available on GitHub, thus readers have access to everything. I encourage others to clone and play with the project as they see fit.", "This is always the best way to learn. I welcome questions in the comments section for those needing support (you can also @ me on Twitter so the support benefits others more publicly).", "There are a number of challenges we face when attempting to automate defect detection and classification\u00b2. A few of these were already mentioned in the introduction. The fuller list includes:", "We will need an approach that addresses these challenges while supporting a real-world application that effectively detects, extracts and predicts defect types in PCBs.", "Given the challenges we face it makes sense to use a hybrid approach to build our classifier application, which combines the reference method and non-reference method.", "Reference Method: the inspected PCB board (test board) is compared to a reference template image (template board) that has no defects, in order to allow analysts to identify differences.", "Non-Reference Method: the inspected PCB board is checked for compliance against design principles, without relying on template images.", "The reference method is relatively straightforward to implement but has large storage requirements (holding all the images). The non-reference method doesn\u2019t suffer from storage issues, but can be limited in the number of defects found.", "Building a product that automates both reference and non-reference methods may not cut down on storage and computational requirements, but if the manual detection and classification errors are reduced we gain massively from the increased and reliable throughput .", "While we could attempt to train our deep learning model to classify the defects present on an entire board, this would be challenging. Take a look at the following example test and template PCB boards:", "The board on the left is what our model needs to classify. We can see the individual defects by comparing to the template. But how likely is it that our model will be able to reliably classify a combination of defects? What would the class be called? How many unique defect combinations exist?", "To lower the burden placed on our model we will first extract the individual defects from the test image. This can be accomplished by creating a differenced image and extracting the parts of the image that are different.", "The following is the kind of differenced image we can produce using image processing in Python:", "Notice the defects are highlighted in red. The above image doesn\u2019t show all the defects since in this article we are only concerned with extracting 3 types. Capturing the other defect types of fairly trivial, and I will discuss this later.", "Since we have a differenced image that highlights the defects in the test image we can also use image processing to extract the colored parts of the image:", "This dramatically lowers the burden placed on our deep learning classifier. By extracting individual defects we convert the problem from a complex recognition problem into something akin to digit recognition (a problem that already works well with deep learning). This also means we are more likely to be successful using transfer learning, since there are numerous successful models in the OCR space. I will discuss transfer learning in more detail later on.", "With this approach we can outline 5 major efforts:", "Head on over to Google Colab and start a new Python 3 notebook. This will be our modeling environment. This is a Jupyter notebook environment that runs entirely in the cloud.", "Google Colab allows access to an environment capable of running GPUs at no cost. Colab also makes installing and importing libraries a breeze. This is back-end as a service (BaaS), which helps (immensely) with rapid prototyping.", "You have 2 options for getting the notebook into your own Google Colab environment.", "2. Or you can mount a drive in Google Colab, clone the defect_classifier repo, and open the notebook from your Google drive.", "2.2 Mount a Drive on Google Colab", "Run the following in the first cell (play button, or shift-return on Mac):", "You will be presented with a URL. Click it, get the auth code, return to your notebook and enter it. You now have access to your Google Drive inside Colab:", "\u2026then copy the cloned notebook into your mounted drive:", "Now find the notebook inside your Google drive, as you would any other file, right-click, and choose open with Google Colab.", "We will require Graphical Processing Units (GPU) to train our Deep Learning model in reasonable time. We can set the hardware acceleration in Colab by clicking on Runtime at the top, choosing Change runtime type, selecting GPU under hardware accelerator, and clicking SAVE.", "First we need to build the defect extraction pipeline. To use less code I\u2019ve created a small library that will abstract much of the image processing. I plan on continuing to add to this library going forward to stay tuned. For an intuitive yet detailed tutorial on creating libraries in R and Python see here.", "The library is freely available on GitHub. We can install libraries from GitHub using pip as follows:", "Note the ! before the usual pip command. This is the \u201cbang\u201d symbol commonly used when doing interactive computing. It allows our Google Colab environment to access the underlying shell.", "We can now import the library:", "You can also click on the Files icon to the left so we can see the files we work with (click on Refresh as needed):", "Let\u2019s create folders to hold our differenced images, extracted defects, and the hold out images needed to test our model. We\u2019ll use tetryonai\u2019s directory function:", "We will need access to a large number of test and template PCB board images. These are available on GitHub\u00b3 via the DeepPCB project. This provides us with a large number of images obtained from a linear scan CCD. Review this project for more details.", "Clone the DeepPCB project into your Colab environment by running the following in the next cell:", "Hit Refresh in the Files pane to see the new DeepPCB folder. You can expand through the folder to see just how many images are available.", "For this project we will use only the group00041 set of temp and test images as shown above. These are the images previously described in Figures 1-3.", "Let\u2019s write some Python for storing the group00041 temp and test image paths from our DeepPCB folder inside a dict. We\u2019ll then use this in the next step to difference our images:", "Now we will use image processing to difference each pair of temp and test images using the paths specified inside the dict we just created. We also need to hold out a set of these images to test in our application. I will combine these operations into one codeblock for convenience:", "We are using tetryonai\u2019s copy_files function to copy the necessary files into the target_directory called hold_out that we created earlier. I am using a split_percentage of 20% for the hold out set. In the code above, once 20% of the images have been held out the remaining are subtracted using tetryonai\u2019s subtract_images function.", "If we Refresh our Files pane and inspect our difference_img and hold_out folders we will see the images placed as inspected. You can also open a few of the images inside difference_img to confirm the subtraction process worked (as was shown in Figure 2):", "We are now ready to extract the highlighted defects that appear in the differenced images. We will use tetryonai\u2019s extract_contours_from_image function to read in each differenced image, extract defects per image, and save the defects to the extracted_defects folder we created towards the beginning:", "Images that are corrupt/non-readable will be skipped by the extract_contours_from_image function. This still leaves us with plenty of images to train our model.", "The extract_contours_from_image function uses contours to extract the highlighted parts of our differenced images. Think of contours as a curve joining all the continuous points (along the boundary) that have the same color or intensity. Contours are a useful tool for shape analysis and object detection/recognition. You can read more about contours on OpenCV.", "Refresh the Files pane and inspect the extracted_defects folder. You will notice individual folders have been created for each set of contours extracted from each differenced image.", "We will now combine all the extracted defects into a single directory called all_extracts. Let\u2019s make that directory now:", "We write some Python to walk through the extracted_defects directory and move any PNG files using tetryonai\u2019s move_files function:", "Refreshing the Files pane and inspecting the all_extracts folder will reveal all extracted defects.", "In PART 2 we will be applying labels to our extracted defects (\u201cturking\u201d). We thus need to download all extracted defect images to use with the labelling application we create next. So let\u2019s zip all extracted defects for easy downloading:", "If you Refresh your Files pane you will see a new extracted_defects.zip file created.", "Our labelling application will also require a JSON file with the filenames of the images in our zip folder. Let\u2019s write some Python to grab all filenames in the all_extracts directory:", "Save the JSON file we just created:", "Refresh the File pane and download both the extracted_defects.zip and extracted_defects.json files:", "Save these files to your Desktop for now.", "In PART I we differenced a large set of test and template PCB images, extracted defects in the differenced images using contours, and created the 2 files we need to use the labelling application we create next. Let\u2019s do that now.", "With our set of extracted defect images in hand we have a good-sized dataset to use for training a Deep Learning model for image classification. But like any supervised machine learning approach our training data requires labels. Since we extracted our images we obviously don\u2019t have these labels available.", "Image classification requires large amounts of labelled data, making hand-crafted labeling an arduous task. But the colossal data prerequisite to image classification often isn\u2019t a show stopper. This is because there are a wealth of publicly-available models that have already been trained on large benchmark sets of images. As long as the domain isn\u2019t too different we can use much less data to train a pre-trained model. Can we get away with successfully classifying our extracted defects using much less labelled data, paired with an existing image classifier?", "My bet is yes, but there is only one way to find out. This is a good opportunity to build a new, general-purpose product. This product will allow us to create labels for a set of images.", "TI won\u2019t go through the steps for creating the Defect Turker since this article is already long enough. It\u2019s a simple application that allows us to apply labels to any images that are inside its img folder.", "Too often people rush to find existing solutions, with products that don\u2019t address their true requirements. A lot of time (and money) ends up being wasted trying to force existing products to their specific set of challenges. Bespoke software development is immensely powerful, but only when it\u2019s not inhibited by over-staffed projects and over-engineered solutions. Rapid prototyping is a massively beneficial skill.", "We won\u2019t do our labelling on Colab since it currently has no obvious way to host web applications inside its environment. We will thus run the Defect Turker locally.", "The Defect Turker is available on GitHub. Clone the application onto your local machine by running the following in a terminal session:", "I also start a simple web service using the following line:", "Before opening our browser to the application let\u2019s add the extracted defect images (extracted_defects.zip) and JSON file (extracted_defects.json) we created earlier to the application. These files are on my Desktop, so I\u2019ll double-click the ZIP file to decompress it contents:", "..and run the following line in a new tab in terminal, from inside the defect_turker directory:", "Confirm our extracted defect images are inside the application\u2019s img folder:", "We also need the JSON file containing all image names. Move these now:", "We\u2019re now ready to label our images. Let\u2019s start the application. Since our web server is already up-and-running we simply point our browser to http://localhost:8000/.", "If you need to change the port # on the web server you simply add the port to the end of the full command (e.g. python3 -m http.server 5555)", "Your first image will likely be something other than the one shown here. We can see there are 1333 total images. That\u2019s a lot of labelling. I decided to break this up throughout the day and do a few hundred at a time. Ideally we would split this task among a few people on the team.", "Product Idea: Create a version of this application that allows labelling to be done by multiple people, then recombines the results into a single CSV file.", "The first icon is a legend showing the labels for each defect type. Refer to this to learn which defect has what label.", "It turns out our image differencing only extracted 3 types of defects:", "The reason only 3 types were extracted has to do with how our image differencing was set up. We can easily detect the other types of defects as well, but I will keep our application to these 3 defect types for this article. See NOTES at the end for details.", "Simply click on the button that corresponds to the label for the presented image. Once we have labelled all the images (or as many as you wish) we click on the upper right icon to download a CSV file that can be used to train our Deep Learning model.", "The CSV file has each image name and the label we applied. Save the file as image_labels.csv and keep it on your Desktop for Part 3.", "We\u2019re now ready to train our Deep Learning PCB Classifier.", "We move back to the Colab notebook to train our Deep Learning model using the CSV file we created with the Defect Turker. We will use fastai to train our Deep Learning model.", "fast.ai, the research institute, is dedicated to making deep learning more accessible, via their courses, software, research and community. Their library fastai is a powerful open source API sitting on top of PyTorch. Recent research breakthroughs in Deep Learning are embedded into the fastai library meaning we get access to cutting-edge Deep Learning models that are more accurate and faster than many other DL libraries; all while writing much less code.", "We will upload the image_labels.csv file created with the Defect Turker in Part 2. Run the following line in Colab to upload the file:", "You may have to run this twice as the first run often fails.", "We\u2019ll now convert image_labels.csv to a data frame using tetryonai\u2019s csv_to_dataframe function:", "Let\u2019s check the class balance between our labels. First, we\u2019ll get the number of examples of each label using tetryonai\u2019s get_feature_counts function:", "\u2026then use Matplotlib to create our plot:", "Note: If \u201clabel\u201d appears in the chart, run del labelled_counts[\u2018label\u2019] in the cell prior to creating the visual.", "We have a \u201cmajority class\u201d of NOT, while the 3 defect types are fairly balanced. We could downsample the majority class but it may not be needed. We\u2019ll go ahead and use our labelled data as is, and readjust the balance in our training data only if needed.", "The fastai training approach we will use requires individual labelled CSV files for each class we want to predict. Let\u2019s create a folder called training_csvs to hold these individual files:", "\u2026now let\u2019s create individual CSV files for each class using the image_labels_frame dataframe we created from our uploaded image_labels.csv file.", "First we create individual lists for each class:", "\u2026then we convert those lists into data frames for each class:", "Now let\u2019s create individual folders for the CSV files:", "Now we can move the individual CSV files to their appropriate folders:", "We obviously need images to train our image classifier. These will be the defect images we extracted in PART 1, zipped into the file called extracted_defects.zip, and added to our Defect Turker for labelling.", "We could just use the extracted_defects.zip file that is currently in our Colab environment, but we may have restarted and rerun our pipeline from PART 1 if we are doing this project over a few days. This will obviously recreate our zipped image file making the filenames in our previously labelled CSV file (image_labels.csv) mismatch our zipped images filenames.", "Given the above, let\u2019s remove the extracted_defects.zip file currently in Colab and upload the extracted_defects.zip file we know we used with the Defect Turker.", "Extract all images from extracted_defects.zip into the training_csvs folder:", "Now we can move all extracted defect images into their proper training folder, using the image_labels.csv file:", "To clean up, let\u2019s remove any remaining PNG files (defect images) that were not labelled:", "We should inspect the image data to confirm they were read-in properly:", "We can see the labels match the images (the spur, spurious, short, and not_defect images all match the labels shown).", "We are now ready to train our classifier. We need a fairly deep architecture if we are to get good enough results to create a product people use. Deep networks (large number of stacked layers) allow for deeper representations than their shallow counterparts and have been shown to perform very well on image recognition tasks.", "We will download a pre-trained PyTorch model from torchvision. We want to use a pre-trained model to cut down on training time and CPU requirements. Pre-trained models have been trained on large benchmark datasets to solve problems similar to ours. This is called transfer learning.", "The following figure shows the ResNet34 architecture we will use. This architecture is based off research discussed in this paper.", "To download the pre-trained ResNet34 model from fastai we run the following:", "Let\u2019s train our model on our defect data.", "By using a pre-trained model it means all the weights are already trained prior to our implementation. We refer to this kind of setup as a frozen model, which be default has \u201call\u201d layers frozen (except the very last layers). Freezing prevents well-trained weights from being modified, which is what we want since are looking to implement transfer learning.", "We are using the default values across a large number of hyper-parameters. It makes sense to see how good our model can perform with the least amount of work possible.", "We need to make sure our notebook is utilizing GPU hardware acceleration. We did this at the beginning when we set the hardware accelerator to GPU. If you restarted your notebook since the beginning of this article ensure this is still set.", "We access GPU hardware via Nvidia\u2019s CUDA API. This enables us to tap into the parallel computing needed to train our model is reasonable time.", "fastai\u2019s fit_one_cycle method uses Leslie Smith\u2019s 1cycle policy, which gives us a faster way to train complex models. You can learn more about this policy Sylvain Gugger\u2019s post here.", "We will train our model for 10 epochs. An \u201cepoch\u201d is the number of times our learning algorithm will work through the entire training dataset (each example in the training data had an opportunity to update the model parameters).", "Epoch is different than the batch size, which is the number of samples processed before the model is updated.", "We begin by training only the last layers of our model, by calling fastai\u2019s fit_one_cycle method, specifying 10 epochs:", "Below shows the first 3 epochs during training:", "Total training will take around 40 mins. Keep in mind this training would be performed offline, thus training time isn\u2019t that important for our product (whereas inference time is).", "Your final result should look similar to this:", "We have fairly low error rates, which is good. Not bad for a frozen model using default hyper-parameters. But let\u2019s see if we can improve the results.", "Now we will unfreeze the network, which means all the weights in our model can now be updated. We can call fastai\u2019s unfreeze() method in our learn object:", "Since we have \u201cthawed\u201d our model it no longer makes sense to use the same learning rate across all layers. Different layers in deep models benefit from so-called \u201cdifferential\u201d learning rates, where various rates are used depending on where in the network they are applied. To use differential learning rates we first need to find a suitable range.", "To find a suitable range of learning rates we will plot our model\u2019s loss against increasing rates. We can do this by first running:", "We are attempting to observe and understand clues that sometimes appear earl-on in training. By doing so, we can potentially tune our architecture via its hyper-parameters in such a way that less epochs are required. This enables us to avoid running complete grid and random searches in our efforts to find good hyper-parameters.", "We can plot the learning rates against loss by running the following:", "The typical approach is to take the values right below the lowest point, prior the error becoming worse. We will use the range between 3 x 10^\u20135 and 3 x 10^e-4.", "We will now run fit_one_cycle again, this using the max_lr argument to specify the range of learning rates. Let\u2019s train our thawed model across 4 epochs using differential learning rates:", "Note we achieved much lower error. Of course this is near-meaningless without first examining the quality of predictions.", "As usual we examine the confusion matrix (CM) to see if there are any red flags with respect to misclassification. There might be certain defect types that our model struggles with.", "We see most values sitting across the characteristic diagonal of the CM. Looks like our model is quite effective at predicting defects. We will use this model for our product.", "Now that we have a trained model with reasonable accuracy we want to download it as an object that can be used for inference (predictions on real data):", "The .pkl file should appear in the training_csvs folder. Download this:", "Recall in PART 1 we created the extracted_defects.json file and uploaded this to the Defect Turker for labelling. We will now create a JSON file with filenames for the actual application we build Part 4:", "Finally, let\u2019s zip and download the hold out images to use with PCB Defect Classifier:", ".., and download from Colab as usual:", "We will use these files in PART 4.", "We\u2019re now ready to build our PCB Defect Classifier application.", "We\u2019ve arrived at the ultimate goal of this project (and of any real-world project), which is to create a real application for end users. As I stated in the introduction, creating products around our machine learning is the only true test our work has utility beyond a group of engineers.", "I also stated that I will not cover all pipeline and front-end coding in order to keep this article a reasonable size.", "TThis is the main application we want to create in this article. We looked at the reasons why a product like this would prove useful to end users in the printed circuit board domain. Let\u2019s go over the major parts needed to craft this product, building out both the back-end and front-end components.", "The user can also set the defect costs based on their organization\u2019s manufacturing.", "We will use Flask to create a lightweight web service. Between Flask and Azle it will be easy to call our Python functions in the back-end. There are many tutorials on how to create a Flask web service so I won\u2019t detail those steps here. Again, all code is available on GitHub.", "We will use the major pipeline functions used in our Colab environment to create the back-end of our product pipeline.", "From the figures above we know we need:", "We will use Azle to call the functions (via app.py) contained in classifier.py, image_differencing.py and utility.py.", "Here are the major functions needed:", "The first 2 are the same tetryonai functions we used in our Colab environment for processing the test and template images.", "I will create a directory called api that holds the main Flask file (app.py) and the files pertaining to our pipeline:", "The utility functions inside utility.py just help with some basic operations needed for the operation of the application.", "Creating the application in Azle enables rapid prototyping. Here the major pieces:", "Clone the application from GitHub by running the following in terminal:", "We need to add the following files:", "Recall in PART 3 we created and downloaded the files test_temps.json and hold_out.zip. Place these files on your Desktop if they\u2019re not already and unzip the hold_out.zip folder.", "Now we can add all the hold out images to our application by moving them into the test_temps folder. From inside the cloned application (assuming application was cloned to Desktop):", "Our application now has access to the kind of images we would expect in our PCB board manufacturing scenario.", "In PART 3 we saved the .pkl file. This is our trained defect classifier model. Let\u2019s add this to the model folder of the application:", "We need to rename our model object since fastai\u2019s load_learner method expects the object to be called \u201cexport.pkl\u201d:", "Let\u2019s go ahead and see how our PCB Defect Classifier works!", "We built the web service in Flask. We call this as usual:", "You should see the following in your terminal:", "We can see that we are running in debugger mode. This is ideal since any change we make to the Python will cause the service to automatically restart. This is very beneficial for prototyping.", "Now we need to start a web service to show the front-end of the application. In your terminal run the following:", "Our first screen looks like this:", "The first step for the user is to run FETCH BOARDS, which will bring in our PCB images stored in test_temps (our hold out images).", "This fetches both the TEST and TEMPLATE images. These are the PCB boards that manufactures need to test to see if any defects exist.", "Now the user runs the pipeline, which will:", "Here\u2019s the fuller video again we saw at the beginning, showing how we can make multiple runs against our pipeline, getting accurate predictions each time:", "Beautiful. We can see that differencing and defect extraction is almost instantaneous. The prediction is set to 1000ms for each extracted defects, which seems reasonable for our demonstration. Is this fast enough for a PCB manufacturer?", "FFeature Idea: Users could be presented a slider to set the prediction time. Based on manufacturing throughput, setting a lower prediction time might make sense. Of course this has to be balanced with how fast the prediction can be made with our pre-trained model (inference time). Setting up a chart showing best inference times would be a good experiment to run and show clients.", "There are a number of things we could do to improve our product. While model accuracy is already quite good we didn\u2019t try the other defect types. Will model performance be as good on these defects? What if this product needs to predict at a much higher rate? Would it be worth using shallower networks that run faster inference, while sacrificing some of our hard-won accuracy?", "Here are some things we could try:", "There are also various user experiences we might build for, by way of different/additional product features. Would it make sense for users to have an option to mark bad predictions as incorrect (feed this info back to model). What about tallying additional information about the predicted defects, other than cost? Perhaps creating interesting summarizing visualizations. By embracing rapid prototyping we don\u2019t have to know the answers to these questions upfront; we can build, showcase, and change as needed, with real products.", "In this article we created an end-to-end PCB Defect Classifier application. We used image processing to difference sets of test and template PCB images, extract defects using contours, and classify the extracted defects using Deep Learning. We then created a front-end application that allows users to run our machine learning pipeline and review model predictions.", "Applications like this help automate tasks that are manual, time-consuming, and prone to human error. The purpose is not to replace human experts, but rather augment their efforts so they may focus on more strategic and creative aspects of their jobs.", "If you have any questions / need support please use the comments section. I can help others modify these applications for their specific purpose. Azle questions can be asked on Stack Overflow.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Founder Kedion, Ph.D. Computational Chem, builds AI software, studies complexity, host of NonTrivial podcast."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F6361b3a76232&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----6361b3a76232--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----6361b3a76232--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://seanamcclure.medium.com/?source=post_page-----6361b3a76232--------------------------------", "anchor_text": ""}, {"url": "https://seanamcclure.medium.com/?source=post_page-----6361b3a76232--------------------------------", "anchor_text": "Sean McClure"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc06551b485e5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&user=Sean+McClure&userId=c06551b485e5&source=post_page-c06551b485e5----6361b3a76232---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F6361b3a76232&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F6361b3a76232&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://en.wikipedia.org/wiki/Printed_circuit_board", "anchor_text": "Printed Circuit Board"}, {"url": "https://github.com/sean-mcclure/defect_classifier", "anchor_text": "GitHub"}, {"url": "https://twitter.com/sean_a_mcclure", "anchor_text": "Twitter"}, {"url": "https://colab.research.google.com/notebooks/intro.ipynb", "anchor_text": "Google Colab"}, {"url": "https://flask.palletsprojects.com/en/1.1.x/", "anchor_text": "Flask"}, {"url": "https://www.fast.ai/", "anchor_text": "fastai"}, {"url": "https://www.notes2tree.com//published_tree/?publish_tree=Qjb4gOndye", "anchor_text": "tetryonai"}, {"url": "https://azlejs.com", "anchor_text": "Azle"}, {"url": "https://github.com/sean-mcclure/defect_classifier/blob/master/notebooks/PCB_Defect_Extraction_and_Classification.ipynb", "anchor_text": "PCB_Defect_Extraction_and_Classification.ipynb"}, {"url": "https://github.com/sean-mcclure/defect_turker", "anchor_text": "Defect Turker"}, {"url": "https://github.com/sean-mcclure/defect_classifier", "anchor_text": "PCB Defect Classifier"}, {"url": "https://en.wikipedia.org/wiki/Transfer_learning", "anchor_text": "transfer learning"}, {"url": "https://colab.research.google.com", "anchor_text": "Google Colab"}, {"url": "https://github.com/sean-mcclure/defect_classifier/blob/master/notebooks/PCB_Defect_Extraction_and_Classification.ipynb", "anchor_text": "notebook"}, {"url": "https://github.com/sean-mcclure/defect_classifier", "anchor_text": "defect_classifier"}, {"url": "https://en.wikipedia.org/wiki/Graphics_processing_unit", "anchor_text": "Graphical Processing Units"}, {"url": "https://towardsdatascience.com/step-by-step-guide-to-creating-r-and-python-libraries-e81bbea87911", "anchor_text": "here"}, {"url": "https://github.com/tangsanli5201/DeepPCB", "anchor_text": "GitHub"}, {"url": "https://docs.opencv.org/trunk/d4/d73/tutorial_py_contours_begin.html", "anchor_text": "OpenCV"}, {"url": "https://github.com/sean-mcclure/defect_turker", "anchor_text": "GitHub"}, {"url": "https://github.com/sean-mcclure/defect_turker.git", "anchor_text": "https://github.com/sean-mcclure/defect_turker.git"}, {"url": "http://localhost:8000/", "anchor_text": "http://localhost:8000/"}, {"url": "https://www.fast.ai/", "anchor_text": "fastai"}, {"url": "https://course.fast.ai/", "anchor_text": "courses"}, {"url": "https://www.fast.ai/2018/10/02/fastai-ai/", "anchor_text": "software"}, {"url": "https://www.theverge.com/2018/5/7/17316010/fast-ai-speed-test-stanford-dawnbench-google-intel", "anchor_text": "research"}, {"url": "https://forums.fast.ai/", "anchor_text": "community"}, {"url": "https://en.wikipedia.org/wiki/Oversampling_and_undersampling_in_data_analysis", "anchor_text": "downsample"}, {"url": "https://pytorch.org/docs/stable/torchvision/models.html", "anchor_text": "torchvision"}, {"url": "https://en.wikipedia.org/wiki/Transfer_learning", "anchor_text": "transfer learning"}, {"url": "https://arxiv.org/pdf/1512.03385.pdf?", "anchor_text": "paper"}, {"url": "https://en.wikipedia.org/wiki/CUDA", "anchor_text": "CUDA"}, {"url": "https://sgugger.github.io/the-1cycle-policy.html", "anchor_text": "here"}, {"url": "https://azlejs.com", "anchor_text": "Azle"}, {"url": "https://github.com/sean-mcclure/defect_classifier.git", "anchor_text": "https://github.com/sean-mcclure/defect_classifier.git"}, {"url": "http://127.0.0.1:5000/", "anchor_text": "http://127.0.0.1:5000/"}, {"url": "http://localhost:8000/app/", "anchor_text": "http://localhost:8000/app/"}, {"url": "https://stackoverflow.com/questions/ask?tags=azle+javascript", "anchor_text": "Stack Overflow"}, {"url": "https://towardsdatascience.com/learn-to-build-machine-learning-services-prototype-real-applications-and-deploy-your-work-to-aa97b2b09e0c", "anchor_text": "Learn to Build Machine Learning Services, Prototype Real Applications, and Deploy your Work to\u2026In this post I show readers how to expose their machine learning models as RESTful web services, prototype real\u2026towardsdatascience.com"}, {"url": "https://towardsdatascience.com/step-by-step-guide-to-creating-r-and-python-libraries-e81bbea87911", "anchor_text": "Step-by-Step Guide to Creating R and Python Libraries (in JupyterLab)R and Python are the bread and butter of today\u2019s machine learning languages. R provides powerful statistics and quick\u2026towardsdatascience.com"}, {"url": "https://towardsdatascience.com/gui-fying-the-machine-learning-workflow-towards-rapid-discovery-of-viable-pipelines-cab2552c909f", "anchor_text": "GUI-fying the Machine Learning Workflow: Towards Rapid Discovery of Viable PipelinesPREFACEtowardsdatascience.com"}, {"url": "https://towardsdatascience.com/creating-web-applications-with-d3-observable-d5c53467ff12", "anchor_text": "Creating Web Applications with D3 ObservableWhat is D3 Observable?towardsdatascience.com"}, {"url": "https://towardsdatascience.com/combining-d3-with-kedion-graduating-from-toy-visuals-to-real-applications-92bf7c3cc713", "anchor_text": "Graduating from Toy Visuals to Real Applications with D3.jsToo often we learn about technology and methods in isolation, disconnected from the true goal of data science; to\u2026towardsdatascience.com"}, {"url": "http://www.iconnect007.com/index.php/article/92973/world-pcb-production-in-2014-estimated-at-602b/92976/?skin=pcb", "anchor_text": "World PCB Production in 2014 Estimated at $60.2B"}, {"url": "https://arxiv.org/pdf/1901.08204.pdf", "anchor_text": "A PCB Dataset for Defects Detection and Classification"}, {"url": "https://github.com/tangsanli5201/DeepPCB", "anchor_text": "tangsanli5201/DeepPCB on GitHub"}, {"url": "https://medium.com/tag/machine-learning?source=post_page-----6361b3a76232---------------machine_learning-----------------", "anchor_text": "Machine Learning"}, {"url": "https://medium.com/tag/artificial-intelligence?source=post_page-----6361b3a76232---------------artificial_intelligence-----------------", "anchor_text": "Artificial Intelligence"}, {"url": "https://medium.com/tag/deep-learning?source=post_page-----6361b3a76232---------------deep_learning-----------------", "anchor_text": "Deep Learning"}, {"url": "https://medium.com/tag/manufacturing?source=post_page-----6361b3a76232---------------manufacturing-----------------", "anchor_text": "Manufacturing"}, {"url": "https://medium.com/tag/data-science?source=post_page-----6361b3a76232---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F6361b3a76232&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&user=Sean+McClure&userId=c06551b485e5&source=-----6361b3a76232---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F6361b3a76232&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&user=Sean+McClure&userId=c06551b485e5&source=-----6361b3a76232---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F6361b3a76232&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----6361b3a76232--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F6361b3a76232&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----6361b3a76232---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----6361b3a76232--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----6361b3a76232--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----6361b3a76232--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----6361b3a76232--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----6361b3a76232--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----6361b3a76232--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----6361b3a76232--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----6361b3a76232--------------------------------", "anchor_text": ""}, {"url": "https://seanamcclure.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://seanamcclure.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Sean McClure"}, {"url": "https://seanamcclure.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "2.1K Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc06551b485e5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&user=Sean+McClure&userId=c06551b485e5&source=post_page-c06551b485e5--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fd94a85a0d3a2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-end-to-end-deep-learning-defect-classifier-application-for-printed-circuit-board-pcb-6361b3a76232&newsletterV3=c06551b485e5&newsletterV3Id=d94a85a0d3a2&user=Sean+McClure&userId=c06551b485e5&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}