{"url": "https://towardsdatascience.com/building-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e", "time": 1682997397.811626, "path": "towardsdatascience.com/building-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e/", "webpage": {"metadata": {"title": "Building a Stable and User Friendly API for your Model | by Harpal Sahota | Towards Data Science", "h1": "Building a Stable and User Friendly API for your Model", "description": "Most (if not all) Data Scientists will eventually need to deploy their model and make it available via an API. This is often the most overlooked part in the end-to-end process of a machine learning\u2026"}, "outgoing_paragraph_urls": [{"url": "https://github.com/harpalsahota/DataScience/tree/master/Model_API_Example", "anchor_text": "GitHub account", "paragraph_index": 1}, {"url": "https://marshmallow.readthedocs.io/en/3.0/", "anchor_text": "marshmallow", "paragraph_index": 13}, {"url": "https://hackernoon.com/a-brief-tour-of-python-3-7-data-classes-22ee5e046517", "anchor_text": "post", "paragraph_index": 17}, {"url": "https://docs.python.org/3/howto/logging.html#logging-basic-tutorial", "anchor_text": "basic tutorial", "paragraph_index": 20}, {"url": "https://swagger.io/solutions/api-design/", "anchor_text": "Swagger", "paragraph_index": 21}, {"url": "https://github.com/rochacbruno/flasgger", "anchor_text": "Flassager", "paragraph_index": 22}, {"url": "https://github.com/zalando/connexion", "anchor_text": "Connexion", "paragraph_index": 22}, {"url": "https://swagger.io/docs/specification/2-0/basic-structure/", "anchor_text": "swagger docs", "paragraph_index": 23}, {"url": "http://flask.pocoo.org/docs/1.0/views/#method-views-for-apis", "anchor_text": "MethodView", "paragraph_index": 25}, {"url": "http://flask.pocoo.org/docs/1.0/tutorial/deploy/#run-with-a-production-server", "anchor_text": "not recommended", "paragraph_index": 33}, {"url": "https://gunicorn.org/", "anchor_text": "Gunicorn", "paragraph_index": 33}, {"url": "https://docs.pylonsproject.org/projects/waitress/en/latest/#", "anchor_text": "Waitress", "paragraph_index": 33}], "all_paragraphs": ["Most (if not all) Data Scientists will eventually need to deploy their model and make it available via an API. This is often the most overlooked part in the end-to-end process of a machine learning project as most of the focus is on building the model or the dreaded data cleaning. Constructing a stable and user friendly API is key for getting users / product teams to start consuming your services and to keep consuming them. So how do you go about building a stable and user-friendly API? This is where this article comes in, I\u2019ve built many APIs over the years specifically for data science models and I want to share with you how I would go about making them. This article does assume the following:", "If you haven\u2019t already guessed we\u2019ll be using Python and Flask to build the API and all the code is available on my GitHub account.", "We have built a (very crude) Random Forest model to predict house prices. This model has 3 features: is_house, has_garden and n_bedrooms. Both is_house and has_garden are binary flags while n_bedrooms is an integer. Showing the model to stake holders leaves them impressed and now want to take it to the next stage, which is quality assurance via an API. You have now been tasked with building an API for your model.", "I generally follow this folder structure for my APIs. I try to keep it as simple as possible while also making it easily extensible:", "To get this up and running locally have a look at the README on the repo which gives instructions on the setup.", "This may seem like a really boring aspect of building an API and it is, but correctly configuring your API from the start really helps things down the line. There three files involved are API configuration:", "The config.yml and .env files contain application settings and environmental variables for your application which can contain sensitive information. We don\u2019t want this information on the repository so we create example files which have sensitive information omitted. For example, the config.yml file may contain a database password: DB_PASSWORD: XXXXX but in the config.yml.example this will be: DB_PASSWORD:. The password is removed but the variable it\u2019s associated with is kept, this makes it easier for new users of your application to get up and running as this highlights what configuration of the app is required. To use these files all you need to do is copy both of them but rename them with the .example suffix removed. In my config.yml file I only have a single variable called MODEL_NAME which is just the name of the model we wish to use. In the config.yml file fill in MODEL_NAME with rf_classifier.pkl. In the .env file assign APP_SETTINGS_YAML to config.yml. Finally, make sure both config.yml and the .env files are in your .gitignore file so they can\u2019t be pushed to the repository by accident.", "The settings.py file is the access point of the API to these variables (shown below). Lines 9\u201314 in the following portion of code loads in the .env file and has a place holder for MODEL_NAME which defaults to None:", "Following this, the value of APP_SETTING_YAML (defined in the .env file) is obtained (line 17) which has the value config.yml. This file is then read and the key value pairs extracted (lines 18\u201320). These key value pairs in config.yml are then used to update the values present in the settings.py file. The variables with the placeholder of None are the ones to be updated.", "The initial value of MODEL_NAME is None but after reading in the config.yml file and updating the global values it\u2019s now set to rf_classifier.pkl. To access this variable all you would do in your application would be:", "An important thing to note here is the application variable names defined in settings.py must match exactly the key name in config.yml otherwise the variables in your settings.py won\u2019t be updated.", "The final piece of code on lines 22\u201324 actually looks at the environmental variables defined in your OS and uses these to override the derived variables from config.yml. Why would you do this I hear you say? When you typically deploy to production there can be different application settings such as a production database user name and password or port numbers etc\u2026 which you would not use locally. Rather than having a second config.yml file all you would need to do is define these same variables in your OS environment. This allows you to easily switch between settings used for local development and those used in production, without having to change any of your application code. A key thing to remember here is variables defined in your OS environment have precedence over those defined in your config.yml file.", "This folder contains python modules which has common functionality with other APIs. So if you were to add another API to this project say for another model you wouldn\u2019t have to duplicate code. Let\u2019s break down the modules in this folder starting with schemas.py", "This module uses the marshmallow package to load data into a schema we define. Marshmallow will then check the data against the schema and if any inconsistencies are detected an error will be raised. By verifying the data against a schema we ensure the consumers of the API are conforming to the feature range the model was trained on. This is great because it prevents consumers of the API passing unexpected parameters to the model and therefore obtaining strange results, which may later on be used in reporting. The schema for our model looks like:", "We first create a class which inherits the Schema class from marshmallow, which will allow us to create our own schema. Next, variables of the schema (features of the model) are defined and are assigned field objects. Field objects simply define what type the object is e.g. string, integer of even another schema that the field accepts. They can also state whether or not a field is compulsory by passing the keyword argument required with a boolean value. Here we create three variables is_house, has_garden, and n_bedrooms which are declared on lines 13\u201315 and labelled as required. All three of these variables define an integer type. Next, we create three functions which validate each of the features, these functions are prefixed with validate in their name, this is not necessary just something I use for my own nomenclature. The functions are decorated with the@validates method which takes a single parameter being the name of the feature you wish to validate as a type string. Only functions wrapped with @validates are used to validate the data and the string input must be a variable defined at the top of the class. As a result of decorating the functions they now take a single positional argument defined here as value. This is the value passed to the each of the features and upon which we perform our validation. Both is_house and has_garden are binary flags and have exactly the same check, with only the error message differing (lines 17\u201325).", "For example, if the if statement inside validate_is_house returns true an error is raised with a specific message: is_house must be either 0 or 1. The error message can then be returned to the client. This sort of error message provides useful debugging information for the user rather than a generic HTTP error message. The n_bedrooms validation (lines 27\u201330) verifies the value is greater than or equal to zero if not raise an error.", "The method make_price_prediction_data_model runs after the schema checks have passed. This is defined by the @posts_loads decorator. The execution of this function returns a data class object containing the features. This would be good time to look at the data class defined in data_models.py", "As mentioned above once the schema checks have passed a model of the data is returned in the form of a data class. If you don\u2019t know what a data class is I highly recommend you check this post. The data class gives us additional functionality out of the box and also allows us to access the attributes of the class by their name, just like a regular class. The data class for our model looks like:", "Not really much going on here. We define a class wrapped by @dataclass and within the class define three variables which are the attributes of the class. In our case these attributes are the features for the model. I\u2019ve also defined a __repr__ method to giving us a useful representation of the class. Just like a regular class you can add additional methods if need be.", "The final module is the common folder is the logging file. The file just contains a few lines of code to setup a logger:", "Here, I setup a logger with a StreamHandler to log to the console. If you so wish you can setup a logger to log a file, refer to the basic tutorial in the docs to show you how to do so.", "With the schema defined how would users know beforehand what are acceptable inputs for the model? Additionally, how a can user explore other endpoints for you API? This is where Swagger comes in. By implementing Swagger in our API we provide a visual endpoint for our API, listing all of the available endpoints along with what HTTP methods they accept. Additionally, with each endpoint you can provide the schema and examples to run, essentially documenting the API. Below is a screen shot of the Swagger page for the API we are building:", "How can we implement swagger for out API? The good news there are packages out there which can do this for us such as Flassager and Connexion. For our API we will be using Flassager.", "For swagger to display the information we need to provide documentation for it. This is provided in yaml file format and is located in the endpoint_docs folder. If you navigate to the file found at /endpoint_docs/property_price_prediction_v1/get.yml you will find the docs for this endpoint which was displayed above. In this file are the parameters for the endpoint along with response examples. For more information on documenting your endpoints see the swagger docs", "Now we move onto code for the api itself. Let\u2019s start off with the only endpoint of the API which is located at /views/property_price_prediction.py. This file contains a single class defining the endpoint:", "The ProperyPricePrediction class inherits SwaggerView from flassagger which also inherits MethodView from Flask. Method views allows us to use the same endpoint to accept different HTTP methods in a single class. For this to happen we first need to define functions named by the method they serve. For example, in the code above this endpoint accepts the GET method so I define a function called get. If I wanted this endpoint to also accept a POST method all I would do is define a post method in this class and add POST to the methods variable created at the top of the class. This variable isn\u2019t necessary for the method view but is for swagger, so if you\u2019re not using swagger you can leave this out. If you are using swagger however it will now expect documentation to be present in a file called get.yml, you may have guessed it already but the files are named after the HTTP method they serve. The explanation of the directory structure to the get.yml file is explained in the blueprints section below.", "Moving onto the def get method. The code in this function is wrapped in a try/except block to prevent the API from going down if an error occurs during any of the processing. This method obtains the inputs to the model as URL parameters defined on line 21 and converts is to a dictionary. The following line (22) then loads this features into the schema which in turn verifies the inputs. If this fails the validation error is raised which is caught in the try/except block and returned to the user. If it passes, the data is loaded into the data model which can now be used to make a prediction. The next line of code makes this prediction using the data model (lines: 23\u2014 27). Notice, how we can now reference the features by their name making it far nicer to look at in the code. The prediction is then returned to the user as a JSON object.", "At the top of the file I imported the settings module. Inside this module a global variable MODEL_NAME is defined. This variable states the name of the model to use which is subsequently assigned to the MODEL variable. I defined MODEL_NAME as an API configuration because it makes it easy to quickly switch between different models by simply changing a configuration in the app rather than source code. The MODEL variable is defined outside of the class because we only need the model to be loaded once. If this was defined in the get method it would mean loading the model every time a request comes in. This would greatly slow down response time of requests especially if the model is large.", "Blueprints allows us to modularise our application routes, for example, we may have a blueprint for admins only and a blueprint for users, therefore segregating the routes. For this to happen we need to create blueprints and register the endpoints to them, the code in blueprints.py does this for us:", "Typically speaking, to create a blueprint all you would do would is create an instance of the Blueprint class and register the endpoint to it with the add_url_rule method. In the code above I extend the Blueprint class by creating my own BaseBlueprint class that inherits the Flask\u2019s Blueprint class. I do this to make logging much easier. Flask\u2019s Blueprint class has two methods before_request and after_request which if assigned to methods are called before and after a request respectively. In the __init__ method of the BaseBlueprint class I call these two methods and assign _log_before_request to be called before every request and _log_after_request to be called after every request. In the _log_before_request method I log the endpoint which is called along with any arguments. The _log_after_request method logs the HTTP response status and the returned JSON payload. This may seem like a lot of work for a single endpoint and it is, but if we were to add new endpoints to the API all we would have to do is add the new view as a rule to this BaseBlueprint instance (literally 1 line of code) and we have logging implemented! This makes scaling the logging of your API much easier. I find this solution far more elegant that having logging implemented in the view functions themselves.", "Now all that needs to be done is to create an instance of the BaseBlueprint class, this is done on line 31. We then take that instance and add a URL rule to it (lines 33\u201336), meaning that every time this URL is called the assigned view function will be called. The add_url_rule method takes a single positional argument being a string which is the URL for this endpoint. I also add a keyword argument view_func which takes the MethodView (or SwaggerView in our case) we want to assign to this URL. Here, I assigned the PropertyPricePrediction view to this URL and state it\u2019s a view with the as_view method. This is done so the class is converted into view functions that can be used by the routing system. The keyword argument name in this method simply assigns a name for this view. The name defined here also provides a reference for Swagger in searching for the endpoint docs. Since this view has a get method the path to the get docs would have the following schema: <name of view>/<HTTP method>.yml and would translate to:property_price_prediction_v1/get.yml", "This file is the access point to start the API and mainly contains configuration:", "Let\u2019s go through it line by line:", "This is it the final file. The file that launches the API in a production setting. This file only imports the API instance (from api.py). I have this separated out so we can have different settings in production and any additional checks if we need to. You can run api.py directly but you will only be using flask\u2019s internal server which is not what we want and is not recommended for production. Instead what we will be using is a package called Gunicorn which is a Python WGSI server for UNIX and is compatible with many python web frameworks. If you\u2019re on Windows you can use Waitress. The calls to start the API is as follows:", "You should see something like this if your running on Unix / Mac:", "The API is now running and if you navigate to http://localhost:5000/apidocs you should see this:", "This is the page displaying the documentation of the API. Clicking on the blue bar will expand it revealing the capability of executing a query to the model like so:", "Clicking \u201cTry it out\u201d will allow you to enter values for the features, enter the following values for the features and hit \u201cexecute\u201d (button does not show until you have clicked \u201cTry it out\u201d):", "This value for is_house is not valid for our model and it should throw an error when you hit execute. Further down is the example curl request for the data you just entered along with the request URL (example curl request won\u2019t show until an query is executed). Below this is the actual response from the server. This example as expected should have returned 400 \u2014 Error: Bad Request along with this response body:", "This is exactly what we want, a clear error is return to the user explaining why the request failed. Now enter some values which should work:", "And hit execute. The curl request and request URL should be updated after hitting execute. You should also have a new response body with a status code of 200 indicating the query was a success. The response body should look something like:", "Showing what the model values this property at given the input features. Now if we take a look at the logs printed to the console you should see:", "The logs reveal the requests to the model along with the arguments passed and if the request failed. We can see the first request which failed because is_house must be a binary value. This is followed by our second request which satisfies the schema and a prediction is successfully returned.", "Hopefully it\u2019s clear to see why using Swagger is a necessary tool for your API, for very little work you get a lot of additional functionality which is totally worth it. This tool allows users to play around with your API, see it\u2019s constraints which will allow them to plan accordingly their consumption of this resource.", "Here, we\u2019ve built an API which deals with requests and gracefully fails returning the error to the user, making the API more transparent and less of a black box. The data schemas are a nice constraint to have as this prevents unintended use of the model outside of feature ranges it was trained on, thus preventing some awkward questions.", "That\u2019s it! Hopefully, in this post I\u2019ve show you why and how building a stable and user friendly API is important. Finally, thanks for reading and if there\u2019s interest, I may write posts on adding tests for the API and a further post on containerisation.", "Your home for data science. A Medium publication sharing concepts, ideas and codes."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fef4b2167934e&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@harpalsahota?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@harpalsahota?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": "Harpal Sahota"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F63149bc3725a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&user=Harpal+Sahota&userId=63149bc3725a&source=post_page-63149bc3725a----ef4b2167934e---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fef4b2167934e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fef4b2167934e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://pixabay.com/photos/milky-way-starry-sky-night-sky-star-2695569/", "anchor_text": "Source"}, {"url": "https://github.com/harpalsahota/DataScience/tree/master/Model_API_Example", "anchor_text": "GitHub account"}, {"url": "https://marshmallow.readthedocs.io/en/3.0/", "anchor_text": "marshmallow"}, {"url": "https://hackernoon.com/a-brief-tour-of-python-3-7-data-classes-22ee5e046517", "anchor_text": "post"}, {"url": "https://docs.python.org/3/howto/logging.html#logging-basic-tutorial", "anchor_text": "basic tutorial"}, {"url": "https://swagger.io/solutions/api-design/", "anchor_text": "Swagger"}, {"url": "https://github.com/rochacbruno/flasgger", "anchor_text": "Flassager"}, {"url": "https://github.com/zalando/connexion", "anchor_text": "Connexion"}, {"url": "https://swagger.io/docs/specification/2-0/basic-structure/", "anchor_text": "swagger docs"}, {"url": "http://flask.pocoo.org/docs/1.0/views/#method-views-for-apis", "anchor_text": "MethodView"}, {"url": "http://flask.pocoo.org/docs/1.0/tutorial/deploy/#run-with-a-production-server", "anchor_text": "not recommended"}, {"url": "https://gunicorn.org/", "anchor_text": "Gunicorn"}, {"url": "https://docs.pylonsproject.org/projects/waitress/en/latest/#", "anchor_text": "Waitress"}, {"url": "https://medium.com/tag/python?source=post_page-----ef4b2167934e---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/data-science?source=post_page-----ef4b2167934e---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/api?source=post_page-----ef4b2167934e---------------api-----------------", "anchor_text": "API"}, {"url": "https://medium.com/tag/model?source=post_page-----ef4b2167934e---------------model-----------------", "anchor_text": "Model"}, {"url": "https://medium.com/tag/flask?source=post_page-----ef4b2167934e---------------flask-----------------", "anchor_text": "Flask"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fef4b2167934e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&user=Harpal+Sahota&userId=63149bc3725a&source=-----ef4b2167934e---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fef4b2167934e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&user=Harpal+Sahota&userId=63149bc3725a&source=-----ef4b2167934e---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fef4b2167934e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2Fef4b2167934e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----ef4b2167934e---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----ef4b2167934e--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----ef4b2167934e--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----ef4b2167934e--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----ef4b2167934e--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@harpalsahota?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@harpalsahota?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Harpal Sahota"}, {"url": "https://medium.com/@harpalsahota/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "46 Followers"}, {"url": "https://www.linkedin.com/in/harpalsahota/", "anchor_text": "https://www.linkedin.com/in/harpalsahota/"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F63149bc3725a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&user=Harpal+Sahota&userId=63149bc3725a&source=post_page-63149bc3725a--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fea125248b5d0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-stable-and-user-friendly-api-for-your-model-ef4b2167934e&newsletterV3=63149bc3725a&newsletterV3Id=ea125248b5d0&user=Harpal+Sahota&userId=63149bc3725a&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}