{"url": "https://towardsdatascience.com/essential-programming-time-complexity-a95bb2608cac", "time": 1683002987.065546, "path": "towardsdatascience.com/essential-programming-time-complexity-a95bb2608cac/", "webpage": {"metadata": {"title": "Essential Programming | Time Complexity | by Diego Lopez Yse | Towards Data Science", "h1": "Essential Programming | Time Complexity", "description": "In computer programming, as in other aspects of life, there are different ways of solving a problem. These different ways may imply different times, computational power, or any other metric you\u2026"}, "outgoing_paragraph_urls": [{"url": "https://www.linkedin.com/in/lopezyse/", "anchor_text": "Linkedin", "paragraph_index": 40}, {"url": "https://twitter.com/lopezyse", "anchor_text": "Twitter", "paragraph_index": 40}], "all_paragraphs": ["In computer programming, as in other aspects of life, there are different ways of solving a problem. These different ways may imply different times, computational power, or any other metric you choose, so we need to compare the efficiency of different approaches to pick up the right one.", "Now, as you may know, computers are able to solve problems based on algorithms.", "Algorithms are procedures or instructions (set of steps) that tell a computer what to do and how to do it.", "Nowadays, they evolved so much that they may be considerably different even when accomplishing the same task. In the most extreme case (which is quite usual by the way), different algorithms programmed in different programming languages may tell different computers with different hardware and operating systems to perform the same task, in a completely different way. That\u2019s crazy, isn\u2019t it?", "The thing is that while one algorithm takes seconds to finish, another will take minutes with even small data sets. How can we compare different performances and pick the best algorithm to solve a particular problem?", "Fortunately, there are ways of doing this, and we don\u2019t need to wait and see the algorithm at work to know if it can get the job done quickly or if it\u2019s going to collapse under the weight of its input. When we consider the complexity of an algorithm, we shouldn\u2019t really care about the exact number of operations that are performed; instead, we should care about how the number of operations relates to the problem size. Think about it: if the problem size doubles, does the number of operations stay the same? Do they double? Do they increase in some other way? To answer these questions, we need to measure the time complexity of algorithms.", "Time complexity represents the number of times a statement is executed. The time complexity of an algorithm is NOT the actual time required to execute a particular code, since that depends on other factors like programming language, operating software, processing power, etc. The idea behind time complexity is that it can measure only the execution time of the algorithm in a way that depends only on the algorithm itself and its input.", "To express the time complexity of an algorithm, we use something called the \u201cBig O notation\u201d. The Big O notation is a language we use to describe the time complexity of an algorithm. It\u2019s how we compare the efficiency of different approaches to a problem, and helps us to make decisions.", "Big O notation expresses the run time of an algorithm in terms of how quickly it grows relative to the input (this input is called \u201cn\u201d). This way, if we say for example that the run time of an algorithm grows \u201con the order of the size of the input\u201d, we would state that as \u201cO(n)\u201d. If we say that the run time of an algorithm grows \u201con the order of the square of the size of the input\u201d, we would express it as \u201cO(n\u00b2)\u201d. But what does that mean exactly?", "The key to understanding time complexity is understanding the rates at which things can grow. The rate in question here is time taken per input size. There are different types of time complexities, so let\u2019s check the most basic ones.", "When time complexity is constant (notated as \u201cO(1)\u201d), the size of the input (n) doesn\u2019t matter. Algorithms with Constant Time Complexity take a constant amount of time to run, independently of the size of n. They don\u2019t change their run-time in response to the input data, which makes them the fastest algorithms out there.", "For example, you\u2019d use an algorithm with constant time complexity if you wanted to know if a number is odd or even. No matter if the number is 1 or 9 billions (the input \u201cn\u201d), the algorithm would perform the same operation only once, and bring you the result.", "Also, if you wanted to print out once a phrase like the classic \u201cHello World\u201d, you\u2019d run that too with constant time complexity, since the amount of operations (in this case 1) with this or any other phrase will remain the same, no matter which operating system or which machine configurations you are using.", "To remain constant, these algorithms shouldn\u2019t contain loops, recursions or calls to any other non-constant time function. For constant time algorithms, run-time doesn\u2019t increase: the order of magnitude is always 1.", "When time complexity grows in direct proportion to the size of the input, you are facing Linear Time Complexity, or O(n). Algorithms with this time complexity will process the input (n) in \u201cn\u201d number of operations. This means that as the input grows, the algorithm takes proportionally longer to complete.", "These are the type of situations where you have to look at every item in a list to accomplish a task (e.g. find the maximum or minimum value). Or you can also think about everyday tasks like reading a book or finding a CD (remember them?) in a CD stack: if all data has to be examined, the larger the input size, the higher the number of operations are.", "Linear running time algorithms are very common, and they relate to the fact that the algorithm visits every element from the input.", "Algorithms with this complexity make computation amazingly fast. An algorithm is said to run in logarithmic time if its time execution is proportional to the logarithm of the input size. This means that instead of increasing the time it takes to perform each subsequent step, the time is decreased at a magnitude that is inversely proportional to the input \u201cn\u201d.", "What\u2019s the secret of it? These type of algorithms never have to go through all of the input, since they usually work by discarding large chunks of unexamined input with each step. This time complexity is generally associated with algorithms that divide problems in half every time, which is a concept known as \u201cDivide and Conquer\u201d. Divide and Conquer algorithms solve problems using the following steps:", "1. They divide the given problem into sub-problems of the same type.2. They recursively solve these sub-problems.3. They appropriately combine the sub-answers to answer the given problem.", "Consider this example: let\u2019s say that you want to look for a word in a dictionary that has every word sorted alphabetically. There are at least two algorithms to do that:", "Which one of both is faster? While algorithm A goes word by word O(n), algorithm B splits the problem in half on each iteration O(log n), achieving the same result in a much more efficient way.", "Logarithmic time algorithms (O(log n)) are the second quickest ones after constant time algorithms (O(1)).", "In this type of algorithms, the time it takes to run grows directly proportional to the square of the size of the input (like linear, but squared).", "In most scenarios and particularly for large data sets, algorithms with quadratic time complexities take a lot of time to execute and should be avoided.", "Nested For Loops run on quadratic time, because you\u2019re running a linear operation within another linear operation, or n*n which equals n\u00b2.", "If you face these types of algorithms, you\u2019ll either need a lot of resources and time, or you\u2019ll need to come up with a better algorithm.", "In exponential time algorithms, the growth rate doubles with each addition to the input (n), often iterating through all subsets of the input elements. Any time an input unit increases by 1, it causes you to double the number of operations performed. This doesn\u2019t sound good, right?", "Algorithms with this time complexity are usually used in situations where you don\u2019t know that much about the best solution, and you have to try every possible combination or permutation on the data.", "Exponential time complexity is usually seen in Brute-Force algorithms. These algorithms blindly iterate an entire domain of possible solutions in search of one or more solutions which satisfy a condition. They try to find the correct solution by simply trying every possible solution until they happen to find the correct one. This is obviously a not optimal way of performing a task, since it will affect the time complexity. Brute-Force algorithms are used in cryptography as attacking methods to defeat password protection by trying random strings until they find the correct password that unlocks the system.", "As in quadratic time complexity, you should avoid algorithms with exponential running times since they don\u2019t scale well.", "Generally speaking, we\u2019ve seen that the fewer operations the algorithm has, the faster it will be. This looks like a good principle, but how can we apply it to reality?", "If we have an algorithm (whatever it is), how do we know its time complexity?", "In some cases, this may be relatively easy. Let\u2019s say you have an outer For Loop that iterates through all the items in the input list and then a nested inner For Loop, which again iterates through all the items in the input list. The total number of steps performed is n * n, where n is the number of items in the input array.", "But how do you find the time complexity of complex functions?", "To find the answer, we need to break down the algorithm code into parts and try to find the complexity of the individual pieces. Yes, sorry to tell you that, but there isn\u2019t a button you can press that tells you the time complexity of an algorithm. You have to do it yourself.", "As a rule of thumb, it is best to try and keep your functions running below or within the range of linear time-complexity, but obviously it won\u2019t always be possible.", "There are different Big O notations, like \u201cbest case\u201d, \u201caverage case\u201d, and \u201cworst case\u201d, but what really matters is the worst case scenario; those are the ones that can seriously crash everything. They go right to the heart of why time complexity matters and point to why some algorithms simply cannot solve a problem without taking a few billion years to do it.", "Worst case analysis gives the maximum number of basic operations that have to be performed during execution of the algorithm. It assumes that the input is in the worst possible state and maximum work has to be done to put things right. For example, for a sorting algorithm which aims to sort an array in ascending order, the worst case occurs when the input array is in descending order. In this case, maximum number of basic operations (comparisons and assignments) have to be done to set the array in ascending order. Think it this way: if you had to search for a name in a directory by reading every name until you found the right one, the worst case scenario is that the name you want is the very last entry in the directory.", "To sum up, the better the time complexity of an algorithm is, the faster the algorithm will carry out the work in practice. You should take into account this matter when designing or managing algorithms, and consider that it can make a big difference as to whether an algorithm is practical or completely useless.", "Interested in these topics? Follow me on Linkedin or Twitter", "Your home for data science. A Medium publication sharing concepts, ideas and codes."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fa95bb2608cac&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://lopezyse.medium.com/?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": ""}, {"url": "https://lopezyse.medium.com/?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": "Diego Lopez Yse"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F806fa785a6af&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&user=Diego+Lopez+Yse&userId=806fa785a6af&source=post_page-806fa785a6af----a95bb2608cac---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fa95bb2608cac&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fa95bb2608cac&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://unsplash.com/@icons8?utm_source=medium&utm_medium=referral", "anchor_text": "Icons8 Team"}, {"url": "https://unsplash.com?utm_source=medium&utm_medium=referral", "anchor_text": "Unsplash"}, {"url": "https://www.linkedin.com/in/lopezyse/", "anchor_text": "Linkedin"}, {"url": "https://twitter.com/lopezyse", "anchor_text": "Twitter"}, {"url": "https://medium.com/tag/programming?source=post_page-----a95bb2608cac---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/tag/data-science?source=post_page-----a95bb2608cac---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/technology?source=post_page-----a95bb2608cac---------------technology-----------------", "anchor_text": "Technology"}, {"url": "https://medium.com/tag/algorithms?source=post_page-----a95bb2608cac---------------algorithms-----------------", "anchor_text": "Algorithms"}, {"url": "https://medium.com/tag/performance?source=post_page-----a95bb2608cac---------------performance-----------------", "anchor_text": "Performance"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fa95bb2608cac&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&user=Diego+Lopez+Yse&userId=806fa785a6af&source=-----a95bb2608cac---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fa95bb2608cac&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&user=Diego+Lopez+Yse&userId=806fa785a6af&source=-----a95bb2608cac---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fa95bb2608cac&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2Fa95bb2608cac&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----a95bb2608cac---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----a95bb2608cac--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----a95bb2608cac--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----a95bb2608cac--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----a95bb2608cac--------------------------------", "anchor_text": ""}, {"url": "https://lopezyse.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://lopezyse.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Diego Lopez Yse"}, {"url": "https://lopezyse.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "944 Followers"}, {"url": "https://www.linkedin.com/in/lopezyse/", "anchor_text": "https://www.linkedin.com/in/lopezyse/"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F806fa785a6af&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&user=Diego+Lopez+Yse&userId=806fa785a6af&source=post_page-806fa785a6af--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Fe1178cb759ee&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fessential-programming-time-complexity-a95bb2608cac&newsletterV3=806fa785a6af&newsletterV3Id=e1178cb759ee&user=Diego+Lopez+Yse&userId=806fa785a6af&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}