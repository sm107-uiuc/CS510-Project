{"url": "https://towardsdatascience.com/numpy-indexing-explained-c376abb2440d", "time": 1683005055.478178, "path": "towardsdatascience.com/numpy-indexing-explained-c376abb2440d/", "webpage": {"metadata": {"title": "NumPy indexing explained. NumPy is the universal standard for\u2026 | by Alexandre Escol\u00e0 Nixon | Towards Data Science", "h1": "NumPy indexing explained", "description": "NumPy is the universal standard for working with Numerical data in Python. Multidimensional NumPy arrays are extensively used in Pandas, SciPy, Scikit-Learn, scikit-image, which are some of the main\u2026"}, "outgoing_paragraph_urls": [{"url": "https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing", "anchor_text": "Advanced Indexing", "paragraph_index": 3}, {"url": "https://github.com/AlexanderNixon/Machine-learning-reads/blob/master/NumPy-indexing-explained.ipynb", "anchor_text": "here", "paragraph_index": 4}, {"url": "https://stackoverflow.com/a/509295/9698684", "anchor_text": "this", "paragraph_index": 6}, {"url": "https://www.youtube.com/watch?v=o0EacbIbf58&t=1680s", "anchor_text": "very instructive talk", "paragraph_index": 13}, {"url": "https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing", "anchor_text": "docs", "paragraph_index": 16}, {"url": "https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html", "anchor_text": "docs", "paragraph_index": 19}, {"url": "https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html#general-broadcasting-rules", "anchor_text": "general broadcasting rules", "paragraph_index": 24}, {"url": "https://en.wikipedia.org/wiki/Cartesian_product", "anchor_text": "cartesian product", "paragraph_index": 41}, {"url": "https://docs.python.org/3/library/itertools.html#itertools.product", "anchor_text": "itertools.product", "paragraph_index": 41}], "all_paragraphs": ["NumPy is the universal standard for working with Numerical data in Python. Multidimensional NumPy arrays are extensively used in Pandas, SciPy, Scikit-Learn, scikit-image, which are some of the main data science and scientific Python packages. So a good understanding of NumPy is crucial if we are working with these tools! And so it is to understand its indexing methods, which we will go through in this post.", "Note that a key aspect or motivation in using NumPy, is that it enables to manipulate large quantities of numerical data in a vectorised way, that is, avoiding the use of inefficient python loops. The huge advantage of vectorising your code is that you\u2019re pushing all looping down to C level, which is much faster.", "Now let\u2019s get to the topic of the post, which is indexing NumPy arrays. Indexing with NumPy can be a little tough and counter-intuitive without a good understanding of its basic rules. Here we\u2019ll dive into the different indexing methods that can be used, which are:", "- Advanced Indexing (including both integer and boolean array indexing)", "Find a notebook version of this post along with all explanations here.", "NumPy\u2019s basic slicing is an extension of Python\u2019s basic slicing concept extended to N dimensions.", "It essentially allows you to take slices of an array along its dimensions using basic slicing notation, i.e start:stop:step. If you are not too familiar with Python\u2019s basic slicing notation you can check this post in stack overflow which makes it very clear. Let\u2019s see with an example:", "Yes, I know z is missing\u2026 Nothing against it, but we need a homogeneous matrix. This example array has a shape of (5, 5), so two dimensions. We can take slices along its dimensions (I\u2019ll be using the equivalent term axes) by following the mentioned notation, for instance:", "So far so good. We\u2019ve basically sliced the array along the first axis to get up to the second row starting at index 0 (note that the stop index is not included!), and along the second to get columns one to three. Think of the axes just as the (x,y,z) dimensions of a matrix. Where a third dimension can be simply though of as stacking multiple 2D arrays together:", "Okay, so now we know we can slice an n-dimensional array using python\u2019s slice notation. But what if you had to take values from a given axis using a list of indexes?", "Well, here\u2019s where advanced indexing comes into play \u2193", "Let\u2019s just go with an example of what an intuitive way of doing this would be:", "Okay, so following the same logic as in basic slicing, one could expect to get all values that fall into the above indexes along the different axes of the ndarray. Namely all values in rows 4, 3 and 1 which are in columns 2, 4 and 0 respectively, so the intersecting values that are highlighted bellow:", "Clearly not\u2026 (example inspired by this very instructive talk by Jaime Fern\u00e1ndez :) ) What happened there? Why are we getting a one-dimensional result?", "This is because advanced indexing follows a different set of rules. A good way to think about it, is that when using basic slicing, we are indexing on a grid which is defined by the slices we take on each dimension. Whereas using advanced indexing can be thought of as specifying a set of (x,y) coordinates of the values we want to retrieve.", "In the above case indexing with [4,3,1],[2,4,0] , will behave as indexing on(4,2) , (3,4) and (1,0) respectively. So each index we specify in each dimension, will be combined with the corresponding indexes from the other dimensions.", "More generally, when using advanced indexing, we must take into account these two main aspects (from the docs):", "Which basically means that we will retrieve as many elements from a given axis as indexes specified in the indexing array into that dimension. In the above case, we\u2019ve retrieved 3 elements specified by the length 3 indexing arrays.", "To understand the above we need to dive a little into broadcasting\u2026", "Going deep into broadcasting could easily lead to an another entire blog post, so i\u2019ll just try to cover the very essentials\u2026 From the docs:", "broadcasting is defined as a term describing how NumPy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is \u201cbroadcast\u201d across the larger array so that they have compatible shapes", "So basically, when some operation involving arrays with different shapes is performed, NumPy tries to make their shapes compatible before the operation takes place. Let\u2019s take a look at some visual examples:", "In the first case for instance, a one-dimensional NumPy array is added to an integer. So under the hood, before the addition takes place NumPy will broadcast the smaller shaped array across the larger, i.e it will replicate its value until its shape becomes compatible with that of the larger array.", "And how do we know if two shapes are compatible?", "We can find the general broadcasting rules defined in the docs. It is stated that two dimensions are compatible when", "Okay so what does all this have to do with advanced indexing? Well, reminding the second mentioned point, the resulting shape from an advanced indexing is identical to the (broadcast) indexing array shapes. This basically means that NumPy will try to make the shapes from the indexing arrays compatible before performing the indexing operation. A simple way to inspect what the resulting shape will look like (in the case the arrays can be broadcast) is by using np.broadcast . Let\u2019s see with the same example as above:", "Say we now want to index the array with:", "So using the above indexes, we would get an array with the shape:", "So here as we can see, a broadcast as in the first case in the figure above is taking place. The array will be indexed on the following (x,y) coordinates:", "Which, since both arrays are being broadcast, the above is equivalent to:", "So in order to index with integer arrays, we just have to make sure that their shapes can be broadcast together and then just let NumPy take care of the rest.", "Okay, so now we know how to index an array using integer indexes\u2026", "So the question that follows is\u2026.", "What if I want the indexing to behave as it does with basic slicing? i.e how can we obtain what we were expecting in the first case, instead of array(['W', 'T', 'F']) ?", "Let\u2019s go back to that example\u2026 We were using the indexes:", "In this case, as we verified before, we are getting a one-dimensional array as a result from:", "So we have to find a way for NumPy to understand that we want to retrieve a grid containing all values. How can this be done\u2026?", "The answer is\u2026 to USE BROADCASTING!!", "Taking into account that what broadcasting is doing is to stretch the smaller array so that all array shapes are compatible, we can leverage this idea to get the result we expected.", "What we can do is to add an axis to one of the arrays, so that NumPy broadcasts the smaller to fit the size of the larger (smaller here in terms of the amount of dimensions). That can be done with:", "Or we could equivalently use rows[:,None]. Now both indexing arrays con be broadcast together and can be used to index the array:", "We can think of this as generating the cartesian product of our lists of indexes in order to retrieve all of them from the array. We could actually reproduce this using itertools.product :", "So now by indexing the array with the broadcast indexes, we get:", "This broadcasting can also be achieved using the function np.ix_:", "So as we can see integer indexing is a really useful tool, we just need to understand how it works. A very common application is when we have an array or nested list of indexes, for instance:", "And we want to take these columns respectively along the first axis, so columns 3 and 4 from the first row, 0 and 2 from the second row and so on. How can we do that? Why don\u2019t you give it a try\u2026?", "As mentioned earlier, in integer indexing indexes along the dimensions are combined through broadcasting rules. Hence, leveraging broadcasting, we want to obtain a set of indexes whose combined shape is broadcastable to the desired output shape. Which in this case is straight forward, since we have a sublist for each row. So it becomes clear that we want a range containing as many values as rows to index across the first axis.", "So an obvious way to do this could be:", "As we can see the error is quite explicit, the indexing arrays cannot be broadcast together. This is because the shapes along the corresponding axis are not compatible, since we have that:", "With the above sketch it becomes clear that for the shapes to be compatible, we must add a new axis to rows, so that the second axes on both arrays have the same shape and the first axis of rows is 1, which satisfies the second rule of broadcasting:", "Now we would get as expected:", "Now for the last section\u2026 Is it possible to combine both types of indexing?", "WARNING\u2026! (this last section gets a little more complicated, and you\u2019ve already gone through the most relevant and useful stuff, so feel free to take a break, or leave it here if you think you\u2019ve had enough for now :)", "It is also possible to combine basic slicing and advanced indexing. This will lead to integer array indexes being broadcast together in the same fashion as we\u2019ve previously seen, and the slices behaving as we\u2019ve seen in the basic slicing section. However under some situations this can lead to unexpected results.", "Let\u2019s take the following example as a reference to better explain this:", "For combined indexing, we need to take into account these following guiding rules:", "That means that if we only use one integer array to index such as:", "So since basic slicing rules apply here the above would be equivalent to a[:2,:2].", "However, as soon as we have more than one indexing array, advanced indexing rules will apply:", "We we can see that adding an indexing array for the last axis, leads to an output the shape of which is dependant of the broadcast shape of both indexing arrays, which is (2,2).", "Let\u2019s take a look at some examples to see this more clearly. Taking for instance the following pairs of indexes:", "We could for instance, index along the two first axes using ix1 and ix2 respectively and take a full slice along the last axis. In such case we would get the 2D-arrays 0 and 1, rows 1 and 3 respectively and a full slice along the last axis for both cases:", "Note that as mentioned earlier, here both different method\u2019s rules work as expected and are combined. Basic slicing along the last axis is following the rules of basic slicing mentioned in the first section, so if you were to instead index with an array you\u2019d get:", "We could also index in the following way:", "So a full slice on the first axis to select all 2D arrays, then select rows 0 and 1 and columns 1 and 3 respectively, so:", "So finally if we use the indexing arrays to index on the first and last axes, as a[ix1, :, ix2], we would expect to index on the first two 2D-arrays, take a full slice on the second axis (so all rows), and columns 1 and 3 respectively. So:", "Going back to the second rule: The resulting axes introduced by the arrays indexes are at the front, unless they are consecutive. So since the indexing arrays here are not consecutive, the resulting axes on which they\u2019ve been used will come at the front, and the sliced dimension at the back.", "While it might seem very weird when indexing with 1-dimensional arrays, take into account that it is also possible to index with arrays of an arbitrary amount of dimensions. Say we are indexing the same example array both on the first and last axes with 3d arrays, both of shape (3,4,2). So we know that the final array will somewhere also have the shape (3,4,2), since both indexing arrays broadcast to the same shape. Now the question is, where do we place a full slice taken between the first and last axis?", "Given that it is no longer as clear that it should go in the middle, there is a convention in these cases which is that sliced dimensions go at the end.", "So in such cases it will be our task to rearrange the dimensions of the array to match our expected output. On the example above what we could do is to swap the last two axes and get as we expected with:", "Which is basically the same as transposing in this case, a[ix1, :, ix2].T.", "So, as a takeaway from this last section, we must be careful when combining both indexing methods since we might not always get what we expect. The safest will be to bear in mind the caveats of combined indexing to make sure that it will behave as we expect it to.", "Thanks a lot for taking the time to read this post and I hope you enjoyed it :)", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Personal interests \u2014 mainly photography and AI"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fc376abb2440d&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----c376abb2440d--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----c376abb2440d--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://alexandr-nixon.medium.com/?source=post_page-----c376abb2440d--------------------------------", "anchor_text": ""}, {"url": "https://alexandr-nixon.medium.com/?source=post_page-----c376abb2440d--------------------------------", "anchor_text": "Alexandre Escol\u00e0 Nixon"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F6f77c7bf8755&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&user=Alexandre+Escol%C3%A0+Nixon&userId=6f77c7bf8755&source=post_page-6f77c7bf8755----c376abb2440d---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc376abb2440d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc376abb2440d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://unsplash.com/@jlxp?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText", "anchor_text": "Jean-Louis Paulin"}, {"url": "https://unsplash.com/s/photos/rubik?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText", "anchor_text": "Unsplash"}, {"url": "https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#basic-slicing-and-indexing", "anchor_text": "Basic Slicing and Indexing"}, {"url": "https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing", "anchor_text": "Advanced Indexing"}, {"url": "https://github.com/AlexanderNixon/Machine-learning-reads/blob/master/NumPy-indexing-explained.ipynb", "anchor_text": "here"}, {"url": "https://stackoverflow.com/a/509295/9698684", "anchor_text": "this"}, {"url": "https://www.youtube.com/watch?v=o0EacbIbf58&t=1680s", "anchor_text": "very instructive talk"}, {"url": "https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing", "anchor_text": "docs"}, {"url": "https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html", "anchor_text": "docs"}, {"url": "https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html", "anchor_text": "Figure source"}, {"url": "https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html#general-broadcasting-rules", "anchor_text": "general broadcasting rules"}, {"url": "https://i.embed.ly/1/image?url=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FSU8uW4rBMMfR2Y3Dnh%2Fgiphy.gif&key=a19fcc184b9711e1b4764040d3dc5c07", "anchor_text": "giff from giphy"}, {"url": "https://giphy.com/gifs/reaction-BmmfETghGOPrW", "anchor_text": "giff from giphy"}, {"url": "https://en.wikipedia.org/wiki/Cartesian_product", "anchor_text": "cartesian product"}, {"url": "https://docs.python.org/3/library/itertools.html#itertools.product", "anchor_text": "itertools.product"}, {"url": "https://giphy.com/gifs/toXKzaJP3WIgM", "anchor_text": "gif from giphy"}, {"url": "https://gph.is/g/aRgqqrJ", "anchor_text": "gif from GIPHY"}, {"url": "https://medium.com/tag/data-science?source=post_page-----c376abb2440d---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/numpy?source=post_page-----c376abb2440d---------------numpy-----------------", "anchor_text": "Numpy"}, {"url": "https://medium.com/tag/machine-learning?source=post_page-----c376abb2440d---------------machine_learning-----------------", "anchor_text": "Machine Learning"}, {"url": "https://medium.com/tag/artificial-intelligence?source=post_page-----c376abb2440d---------------artificial_intelligence-----------------", "anchor_text": "Artificial Intelligence"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc376abb2440d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&user=Alexandre+Escol%C3%A0+Nixon&userId=6f77c7bf8755&source=-----c376abb2440d---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc376abb2440d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&user=Alexandre+Escol%C3%A0+Nixon&userId=6f77c7bf8755&source=-----c376abb2440d---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc376abb2440d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----c376abb2440d--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2Fc376abb2440d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----c376abb2440d---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----c376abb2440d--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----c376abb2440d--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----c376abb2440d--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----c376abb2440d--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----c376abb2440d--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----c376abb2440d--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----c376abb2440d--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----c376abb2440d--------------------------------", "anchor_text": ""}, {"url": "https://alexandr-nixon.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://alexandr-nixon.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Alexandre Escol\u00e0 Nixon"}, {"url": "https://alexandr-nixon.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "115 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F6f77c7bf8755&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&user=Alexandre+Escol%C3%A0+Nixon&userId=6f77c7bf8755&source=post_page-6f77c7bf8755--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F61596630de2c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-indexing-explained-c376abb2440d&newsletterV3=6f77c7bf8755&newsletterV3Id=61596630de2c&user=Alexandre+Escol%C3%A0+Nixon&userId=6f77c7bf8755&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}