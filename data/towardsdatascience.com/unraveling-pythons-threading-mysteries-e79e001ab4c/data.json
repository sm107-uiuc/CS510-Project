{"url": "https://towardsdatascience.com/unraveling-pythons-threading-mysteries-e79e001ab4c", "time": 1683012867.184721, "path": "towardsdatascience.com/unraveling-pythons-threading-mysteries-e79e001ab4c/", "webpage": {"metadata": {"title": "Unraveling Python\u2019s threading mysteries. | by Guillaume Crab\u00e9 | Towards Data Science", "h1": "Unraveling Python\u2019s threading mysteries.", "description": "Majority of our computers now have multi-core architectures, and terms such as multi-threading often ring in our ears as a way to improve the processing efficiency of applications. Python does offer\u2026"}, "outgoing_paragraph_urls": [{"url": "https://wiki.python.org/moin/Generators", "anchor_text": "generators", "paragraph_index": 20}, {"url": "https://docs.python.org/3/library/dis.html", "anchor_text": "here", "paragraph_index": 35}, {"url": "https://github.com/Guillaume-Cr", "anchor_text": "https://github.com/Guillaume-Cr", "paragraph_index": 43}], "all_paragraphs": ["Majority of our computers now have multi-core architectures, and terms such as multi-threading often ring in our ears as a way to improve the processing efficiency of applications. Python does offer several tools to parallelize computation, but they are not often well known. Let\u2019s pierce through their secrets in this article.", "First a small reminder about threading. What is a thread? It\u2019s a lightweight process that runs on your computer, executing it\u2019s own set of instructions. When you run two programs on your computer, you actually create two processes. Each of them has a set of instructions(open your browser or increase the volume) that it wants to have read by the scheduler (the referee that decides what to feed to the processor). The particularity of threads versus processes is that they can share variables.", "For us in terms of coding, when we run two threads, we allow two pieces of code to run at the same time. However it is different than just executing two programs at the same time since threads give us more control. For example we can share some variables between threads or we can wait for the threads to finish, merge the results and go on with the rest of the code. It is a very powerful tool that can allow faster computation or the ability to handle concurrent events (think of robots with multiple sensor data to process).", "Let\u2019s digress a bit and analyze the different possibilities Python offers to run computation in parallel. The three laureates are: Threads, Thread Pools, and Multi-Processing.", "For clarity, let\u2019s first introduce the function that we wish to parallelize. The sleep function, whose purpose is to\u2026 sleep.", "The Python library let us create Threads manually, for which we can specify the target (the function we wish to execute in this thread) and its arguments. The interface also includes a start function as well as a join function, which will wait until the execution of the thread is over. Joining threads is often desirable when we want to exploit the results returned by the thread. But the basic threading.Thread is quite limited in the sense that it does not let us access the variables returned by the sleep function.", "2. Thread Pools: (and it\u2019s library concurrent.futures)", "The thread pool executor provides a more complete set of interfaces for threading. However it\u2019s underlying implementation still uses the Threading library, which gives the same advantages and drawbacks as the previous option. In terms of interface differences, it proposes the concept of future, which will seem familiar to users of C++ 14. The biggest advantage of the futures for us here is that it allows to get the variable returned by the function we are threading using the result() interface.", "3. Multi-processing (from the library multiprocessing)", "Multiprocessing is the most complete library that can provide threading capabilities. The main difference with the two others else than providing more interfaces, is its ability to serialize and de-serialize data using a third-party library called pickle. Serialization is the ability to transform data types (int, array etc.) into binaries, sequences of 0 and 1. To do so is required to be able to send data using protocols (tcp/ip, http, udp\u2026) since these protocols are agnostic to the data types we use: the sender might be running his code in Python while the receiver might use C++. In the case of multi-processing, the serialization happens when we pass the function as well as the arguments to the pool object. This allows us to do something incredible: send this thread to be executed on.. another computer! As a matter of such, the multiprocessing library is aimed at enabling shared computation across multiple computers.", "To note, the multi-processing library provides the apply (sync) and apply_async interfaces, standing for synchronous and asynchronous. In the first case, the threads are forced to return in the same order as they were launched while in the second case the threads come back as soon as they are over. The apply_async provides an additional argument \u201ccallback\u201d that gives the possibility to execute a function when the thread returns (to store the result for example).", "Now it\u2019s time to compare the results of the different threading approaches. We first use the \u201csleep\u201d function previously mentioned to benchmark the results:", "We also compute the sleep function sequentially to provide a base result for comparison. Sleeping for 2s each time, we get a total computation time for the sequential approach which seems logical. We get a computation time of 2s for the threading and multiprocessing approaches which means all the thread could run in parallel successfully, but we obtain 4s for the thread pool executor, showing that there is some additional computation cost time in that process. Now this is very nice with only 3 threads running in parallel, but we might want to run more than a thousand threads. Let\u2019s see how it goes with a higher level of difficulty, say 100 threads:", "As for threading and thread pooling, the results didn\u2019t change from 3 to 100 threads. For the multi-processing approach however, the computation time jumped to 50s! To understand what is happening, let\u2019s look look at the warning that we so thoughtfully placed: \u201cWarning, trying to create more threads than available cores\u201d. As such, multiprocessing will try to dispatch the threads to the available cores (4 in my case) but if no core is available, we can guess that the computation of the threads are queued and thus becoming sequential.", "We could close off the topic and end up with, multi-processing is terrible, threading library is great. But wait a minute. Up until now, what we did in that threaded function was just sleeping, which means in terms of processing instructions: do nothing. Now, what if we have a thread which is much more greedy on computing resources. Let\u2019s take the example of the counting function:", "We use 4 threads (number of cores I have on my personal computer) and can see the following results:", "Here the multi-processing approach is at least 4 times faster the other two. But more importantly, threading takes almost as much time as the sequential approach while the thread pooling approach takes twice as much time, when the initial goal is to optimize the computation time!", "To understand why this is happening, we need to take a look at the GIL (Global Interpreter Lock). Python is an interpreted language while C or C++ are compiled language. What compilation does is transforming the written code into a language understandable by the processor: binaries. So when the code is executed it is directly read by the scheduler and then the processor. In the case of interpreted languages however, upon launching the program, the code is still written in human readable, here python syntax. So as to be read by the processor, it has to be interpreted at run-time by the so-called Python interpreter. However, a problem arises when threading. The Python interpreter does not allow to interpret multiple threads at the same time and consequently has a lock, the GIL to enforce that. Let\u2019s see a diagram to understand the situation better:", "In that case, the GIL acts as a bottleneck and nullify the advantages of threading. That explains quite well why the Threading and Pool Threading cases in the comparative analysis performed so poorly. Each of the threads is fighting to get access over the Python interpreter each time their respective count needs to be incremented and this a billion times, whereas when the threads are sleeping, the Python interpreter is only solicited once during the whole duration of the thread existence. If that\u2019s so, why is the multiprocessing approach providing significantly better results? The library is actually tricking the GIL by creating one instance of the Python interpreter for each thread:", "Thus the bottleneck disappears and the full threading potential can be unlocked.", "It is worth mentioning that multi-processing still has some down-sides due to the serialization process: not everything can be serialized. Especially, python generators or anything that has a pointer like behavior can\u2019t be serialized (which seems rather normal). Let\u2019s say we have and \u201cagent\u201d object with some unknown content (for example here some pytorch objects), we then end up with an error:", "We could interpret the differences between Threading and Multiproccessing in terms of computation efficiency. In this second part, we can take a closer look at the main difference as for how resources and variables are managed, especially for shared resources. Let\u2019s consider the code below which makes the threads use a global variable:", "This code runs totally fine even though we dispatched pieces of code to be evaluated by different processors (the child processes) accessing the same global variable. It means that all the python interpreters were able to access this global variable. So can the python interpreters communicate between each other at runtime? What is the sorcery behind this? Let\u2019s consider a variation of the code below:", "The purpose of this code is to intentionally change the value of the global variable during runtime from different threads. Not only this, but they are also doing it with different timings (observe the sleep with different inputs).", "If this variable was really global, when the second thread outputs the value of the global variable, it should already have been incremented quite a bit. However, we see that this value consistently has the value 1 when the thread is printing it. So now we have a better idea of what is happening. When the thread is created (and with it the python interpreter), all the variables are copied to the new thread, no exception made with global variables. In a sense, all the threads are identical copies of the larger process that you are running with slightly different arguments passed to the thread. Now multiprocessing offers different options related to how are the child processes created. We can choose between three start methods, namely spawn, fork and forkserver. We will analyze the first two ones. According to the Python documentation:", "So the main difference lies in what variables are inherited from the parent process upon creating a child process. Consider the code that was introduced above. If you observed carefully, you could notice that the start method was specified as \u201cfork\u201d. Let\u2019s see what this code actually outputted:", "Nothing special to see here, we know that the child process was able to access the global variable since it has copied it. Now let\u2019s see what happens when we switch to \u201cspawn\u201d:", "I can see the surprised expression in your eyes, no, you are not dreaming, you are seeing this multiple times. The \u201cprint(\u201cShould only see this once\u201d)\u201d was made at the very beginning of the program and totally out of the loop where the threads are dispatched. Yet this was printed 4 times. So what is happening? The Python documentation only tells us that \u201cThe parent process starts a fresh python interpreter process\u201d and that it only inherits the objects necessary for the run() method (understand the function that you are trying to thread). What you need to understand from this is inherited = copied, and not_inherited = re-evaluated. So when we are choosing \u201cspawn\u201d, every instruction of the process is re-interpreted, the function calls as well as variables memory allocation.  Now you can notice the \u201cif __name__ == \u2018__main__\u2019:\u201d statement. What this does is signifying to the interpreter that whatever is inside is belonging to the main, and should therefore be inherited by the child process. Everything not in that statement will be re-evaluated for each child process. It means that by default \u201cspawn\u201d is trying to re-evaluate everything, but we do have control over what gets inherited, while for \u201cfork\u201d, every variable gets inherited by default. You could wonder why would this matters, in the case of our global variable it doesn\u2019t change much. But for some objects, the copy constructor (when you are using the = operator) might not be well defined, which makes it unsafe to use the fork method in some occasions. For that reason, it can be seen in the python documentation that the spawn method is moving to be the default start method over all platforms.", "You might be wondering that this is a rather heavy limitation, if the threads created by multiprocessing are totally closed off, we lose the ability to have a degree of synchronization between the threads. This is not entirely true as the library put at our disposal some tools to do exactly that: Pipes.", "Result: \u201cSlept for: 2.00\u201d, which means the thread actually waited to receive the data provided by the parent process before moving on. In a way, pipes are an equivalent of C++ futures where we are able to wait for the acquisition of some data provided by a different thread. But of course in this case, since the multiprocessing can be happening on different computers, the data sent through the pipes also need to be serialized under the hood.", "We spoke about resources management for multiprocessing. For the threading library (and thread-pool executors), things are a bit different since we only have one python interpreter. Let\u2019s see an example:", "We launch 4 threads at the same time, with a small different delay for each of them to actually start counting.", "Contrary to multiprocessing, the global variable is here shared across the threads and do not hold a local copy. If you are used to manipulated threads, you would probably be horrified by the above code, shouting out terms as \u201crace condition\u201d or \u201clocks\u201d. A lock (which can be shared across threads), is a sort of gate keeper that only allows one thread to unlock the door of code execution at the same time, so as to prevent variables to be accessed or modified at the same time. Wait, we actually already heard that somewhere: The GIL (Global interpreter lock).", "So python does already have a lock mechanism to prevent two threads to execute code at the same time. Great news, the above code might not be that horrible. Let\u2019s prove it by printing the total count generated after the execution of the three threads (and removing the sleeps). Since the GIL protects us from thread executing instructions at the same time, no matter which thread is incrementing the global variable, we should add 10e5 * 4 times 1 so a total of 4.000.000.", "Ok, we need some explanation here. Especially how the GIL is actually working. The description \u201conly let one thread run at the same time\u201d might not be accurate enough to explain the situation. If we delve a bit more into the details, we can see this: \u201cIn order to support multi-threaded Python programs, the interpreter regularly releases and reacquires the lock \u2014 by default, every ten bytecode instructions\u201d. So this is not the same as allowing only one line of actual python code being read at the same time. To fully understand this, we need to get down a level.", "What happens when you execute a python program? The python interpreter will first compile the code (at runtime) into something more easily transformed into bytes (the food given to the processor unit). For python, this intermediate code is called bytecode. The full description of the bytecode operations can be found here. The dis module enables us to take a look at what the bytecode looks like for a specific function. If we try to have a glimpse over a function that adds 1 to a global variable:", "To simply add one constant to a variable, we need 4 bytecode operations, fetching the variables, adding them together and storing the result.Now that we have a better understanding of what is a bytecode operation, we can notice that the GIL comes with settings that we can control: the sys.setcheckinterval() enables us to control every how many bytecodes we want to lock the GIL. But even though we set this to 1 (The GIL gets locked every bytecode instruction), this is not really going to help us. Let\u2019s analyze what happens in the case where we have the GIL locking every 3 bytecodes:", "The numbers 1 to 4 represent the order in which the bytecode groups are allowed to be processed by the GIL. Now let\u2019s imagine the global variable has initially a value of 0. In each thread, we are trying to add 1 to this variable. At the end of the execution of the bytecode group \u201c1\u201d, the copy of the variable that it got from LOAD_FAST got incremented (INPLACE_ADD) by 1. But the global variable itself was not modified yet as STORE_FAST was not executed. Now it\u2019s the turn of the second thread: since the variable was not stored, it will still make a copy of the global variable with the value 0 and increments 1 to it. Now when the group 3 gets executed, the global_variable finally gets stored with the value 1. But as you can imagine, upon execution of group 4, the local copy also has the value 1 and the global variable will be store once again with a 1, while we would expect it to be 2. The bad news is, it doesn\u2019t matter how frequently we lock the GIL, as long as the part of the \u201cglobal_variable += 1\u201d equivalent bytecodes get mixed up, we have a race condition.", "So the GIL is not enough to protect our variables, and we have no choice than using locks to force it on the interpreter to only execute some block of code one at a time across threads:", "That worked about right, the threads counted up to the correct number, while doing this job in parallel. However, if you look at the total computation time, this is over the roof. Acquiring and releasing the locks is indeed time consuming, and when we need to access the variables as often as we do here, it accumulates to form this very heavy computation time.", "Now it\u2019s time to sum up our experience with parallel computation in Python:", "So when to use multiprocessing and when to use Threading? We can analyze two use cases of parallelization for applications.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Robotics Software Engineer, dreaming of creating robots with intelligence beyond the scope of the human brain. https://github.com/Guillaume-Cr"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fe79e001ab4c&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://gcrabemp.medium.com/?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": ""}, {"url": "https://gcrabemp.medium.com/?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": "Guillaume Crab\u00e9"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fea42d028f128&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&user=Guillaume+Crab%C3%A9&userId=ea42d028f128&source=post_page-ea42d028f128----e79e001ab4c---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe79e001ab4c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe79e001ab4c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://unsplash.com/@cadop?utm_source=medium&utm_medium=referral", "anchor_text": "Mathew Schwartz"}, {"url": "https://unsplash.com?utm_source=medium&utm_medium=referral", "anchor_text": "Unsplash"}, {"url": "https://wiki.python.org/moin/Generators", "anchor_text": "generators"}, {"url": "https://docs.python.org/3/library/dis.html", "anchor_text": "here"}, {"url": "https://medium.com/tag/python?source=post_page-----e79e001ab4c---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/multithreading?source=post_page-----e79e001ab4c---------------multithreading-----------------", "anchor_text": "Multithreading"}, {"url": "https://medium.com/tag/reinforcement-learning?source=post_page-----e79e001ab4c---------------reinforcement_learning-----------------", "anchor_text": "Reinforcement Learning"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe79e001ab4c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&user=Guillaume+Crab%C3%A9&userId=ea42d028f128&source=-----e79e001ab4c---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe79e001ab4c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&user=Guillaume+Crab%C3%A9&userId=ea42d028f128&source=-----e79e001ab4c---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe79e001ab4c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2Fe79e001ab4c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----e79e001ab4c---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----e79e001ab4c--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----e79e001ab4c--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----e79e001ab4c--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----e79e001ab4c--------------------------------", "anchor_text": ""}, {"url": "https://gcrabemp.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://gcrabemp.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Guillaume Crab\u00e9"}, {"url": "https://gcrabemp.medium.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "96 Followers"}, {"url": "https://github.com/Guillaume-Cr", "anchor_text": "https://github.com/Guillaume-Cr"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fea42d028f128&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&user=Guillaume+Crab%C3%A9&userId=ea42d028f128&source=post_page-ea42d028f128--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2Faa70df854abc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funraveling-pythons-threading-mysteries-e79e001ab4c&newsletterV3=ea42d028f128&newsletterV3Id=aa70df854abc&user=Guillaume+Crab%C3%A9&userId=ea42d028f128&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}