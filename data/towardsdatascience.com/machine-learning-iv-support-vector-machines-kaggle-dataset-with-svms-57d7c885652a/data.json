{"url": "https://towardsdatascience.com/machine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a", "time": 1683010439.015518, "path": "towardsdatascience.com/machine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a/", "webpage": {"metadata": {"title": "Deep Dive Into Support Vector Machines | by Vardaan Bajaj | Towards Data Science", "h1": "Deep Dive Into Support Vector Machines", "description": "In the previous post, we had a good look at high bias and variance problems in machine learning and discussed how regularization plays a big role in solving these issues along with some other\u2026"}, "outgoing_paragraph_urls": [{"url": "https://medium.com/analytics-vidhya/contents-9b2e49f49fe9", "anchor_text": "previous", "paragraph_index": 5}, {"url": "https://en.wikipedia.org/wiki/Kernel_method", "anchor_text": "kernel methods", "paragraph_index": 32}, {"url": "https://data-flair.training/blogs/svm-kernel-functions/", "anchor_text": "different types of kernel methods", "paragraph_index": 33}, {"url": "https://web.stanford.edu/class/ee392o/subgrad_method.pdf", "anchor_text": "this", "paragraph_index": 42}, {"url": "https://www.coursera.org/learn/machine-learning", "anchor_text": "machine learning course", "paragraph_index": 44}, {"url": "https://www.kaggle.com/mlg-ulb/creditcardfraud", "anchor_text": "here", "paragraph_index": 46}, {"url": "https://www.kaggle.com/vardaanbajaj/credit-card-fraud-svm?scriptVersionId=38180580", "anchor_text": "here", "paragraph_index": 67}, {"url": "https://medium.com/analytics-vidhya/machine-learning-v-decision-trees-random-forest-kaggle-dataset-with-random-forest-3ebfe6d584be", "anchor_text": "next", "paragraph_index": 69}, {"url": "http://linkedin.com/in/vardaan-bajaj-23a279124/", "anchor_text": "linkedin.com/in/vardaan-bajaj-23a279124/", "paragraph_index": 71}], "all_paragraphs": ["In this post, we\u2019ll go through:", "(i) Role of Support Vectors in SVMs", "(iii) SVMs as a Large Margin Classifier", "(iv) Non-Linear Decision Boundaries through SVMs with the help of Kernels", "(v) Fraudulent Credit Card Transaction Kaggle Dataset Detection using SVMs", "In the previous post, we had a good look at high bias and variance problems in machine learning and discussed how regularization plays a big role in solving these issues along with some other techniques. In this post, we\u2019ll be having a detailed look at another supervised learning algorithm called the Support Vector Machine. Later in the post, we\u2019ll be solving a Kaggle dataset to detect Fraudulent Credit Card Transactions using the SVM.", "SVM is a supervised machine learning method which solves both, regression and classification problems. However, it is mostly used in classification problems where it constructs hyperplanes in the n-feature dimensions. An n-dimension feature space has a hyperplane of n-1 dimensions. Eg. In the dataset with 2 features (2-dimeansional feature space), the hyperplane constructed by the SVM is a curve(line, circle, etc.) If we are solving a classification problem on 2 classes, then the job of the SVM classifier is to find the hyperplane that maximizes the margin between the 2 classes. Before we look at how SVMs work, let\u2019s understand where the name Support Vector Machine came from.", "We know that an SVM classifier constructs hyperplanes for classification. But how does the SVM classifier construct a hyperplane? Let\u2019s develop intuition by considering just 2 classes. We know that a hyperplane has to pass from somewhere in the middle of the 2 classes. A good separation between these classes is achieved by the hyperplane that has the largest distance to the nearest training data points from both the classes. In the figure alongside, the 2 dotted lines that mark the extremes of each class constitute the support vectors for each class. These support vectors help in finding the hyperplane that maximizes the distance (margin) of the hyperplane from each of the 2 classes with the help of their support vectors.", "Support Vector Machines can fit both linear and non-linear decision boundaries as a classifier and one of the main advantages SVMs have over Logistic Regression is that they compute the training parameters fast due to a much simplified cost function.", "Let\u2019s recall the binary crossentropy cost function used for binary classification in logistic regression. Here, for the sake of simplification, we\u2019ll ignore the bias term, so the final prediction that we make for the ith training example out of a total of \u2018m\u2019 training examples through logistic regression will be represented as h(x(i)) = sigmoid(W * x(i))", "This cost function can be divided into 2 parts: when y(i) = 1 the term (1 \u2014 y(i))*log(1 \u2014 h(x(i))) becomes 0 and when y(i) = 0, the term y(i)*log(h(x(i))) becomes 0. The corresponding graphs for these equations (Cost vs W * x) (excluding the regularization term, since it is common to both) are:", "SVM uses a slight modification of this cost function which provides it computational advantages over logistic regression. For the case y = 1, we see that the cost function has all its values closer to 0 when W * x >= 1 and when W * x < 1, the -log(h(x)) function values are approximated by a straight line by calculating the derivative of the cost function when W * x = 0. Similarly for the case y = 0, we see that the cost function has all its values closer to 0 when W * x <= -1 and when W * x > 1, the -log(1 \u2014 h(x)) values are approximated by a straight line by calculating the derivative of the cost function when W * x = 0.", "Now since we are no longer using logarithmic cost function, let\u2019s rename the log part in the logistic regression cost function. Let\u2019s replace -log(h(x)) with cost1(h(x)) and -log(1 \u2014 h(x)) with cost0(h(x)). We\u2019re ignoring the constant (1/m) here as it doesn\u2019t affect our minimization objective and helps us to simplify our calculations. So, the final cost function for support vector machine looks like:", "This leads to the following mathematical equation for the cost function:", "Unlike logistic regression which outputs probability values, SVMs output 0/1. When h(x) >=1, the SVM outputs 1 and when h(x) <= -1, the SVM outputs 0. In logistic regression, we saw that when h(x) > 0, the output was a probability > 0.5, which was rounded-off to 1 and when h(x) < 0, the output was a probability < 0.5 which was rounded-off to 0. The range of (-1, 1) is an extra safety margin factor which allows SVMs to make more confident predictions than logistic regression.", "Let us now re-parameterize the cost function a bit. Currently our cost function is of the form A + \u03bb*B, where A is the cost function and B is the regularization term. Let\u2019s convert it to C*A + B form, where C plays a role similar to 1/\u03bb.", "Earlier, we read about the role of support vectors in finding a hyperplane that acts as a classifier which is at a maximum distance from each of the 2 classes. Such a classifier is known as a Large Margin Classifier. A large margin classifier is the one which predicts the classes for given data points with greater confidence. This was not the case with logistic regression. Let\u2019s see why this happens with SVM.", "We re-parameterized the SVM cost function to C*A + B, where A is the loss associated with the SVM output (the cost component), B is the regularization term (regularization component) and C plays a role similar to 1/\u03bb. When we choose C to be very large, then our model will be prone to overfitting. To counter this, we would want that A should be close zero otherwise there would be a huge cost which is undesirable. Since the value of A is directly proportional to the parameter W (represented by \u2018theta\u2019 in figures), this means that the parameters themselves will have very small values. So, in case of large C, the optimization objective is simply to find the minimum value of the training parameters present in B. Formally defining, the minimization objective in this case is:", "In the implementation of SVMs, vectorization is used and the dot product of vector W (\u2018theta in figure\u2019) and the vector of features (X) is computed. From the knowledge of multiplication of matrices, we know that when dot product of 2 vectors (let\u2019s say u and v) is computed, we get the projection of vector u on the vector v. In the same way, when dot product of W and X is computed, we get the projection of the vector X on W and the length of projection (P) is equal to", "where ||thetha|| is the L2 norm of theta. This equation can be represented as:", "So, the minimization objective can be rephrased as follows:", "Now let\u2019s take an example to see how this minimization objective leads to a large margin classifier in SVM.", "Consider the following binary classification problem where \u2018X\u2019 represents the feature x1 and the \u2018O\u2019 represents the feature x2. From our current optimization objective we know that the SVM minimizes the cost function only when p.||theta|| <= -1 for y = 0 (x1) and p.||theta|| >= 1 for y = 1 (x2) i.e. the angle between the projection of a training example and the vector of parameters is either between 900\u20131800 and 2700\u20133600 respectively.", "In the image below, consider the decision boundary in the left image (green). The vector of parameters (theta vector) is perpendicular to it since the region to the right of the vector of parameters has angles from 900\u20131800 and the region to the left of the decision boundary has angles between 2700\u20133600. For this decision boundary, we see that the length of projections of training examples (represented by red and pink) is quite small. To satisfy the conditions of p.||theta|| <= -1 for y = 0 (x1) and p.||theta|| >= 1 (x2) in this case, theta needs to have a large value. Due to this, the value of the cost function is not minimized and hence the decision boundary represented in green in the left image won\u2019t be selected by the SVM.", "Now, consider the decision boundary (green) for the image below at right. For the same training examples, we see that their projection on the vector of parameters is greater as compared to the previous decision boundary. Now to satisfy the conditions of p.||theta|| <= -1 for y = 0 (x1) and p.||theta|| >= 1 (x2), we already have a large value of the projection vector \u2018p\u2019. This means that a small value of theta will suffice, which in turn minimizes the cost function as well. Hence the decision boundary represented in the image on the right will most likely be selected by the SVM for the binary classification task and by comparing both the decision boundaries, we can clearly see that the classifier selected by the SVM is indeed a large margin classifier.", "Let\u2019s keep in mind that the conclusion that we have drawn above is proven when the parameter C in the SVM equation C*A + B was very large. We can get similar results when the value of C is small and hence we generalize this claim. I encourage the reader to think about it. This will help clarifying the mathematics behind the SVM even more.", "So far we have seen the scenario where SVM is used as a classifier with linear decision boundaries. SVM uses kernel methods for this task. Before we get onto kernel methods, let us understand why complex polynomial features won\u2019t work well for non-linear SVM classification. Let\u2019s have an intuition about it with the help of linear regression.", "In linear regression, for training data with \u2019n\u2019 input features, we represent the output as follows:", "The output we get for \u2018m\u2019 training examples is a straight line. So how can we teak this to get a non-linear decision boundary? Well, we know that polynomials of degree > 1 produce non-linear outputs. But using these polynomials as input features has the following problems:", "(i) For the number of features as small as 5, there are tonnes of possibilities for the choosing features. A sample representation of the output can be y = W1x1\u00b2 + W2x2\u00b3x3\u00b2 + W3x1\u00b2x4\u00b2x5 + W4x2x4\u00b3 + \u2026\u2026\u2026 (there can be tonnes of possibilities). Remember that a polynomial of degree 5 does not need to have all features of 5-degree.", "(ii) With such complex feature representation, the decision boundary can\u2019t be intuitively determined which makes it difficult to tune the features to get better results.", "(iii) Additionally, computing these complex features is computationally very expensive and hence undesirable.", "Due to all the drawbacks of polynomial feature vectors for non-linear classifiers mentioned above, SVMs provide a very smart and efficient way to generate non-linear decision boundaries by incorporating the use of kernel methods. The magic of the kernel is to find a function that avoids all the trouble implied by the high-dimensional computation. In machine learning, kernel methods are a class of algorithms for pattern analysis, whose best known member is the Support Vector Machine. Kernel methods require a user-specified kernel, i.e., a similarity function over pairs of data points in raw representation. Kernel methods are preferred over feature vectors since they reduce the computational time drastically while computing complex non-linear decision boundaries. The output of a kernel method is a scalar.", "Here, although we are limiting the use of kernels to SVMs, one important thing to note is that every machine learning algorithm that can be expressed using dot-products can be replaced by kernels. Then we can use any of these machine learning algorithms with kernels, which give both, quick and better results. Although there are different types of kernel methods, I\u2019ll be using Gaussian Kernel for further illustration.", "If kernels don\u2019t do such complex calculations, then how do they generate such good non-linear decision boundaries? Some landmarks are defined for the training examples and the similarity of each of the examples is computed with every defined landmark using the similarity function (kernel). The Gaussian kernel or Gaussian similarity function for the training example xi and the landmark lj is represented as exp(-||xi \u2014 lj||2 / 2\u03c32). From this, we can see that for a training example xi close to the landmark, its feature value fi is close to 1 and for a training example xi quite far away from the landmark, its feature value is close to 0, which seems a good measure for similarity.", "The calculated similarity values using the Gaussian kernel are considered as the new features values of the respective training examples which can then be attached with their weight parameters (W/theta) to compute the final output class. Earlier in the post we saw that the minimisation objective was subject to the conditions when the dot product of the weight vector and the input feature vector was either >=1 or <= -1. After computing the new feature values using kernels, the conditions of the optimization objective change a bit. Although the inequality values remain the same, the dot product is now computed between the weight vector and the new feature vector computed using Gaussian kernel. Just to clarify, although the output of the kernel method is a scalar value, that scalar value is computed against a single landmark. Against L landmarks, L values are computed which then form a feature vector for a given training example.", "Consider a training dataset (with 2 features only for demonstration purposes) with 2 output classes that don\u2019t have a linear decision boundary. Let\u2019s see how defining a few landmarks (let\u2019s say 3) on the training set helps in solving non-linear decision boundaries. In the figure below, we see that for the training example X in pink, it\u2019s quite close to the landmark L1 as compared to the landmarks L2 and L3. Computing the similarity using the Gaussian Kernel for this example, we get feature value f1 corresponding to L1 as close to 1 and the ones corresponding to L2 and L3 (f2 and f3) as close to 0. According to the above equation, we predict one when theta * f >= 1. Now, if the theta values corresponding to these features are 2, 0.5, and 1, then 2*1 + 0.5*0 +1*0 = 2 i.e. >= 1. Performing the same step for multiple training examples gives us a proper non-linear decision boundary with a high accuracy.", "We saw how landmarks combined with kernel methods help in defining complex non-linear decision boundaries in SVMs. Now the obvious question of the selection of landmarks arises. One way to choose the landmarks is to convert all the training examples as landmarks and then the feature vector for each training example is calculated by computing similarity between the training example and each landmark using the Gaussian Kernel.", "Once these landmarks are chosen and these new feature vectors are calculated, the final optimization objective is modified to:", "where f(i) represents the new feature vectors calculated using the Gaussian kernel. One thing to note here is that the number of feature vectors (n) will be equal to the number of training examples (m) since each training example is a landmark.", "We saw in linear and logistic regression how we computed weights using Gradient Descent. We can\u2019t use gradient descent in its raw form to compute the optimal weight parameters for SVMs because the cost function in the SVM is not differentiable at all points. So, in order to compute weight parameters for SVM, some variants of gradient descent like sub-gradient descent or even various complex algorithms are used. The weight update in sub-gradient descent looks like:", "W = W \u2014 alpha * subgradient_wrt_W(J), where \u2018alpha\u2019 is the learning rate.", "Solving for sub-derivatives is not as simple as partial derivatives and requires us to understand limits and inequalities well. The first 2 pages of this pdf from Stanford is a good resource that will give you an intuition of how the sub-derivatives are calculated.", "Once the optimal weight parameters for a classification task are calculated, we can run the SVM classifier and calculate the train and test accuracy to evaluate the model\u2019s performance.", "At times in this post, I\u2019ve used various examples by Andrew NG sir while teaching SVMs on coursera along with my ability to provide intuition for the same. I recommend checking the machine learning course offered by him if you can spare yourself time for that.", "So far, we\u2019ve learned quite a bit about SVMs. We started from the role of support vectors, then understood how the cost function of SVM implicitly favours large margin classifier in depth followed by the use of kernel trick to calculate non-linear decision boundaries with ease of computation through various illustrations to make things easy to understand. In the end we learnt how vanilla (plain) gradient descent does not work for calculating weight parameters, so the need to use sub-gradient descent was realized. After having learnt this much, it\u2019s now time for us to shift our focus to the Credit Card Transactions Kaggle dataset in order to consolidate our concepts and see the SVM in action.", "In this section, we\u2019ll be using an SVM to determine fraudulent credit card transactions. Dataset for this problem can be found here. One thing to note here is that the features of this dataset are already computed as a result of PCA (Principal Component Analysis, which we\u2019ll see in a later post) transformation. It helps in 2 ways:", "(i) The confidentiality of the user data is maintained.", "(ii) The features in the dataset are independent of each other due to PCA transformation.", "Let\u2019s get started by loading the dataset in memory as a dataframe.", "The dataset has 31 columns/features out of which 28 have been computed through PCA transformation and other features are numerical features only. Let\u2019s now see how the fraudulent and non-fraudulent transactions are distributed in the dataset.", "There are 492 fraudulent (1) transactions as compared to 284315 non-fraudulent (0) ones, which is highly skewed. Clearly we need to resample our data else we can achieve high accuracy by simply predicting every transaction as 0 (non-fraudulent).", "There is no use of such a system since all the fraudulent transactions are ignored. We need an equal amount of fraudulent and non-fraudulent transactions for training in order to better capture the features of both kinds of transactions. First of all, let\u2019s analyse the fraudulent transactions data wrt \u2018Time\u2019 and \u2018Amount\u2019.", "At all times we have some number of fraudulent transactions making time an irrelevant factor while predicting them. Additionally, most of the fraudulent transactions are very small amount values as seen from the plot above.", "The given dataset says that the features have been calculated using PCA transformation, hence they should be independent of each other. Let us check if this is the case by calculating the correlation between the features.", "The diagonal across the heatmap represents the highest correlation (close to 1.0), which is the correlation of a feature with itself. The correlation between other pairs of features has values between -0.2 to 0.2, which corresponds to very less correlation. This represents that the features mentioned are indeed independent of each other and hence no feature can be eliminated based on their dependency on each other.", "Since the number of total fraudulent transactions is too small as compared to non-fraudulent transactions, we need to resample the dataset. By applying oversampling, we repeat the fraudulent transactions until they are close in number to non-fraudulent transactions. By applying undersampling, we eliminate a number of non-fraudulent transactions so that the final number of non-fraudulent transactions is roughly the same as fraudulent transactions in the dataset. By applying oversampling to this dataset, the training dataset will become huge (284315 non-fraudulent transactions as compared to just 492 fraudulent ones), so we use undersampling.", "Since there are 385 fraud transactions, we\u2019ll bring down non-fraudulent transactions to around this number to have equal number of training examples of each kind.", "We can now see that the \u2018Class\u2019 column has both 0s and 1s. We took the first 200,000 samples from the dataset and chose 400 (close to 385) non-fraudulent transactions randomly from the total of 284,315 non-fraudulent transactions. Hence, we have successfully implemented undersampling and our final training set consists of 785 training examples. Undersampling can lead to the loss of some important features in the data. But first of all, let\u2019s see the results we get by applying the SVM classifier. Let\u2019s now split data into train and test sets.", "We see that test dataset contains 107 fraudulent transactions. If the SVM classifier performs considerably well on non-fraudulent transactions and can also detect a lot of these fraudulent transactions, we can say that our model did pretty good.", "Now, we have applied the SVM classifier on the training dataset and have stored the prediction results on the test dataset in a \u2018predictions\u2019 variable. To evaluate the model\u2019s performance, let\u2019s plot the confusion matrix and identify the following:", "(i) True positives: The original output class was a positive example (here non-fraudulent transaction) and the predicted output class was also a positive example (here non-fraudulent transaction).", "(ii) False positives: The original output class was a positive example (here non-fraudulent transaction) but the predicted output class was a negative example (here fraudulent transaction).", "(iii) False negatives: The original output class was a negative example (here fraudulent transaction) but the predicted output class was a positive example (here non-fraudulent transaction).", "(iv) True negatives: The original output class was a negative example (here fraudulent transaction) and the predicted output class was also a negative example (here fraudulent transaction).", "For a banking system, it\u2019s fine if some non-fraudulent transactions are detected as fraudulent, they\u2019ll look into it, but if fraudulent transactions are labelled as non-fraudulent, then that can cause huge losses. Hence, our objective is to reduce the total number of false negatives as much as possible and on the same hand, try that the number of false positives are on the lower side as well. Now, let\u2019s plot the confusion matrix.", "From this, we can conclude that most of the fraudulent transactions have been captured and only 11 of them were misclassified, which is way better than a model which yields an extremely high accuracy but doesn\u2019t capture any fraudulent transaction as we discussed earlier while solving this problem.", "The entire code for this post can be found here.", "Our primary focus was on capturing as many fraudulent transactions as we could and we\u2019ve done a great job by detecting 96/107 fraudulent transactions given that we had only around 800 fraudulent examples in the entire dataset.", "That\u2019s it for this post. We went into a lot of depth into the concepts of SVMs and I made sure I provided intuition for each part in order for the readers to better grasp things quickly. The only topic that we didn\u2019t discuss in detail was sub-gradient descent, but trust me, all the python packages that implement SVMs, as long as you know how SVMs work, with all their parameters, sub-gradient descent is implemented automatically in these packages. In the next post, we\u2019ll dive deep into random forest and decision trees and solve a Kaggle dataset using them.", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Software Development Engineer at American Express with a keen interest in the field of Data Science and Web3. linkedin.com/in/vardaan-bajaj-23a279124/"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F57d7c885652a&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----57d7c885652a--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----57d7c885652a--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@vardaanbajaj?source=post_page-----57d7c885652a--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@vardaanbajaj?source=post_page-----57d7c885652a--------------------------------", "anchor_text": "Vardaan Bajaj"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F168771086803&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&user=Vardaan+Bajaj&userId=168771086803&source=post_page-168771086803----57d7c885652a---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F57d7c885652a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F57d7c885652a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://medium.com/analytics-vidhya/contents-9b2e49f49fe9", "anchor_text": "previous"}, {"url": "https://en.wikipedia.org/wiki/Support_vector_machine#/media/File:SVM_margin.png", "anchor_text": "Source"}, {"url": "https://en.wikipedia.org/wiki/Kernel_method", "anchor_text": "kernel methods"}, {"url": "https://data-flair.training/blogs/svm-kernel-functions/", "anchor_text": "different types of kernel methods"}, {"url": "https://web.stanford.edu/class/ee392o/subgrad_method.pdf", "anchor_text": "this"}, {"url": "https://www.coursera.org/learn/machine-learning", "anchor_text": "machine learning course"}, {"url": "https://www.kaggle.com/mlg-ulb/creditcardfraud", "anchor_text": "here"}, {"url": "https://www.kaggle.com/vardaanbajaj/credit-card-fraud-svm?scriptVersionId=38180580", "anchor_text": "here"}, {"url": "https://medium.com/analytics-vidhya/machine-learning-v-decision-trees-random-forest-kaggle-dataset-with-random-forest-3ebfe6d584be", "anchor_text": "next"}, {"url": "https://medium.com/tag/machine-learning?source=post_page-----57d7c885652a---------------machine_learning-----------------", "anchor_text": "Machine Learning"}, {"url": "https://medium.com/tag/data-science?source=post_page-----57d7c885652a---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/support-vector-machine?source=post_page-----57d7c885652a---------------support_vector_machine-----------------", "anchor_text": "Support Vector Machine"}, {"url": "https://medium.com/tag/kernel?source=post_page-----57d7c885652a---------------kernel-----------------", "anchor_text": "Kernel"}, {"url": "https://medium.com/tag/kaggle?source=post_page-----57d7c885652a---------------kaggle-----------------", "anchor_text": "Kaggle"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F57d7c885652a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&user=Vardaan+Bajaj&userId=168771086803&source=-----57d7c885652a---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F57d7c885652a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&user=Vardaan+Bajaj&userId=168771086803&source=-----57d7c885652a---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F57d7c885652a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----57d7c885652a--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F57d7c885652a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----57d7c885652a---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----57d7c885652a--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----57d7c885652a--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----57d7c885652a--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----57d7c885652a--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----57d7c885652a--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----57d7c885652a--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----57d7c885652a--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----57d7c885652a--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@vardaanbajaj?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@vardaanbajaj?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Vardaan Bajaj"}, {"url": "https://medium.com/@vardaanbajaj/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "84 Followers"}, {"url": "http://linkedin.com/in/vardaan-bajaj-23a279124/", "anchor_text": "linkedin.com/in/vardaan-bajaj-23a279124/"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F168771086803&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&user=Vardaan+Bajaj&userId=168771086803&source=post_page-168771086803--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F342b25109362&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmachine-learning-iv-support-vector-machines-kaggle-dataset-with-svms-57d7c885652a&newsletterV3=168771086803&newsletterV3Id=342b25109362&user=Vardaan+Bajaj&userId=168771086803&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}