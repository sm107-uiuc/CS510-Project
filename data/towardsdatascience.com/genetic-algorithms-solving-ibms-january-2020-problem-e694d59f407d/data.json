{"url": "https://towardsdatascience.com/genetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d", "time": 1683003970.093197, "path": "towardsdatascience.com/genetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d/", "webpage": {"metadata": {"title": "Genetic Algorithms \u2014 Solving IBM\u2019s January 2020 problem | by Patrik Holopainen | Towards Data Science", "h1": "Genetic Algorithms \u2014 Solving IBM\u2019s January 2020 problem", "description": "Solving IBM's January 2020 problem using a Genetic Algorithm."}, "outgoing_paragraph_urls": [{"url": "https://gitlab.com/oncerecursive/ibm-ponder-this-jan2020/-/blob/master/january20.ipynb", "anchor_text": "this notebook", "paragraph_index": 0}, {"url": "http://www.research.ibm.com/haifa/ponderthis/challenges/January2020.html", "anchor_text": "January 2020 challenge", "paragraph_index": 1}, {"url": "https://www.youtube.com/watch?v=YX40hbAHx3s", "anchor_text": "watch this", "paragraph_index": 7}, {"url": "https://www.youtube.com/watch?v=kHyNqSnzP8Y", "anchor_text": "Patrick Winston opening a lecture on genetic algorithms", "paragraph_index": 25}, {"url": "https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)#Single-point_crossover", "anchor_text": "single-point crossover", "paragraph_index": 26}, {"url": "https://medium.com/@becmjo/genetic-algorithms-and-the-travelling-salesman-problem-d10d1daf96a1", "anchor_text": "Travelling Salesman Problem", "paragraph_index": 50}], "all_paragraphs": ["This post serves as a gentle introduction to GAs as well as a solution to IBMs January 2020 problem. In case you want to create your own GAs or feel like playing around with my code while/after reading this, feel free to grab this notebook with all of the code. Enjoy!", "Every month IBM publishes a programming-related challenge in their Ponder This blog. Usually, the challenges are related to programming, but occasionally pen-and-paper solutions are viable. The previous one was the January 2020 challenge, and here\u2019s the problem statement:", "\u201c A gardener has 12 barrels of special fluid to water his orchids; exactly two of the barrels are poisonous. Using any amount, even a single drop, from a poisonous barrel will kill the precious orchid in 24 hours. The gardener has only three days before the orchids die unless he can figure out which ten barrels are the good ones. He is willing to sacrifice four orchids by watering them using a mix from a subset of these barrels. How can he find the poisonous barrels?\u201d", "Let\u2019s take a moment to ponder what the problem is. Essentially we have a table of orchid watering slots, like in the table above. Each slot includes a set of letters, each representing one barrel. Our task is to come up with a similar table, where there are 4 orchids (rows), 3 days (columns) and a total of 12 barrels labeled from A to L. We want such a solution, that no matter which two barrels are poisoned, we can always figure it out just by looking at which orchids died on which day. As en example, let\u2019s consider that in the setting above with only 8 barrels, A and B were poisoned.", "Turns out, that no matter which other combination of barrels you choose as poisoned, you will not get that same outcome (of how the orchids die). In fact, each poisoned pair of barrels has a unique outcome, and this is essentially the perfect solution we are after.", "On a first look, there are 12 different slots and 12 barrels, so finding a good configuration would seem straightforward, but the hardness comes from the fact if an orchid dies on the first day, the remaining two days of watering it would provide zero additional information. The reason the above solution does not work is that it would be impossible to distinguish e.g. poison-pair A&B from A&C because either way, only the first orchid would die on the first day, and rest survive! And as can be seen in the first picture, the solution for 8 barrels on 2 days does not include using the same barrel on the same orchid on multiple days.", "Okay, so we could guess that a good solution has around 2\u20133 barrels per slot. Can\u2019t we just try out different combinations and see what works? Well, no.", "Consider that we have the 12 different slots, and for simplicity let\u2019s assume that during each slot we would use exactly 3 distinct barrels to water the orchid. The number of possible combinations would be (12*11*10)\u00b9\u00b2, which is approximately equal to 2.8*1\u2070\u00b3\u2077, so brute-forcing all combinations is out the window. However, this problem is in the NP (Not sure what that means? \u2192 watch this). Even though the search space grows exponentially, it only requires relatively little effort to check whether a solution is good.", "There are only 66 possible pairs for poisonous barrels (|{AB, AC, AD\u2026 LL}| = 12 choose 2 = 66). Given a configuration (e.g. the table above) and going through all 66 poisoned barrel combinations, we can determine whether a solution is good or not, by simply checking are there any identical outcomes. Why does this work? Because as stated above, for a solution to be perfect, the gardener has to be able to figure out the poisonous barrels exactly, but by only looking at what happened to the poor orchids. So, if we are given a configuration of watering the orchids, if we find duplicate outcomes, it is not the final solution.", "One simple way to quantize the outcomes of orchids is to denote each of their fate with a number from 0\u20133, which says on which day the orchid died (indexing from 0). So for Table 1 with the eight barrels, if A and B are poisoned, the outcome would be (0, 1, 0, 3). Here 3 is just to denote that the orchid survived. We use Day 1\u2192 0 because zero-indexing makes the programming simpler. So the outcome (0, 1, 0, 3) can be read as \u201con first day orchids 1 and 3 died, on the second day orchid 2 and orchid 4 survived\u201d.", "Now our task has formed into finding a configuration of barrels (like in the tables before) so that for the 66 poison-barrel pairs all of the outcomes (that we denote as 4 numbers from 0\u20133) are unique. Because we are happy with a single solution (and not computing all of them), we can utilize GAs.", "As a subclass of evolutionary algorithms, a genetic algorithm (GA) is a metaheuristic that uses elements of evolutionary processes to solve search and optimization problems. Quite a mouthful, but essentially what it comes down to is that instead of iteratively improving one solution, you take a large number of possible solutions and combine them with each other.", "This is essentially where all the power of GAs comes from. Imagine that you are given a random configuration of the barrels, and you determine that it is not the final solution. Which barrels should you move/remove/add? Are you getting closer? How far away are you from the final solution?", "Turns out these are really hard questions to ask, and because this is not a convex or differentiable problem, a lot of good methods are not viable. And this is the crazy part of GAs: you do not need exact estimations of how far away you are from the solution \u2014 just a way to compare solutions. Add a bunch randomness and plenty iterations and there we go!", "It might not come as a surprise that GENETIC Algorithms are heavily inspired by evolution theory and that they use a lot of the same terminology, but let\u2019s take a more detailed look into two fundamental components of a GA:", "A set of candidate solutions is called the population. In our case, one member of the population would be one configuration of barrels for the three days. The population is initialized randomly, and further generations are updated and improved versions of the initial population. So just like in evolution, old units get removed by new, possibly better ones. And how do test which solutions are better than others?", "The fitness function gives each candidate a score. This score serves two purposes.", "Fitness is the thing you want to minimize/maximize (for the ML folks, you can think of it as a loss function).", "But in our problem, what is a good way of measuring how good a solution is? Our problem is discreet, and it would require some serious problem engineering to figure out the underlying principles about what kind of structures of answers would give a good result.", "One approach is to take the end condition and elaborate on it. Our end condition is when we find a way of watering the orchids, so that no matter which pair of barrels are actually poisonous, the gardener can always figure out precisely which two barrels they were. A solution is not valid if there are combinations of poisoned barrels that would yield exactly the same outcome (remember the 4-number denotation). Now let\u2019s think about the opposite, if we would have the worst solution, we would not use any barrels. That would give the gardener zero information because all of the poison-barrel combinations would yield to duplicates! So maybe there\u2019s a possible way to measure how good an answer is to simply count how many duplicates there are!", "The magic thing about GAs is that our measurement does not have to be entirely accurate. It suffices that it is a ballpark estimate of where we want to land, and we can let the random processes take care of the rest.", "So, for our purposes, we can go with a fitness function that calculates for a given configuration of barrels", "If there are any duplicate outcomes (which we want to penalize), the fitness score is higher, and with \u201cbetter\u201d solutions the score is lower. The score for the optimal solution is 0 because then there are exactly 66 unique outcomes. Our goal now is to simply minimize this fitness of members of our population. But how can we minimize it?", "The first step is evaluating the population. This is where we rank the solutions based on how good they are. In our setting that is based on the amount of duplicates. Candidate solutions are ranked higher if they have less duplicates, with the best always being the valid solution where there are no duplicates.", "After we have evaluated and ordered the population, (natural) selection occurs. There are plenty of fun ways of doing this, but the key idea is getting rid of bad solutions so that there is room for better ones.", "Now, I realize that most MIT students have a basic grasp of sexual reproduction, but I\u2019ve found in talking with students that many times they\u2019re a little fuzzy on the details. So let\u2019s start off by reflecting a little bit on how that works. \u2014 Patrick Winston opening a lecture on genetic algorithms", "Crossover has many forms, but the underlying idea in GAs is that good solutions can be combined with each other in order to make possibly even better solutions. In our case, we can use one of the simplest crossover methods, namely the single-point crossover.", "The single-point crossover works as the following:", "For our case the split location (or pivot point) is a random slot. In the pictures below is the single-point crossover done for two arbitrary parents at a random slot (Orchid 3 | Day2)", "With crossover, it is possible to include elitism, which means whether the parents are kept after the crossover. If the parents are kept, we cannot create as many children, because otherwise, the population size would grow each iteration, and this might lead to some instabilities. Generally, elitism stabilizes the algorithm as good solutions stay longer. If we do crossover without elitism, it means we can create more offspring, but we might lose potentially already viable solutions by doing too random crossing.", "One problem with crossover is that it is essentially just combining old solutions around. By itself, this does not guarantee that a good solution will be found, and if combining two good solutions does not make up a better solution, we might be stuck in a local minimum. So how do we escape dead ends and come up with even more novel solutions?", "Remember that when in life you don\u2019t know what to do, always choose randomly. Save the trouble with the same expected return. \u2014 Combinatorics teacher, 2019", "Same is true here. A counterpart to crossover, mutation is purely random change. A random factor that changes individual members of the population arbitrarily serves an important purpose, as we do not know whether we are actually closing in on the actual best solution, or whether we are stuck in a locally decent solution. On a more abstract level, if a population evolves by only using the same pool of candidates, it is likely to become extremely homogeneous and possibly miss out on better solutions.", "With our orchid garden, mutation is going to be randomly adding and removing barrels from a certain configuration. Usually, mutation plays a smaller role and is used to escape dead ends, so the mutation rate (i.e. probability that a candidate solution is mutated) is small.", "Too much mutation turns the GA to a random guessing machine and too little causes it to miss out on potentially very good solutions. Use with caution.", "Summarizing what we have learned so far and put into an algorithmic frame,", "2. Second, repeat the following steps until a valid solution is found.", "Every iteration of the loop, the new population is called a generation, for obvious reasons. The order in which these operations are done can vary with different GAs, but that\u2019s it with theory, now to Python!", "Now we can start implementing the actual algorithm. In the code below we start with importing combinations-method and the random-package. ALPHABET is a list that contains all possible barrels, labeled from A to L, and test_answer shows the structure that each individual answer should have, that is again, a 4x3 list where each element is also a list of barrels, namely the slot.", "For example in the code below, the slot [\u201cD\u201d, \u201cK\u201d] is the element of the first row and second column, so it means that Orchid 1 was watered during Day 2 with barrels D and K.", "init_population creates the first generation, that is a population filled with those 4x3 lists, in which each slot (element) is filled with 3 random barrels.", "Next up we define the fitness function, the is called for each candidate solution. As a recap, we want it to", "Evaluation is pretty straightforward, just return the population sorted by fitness.", "Selection returns the better half of the population (so that there\u2019s room for more good candidates)", "Next up is the sex part i.e. the crossover. Note that crossover returns a new population that is double the size of the input! So we assume that selection has been done beforehand.", "And the last component, mutation. For each candidate, it chooses whether to mutate or not, depending on p_mutate. If it does mutate, it flips a coin whether a barrel is added or removed. Additionally, it is assumed that it doesn\u2019t make sense to add barrels of the same kind and to remove barrels if there are only one or less. Returns a (probably slightly) mutated population.", "And there we go! Now we simply have to create the training loop. I chose a mutation rate of 0.9, because even though mutation would occur, it affects a solution very little, so it does not really hurt to have more of that going around. Also, I just ballparked a population size of 1000, but it works as well with 10, 1000 or 10 000. Elitism seemed to speed things up so that\u2019s enabled, but again you might wanna try yourself the difference!", "Which prints out something like this (takes around 1\u20135min on a regular laptop)", "And there we have it, a solution! For the actual challenge, I reused a bit of code from the fitness function to verify that it was actually a correct solution but assuming that everything went well this one should be viable. But what did we learn?", "Interestingly we can see from the iterations that it takes exponentially more time to compute the last few steps (I ran this a few times and got similar patterns), which would imply that getting from 1 or 2 fitness to 0 is a much harder process than getting from 14 to 2. It is possible that around the fitness=1 there is a local minimum, where the crossover starts to create way too similar results and important diversity is lost. It is possible that this final step is achieved by pure random luck, as we don\u2019t know how many possible correct solutions are out there. However, the mutation rate was already cranked up pretty high, so changing it to 1 would not be such a dramatic difference, and maybe in order to get more stable and faster results, the mutation could do more than change one slot at a time (maybe change several during one mutation?).", "GAs are useful when you are dealing with a search or optimization problem, and more traditional methods aren\u2019t feasible (e.g. gradient descent or reducing the problem), yet the search space is too large to brute-force. Essentially, GAs are just a more elaborate way of educated guessing, but they do it in an elegant way by utilizing probability and computational power. They have the power to tackle some really wicked problems (like the Travelling Salesman Problem). However, the problems need to be in NP as checking the goodness of a solution (i.e. calculating fitness) can\u2019t be computationally too expensive. So applying GAs fits a nich\u00e9 of complex problems, where other methods are not suitable (One way to think about it is that if nothing else really works, you might wanna give GAs a go). In general, I\u2019d suggest using GAs as a last resort, e.g. when there is no domain-specific knowledge or the problem can\u2019t be mapped to e.g. a simpler graph problem (which would have its own, possibly faster approaches).", "Some good properties are that GAs are straightforward to create, and (as shown above) can be done using vanilla Python. Also, one does not need to have an in-depth understanding of the problem to get to a solution, sometimes a ballpark heuristic is all that matters! That is why I personally like GAs, they provide a nice middle-ground where a relatively simple program can overcome a complex problem, with a method that is inherently intuitive (after all, what would be more natural to understand than evolution).", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "MSc Complex Systems at Aalto University (finishing up thesis). Love AI & People."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fe694d59f407d&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----e694d59f407d--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----e694d59f407d--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@oncerecursive?source=post_page-----e694d59f407d--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@oncerecursive?source=post_page-----e694d59f407d--------------------------------", "anchor_text": "Patrik Holopainen"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F9d5070a1b34b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&user=Patrik+Holopainen&userId=9d5070a1b34b&source=post_page-9d5070a1b34b----e694d59f407d---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe694d59f407d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe694d59f407d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://unsplash.com/@timmossholder?utm_source=medium&utm_medium=referral", "anchor_text": "Tim Mossholder"}, {"url": "https://unsplash.com?utm_source=medium&utm_medium=referral", "anchor_text": "Unsplash"}, {"url": "https://gitlab.com/oncerecursive/ibm-ponder-this-jan2020/-/blob/master/january20.ipynb", "anchor_text": "this notebook"}, {"url": "http://www.research.ibm.com/haifa/ponderthis/challenges/January2020.html", "anchor_text": "January 2020 challenge"}, {"url": "https://www.youtube.com/watch?v=YX40hbAHx3s", "anchor_text": "watch this"}, {"url": "https://www.youtube.com/watch?v=kHyNqSnzP8Y", "anchor_text": "Patrick Winston opening a lecture on genetic algorithms"}, {"url": "https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)#Single-point_crossover", "anchor_text": "single-point crossover"}, {"url": "https://medium.com/@becmjo/genetic-algorithms-and-the-travelling-salesman-problem-d10d1daf96a1", "anchor_text": "Travelling Salesman Problem"}, {"url": "https://medium.com/tag/genetic-algorithm?source=post_page-----e694d59f407d---------------genetic_algorithm-----------------", "anchor_text": "Genetic Algorithm"}, {"url": "https://medium.com/tag/python?source=post_page-----e694d59f407d---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/coding-challenge?source=post_page-----e694d59f407d---------------coding_challenge-----------------", "anchor_text": "Coding Challenge"}, {"url": "https://medium.com/tag/programming?source=post_page-----e694d59f407d---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/tag/evolution?source=post_page-----e694d59f407d---------------evolution-----------------", "anchor_text": "Evolution"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe694d59f407d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&user=Patrik+Holopainen&userId=9d5070a1b34b&source=-----e694d59f407d---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe694d59f407d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&user=Patrik+Holopainen&userId=9d5070a1b34b&source=-----e694d59f407d---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe694d59f407d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----e694d59f407d--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2Fe694d59f407d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----e694d59f407d---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----e694d59f407d--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----e694d59f407d--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----e694d59f407d--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----e694d59f407d--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----e694d59f407d--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----e694d59f407d--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----e694d59f407d--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----e694d59f407d--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@oncerecursive?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@oncerecursive?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Patrik Holopainen"}, {"url": "https://medium.com/@oncerecursive/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "12 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F9d5070a1b34b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&user=Patrik+Holopainen&userId=9d5070a1b34b&source=post_page-9d5070a1b34b--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fusers%2F9d5070a1b34b%2Flazily-enable-writer-subscription&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fgenetic-algorithms-solving-ibms-january-2020-problem-e694d59f407d&user=Patrik+Holopainen&userId=9d5070a1b34b&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}