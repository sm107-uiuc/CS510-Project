{"url": "https://towardsdatascience.com/timing-and-numpy-611b93338cc3", "time": 1683004710.169909, "path": "towardsdatascience.com/timing-and-numpy-611b93338cc3/", "webpage": {"metadata": {"title": "Timing and NumPy. An Example of how to time code in\u2026 | by Edward Krueger | Towards Data Science", "h1": "Timing and NumPy", "description": "By: Edward Krueger Data Scientist and Instructor and Douglas Franklin Teaching Assistant and Technical Writer. In this article, with dot product calculations as our model for bench-marking run-time\u2026"}, "outgoing_paragraph_urls": [{"url": "https://www.linkedin.com/in/edkrueger/", "anchor_text": "Edward Krueger", "paragraph_index": 0}, {"url": "https://www.linkedin.com/in/douglas-franklin-1a3a2aa3/", "anchor_text": "Douglas Franklin", "paragraph_index": 0}], "all_paragraphs": ["By: Edward Krueger Data Scientist and Instructor and Douglas Franklin Teaching Assistant and Technical Writer.", "In this article, with dot product calculations as our model for bench-marking run-time, we\u2019ll visualize a few methods of generating dot products to see which method is quickest. Additionally, we\u2019ll cover a few ways of timing lines of code and ipython cells.", "Programmers judge code quality by readability, modularity, and run-time. This article focuses on run-time and timing methods in Python and Jupyter. Run time may drastically increase as a function processes more data. All things being equal, a faster function is a better function. In this article, with dot product calculations as our model for bench-marking run-time, we\u2019ll visualize a few methods of generating dot products to see which method is quickest. A dot product is a result of multiplying two or more vectors. Vectors are fundamental to most scientific algorithms and are the underpinning of machine learning and gradient descent. Thus, for data scientists, machine learning researchers, and even new coders looking for tips, these methods may offer insight.", "We\u2019ll show three distinct methods to time code in Jupyter notebook. The outputs of our timing methods are sometimes broken into the subcategories \u201cwall time\u201d and \u201cCPU time.\u201d Wall time is the familiar concept of time, like time from a clock on the wall or a stopwatch. Wall time records from the beginning of a process to its end. CPU time is the total execution time or run-time for which the CPU is dedicated to a process. CPU time will be a fraction of wall time. This is because other operations that don\u2019t involve the CPU directly are included in wall time. We\u2019ll focus on wall time as it provides direct and intuitive time taken.", "Before we can begin timing, we need code to time and arrays to pass as arguments. To create the arrays for timing our function, we use NumPy to generate two random vectors of size 1,000 as NumPy arrays", "Now we\u2019ll cover the three methods of timing within Jupyter Notebook; Jupyter\u2019s built-in time \u2018magic\u2019 and timeit \u2018magic\u2019 methods and an external package called timeit.", "Magics are specific to and provided by the Ipython, or Jupyter, kernel. An advantage of magics is that you don\u2019t have to import a package. To work correctly, Magics use a syntax element that is not valid in the underlying language. For example, the Jupyter kernel uses the `%` syntax element for Magics as `%` is not a valid unary operator in Python. However, `%` might have meaning in other languages.", "1) Jupyter\u2019s built-in magic timeJupyter\u2019s built-in time magic returns the time of a single execution of a cell or line. Time magic can be applied to a line by inserting \u201c%time\u201d on the line of code to be timed. Time magic can also be applied to a cell by placing %%time at the beginning of the cell. This \u201c%%\u201d tells Jupyter to use the magic to time the whole cell.", "2) Jupyter\u2019s built-in magic timeitJupyter\u2019s built-in timeit magic returns the average of multiple executions of the same cell or line. When timing a single execution of each cell or line, results are likely to vary. This variance can be caused by computer processes running in the background. Thus, using timeit will yield a more informative result by returning an average and standard deviation for a set number of executions. This method can also be used as cell or line magic, but for our comparison, we\u2019ll only implement it as line magic.", "The timeit package can also time multiple executions of a function. This package creates an environment to time a function. This environment turns off garbage collection and caching by default. Garbage collection is the automatic process of freeing up space in a computer\u2019s memory by removing data that is no longer required or in use. Caching is done by hardware or software that is used to store data temporarily in a computing environment. The advantage of this approach is that it makes independent timings more comparable. The disadvantage is that garbage collection and or caching may be an essential component of the performance of the function being measured.", "To use timeit, we need to create a function with no arguments. A simple way to accomplish this is by passing a lambda function, with no arguments, as an argument to time it.", "The three timing methods above converge to the same result. The loop-based function on NumPy arrays is the slowest, the looped-based function on lists is second, while NumPy\u2019s function is by far the fastest.", "A More Thorough Approach with timeitAn alternative is to write a timer function that takes in the function to be timed and its arguments. It then defines an equivalent (lambda) function with no arguments and times it.", "From this, we get roughly the same results as using timeit directly.", "Now, we may want to see how the times change as the length of the vector grows. I build a function to time the different dot product functions at different lengths. Timing the function multiple times using the same vector might produce an inaccurate result, because the dot product may be faster to compute for some vectors. I will repeat different vectors to ensure a fair test.", "To visualize the behavior of these functions, we\u2019ll graph them using Matplotlib. To do this, we time each of the dot product functions for vectors of lengths 1 to 1,000,000. For a slower computer, a lower order of magnitude should be chosen. With a faster computer, it might be interesting to see how the functions perform on much longer vectors.", "Increase in run-time as the length of the vectors increase is almost perfectly linear. This linearity matches the theory: assuming arithmetic operations are of constant time complexity, the dot product operation is of linear time complexity, or O(n). The loop-based dot product is slower on NumPy arrays because the loop function must convert the NumPy array into a python list data type. This conversion means more time is needed to iterate over a NumPy array than a list. The NumPy function may look like it never increases in execution time. However, if we zoom in, we can see similar behavior to the other time complexities; O(n).", "In conclusion, one should use NumPy for dot product computation. This is true for other vector operations as well. However, if one must write a loop, it is more efficient to use lists than NumPy arrays as input. All of our timing methods returned similar results, albeit in different formats. Despite the NumPy dot product having the shortest run time by far according to our results, we can say that all the tests have the same asymptotic complexity or order; O(n). In actual cases, the run time of an algorithm depends on the number of operations it must complete. Remember, all things being the same faster functions are better functions. We ought to keep this in mind when writing code to run on large datasets or writing code with modularity in mind. Vectors are crucial to machine learning applications. So with any machine learning computations, NumPy arrays are the way to go. Faster means less computational resources, time, and energy. In computation, faster solutions are better solutions!", "I hope this was informative and thought-provoking! Feel free to explore the Jupyter notebook linked in the header and try some of the timing out for yourself. Is your computer faster than mine?", "My computer | Component | Specification |", "Your home for data science. A Medium publication sharing concepts, ideas and codes.", "Data Scientist, Software Developer and Educator"], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F611b93338cc3&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----611b93338cc3--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----611b93338cc3--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.edkruegerdata.com/?source=post_page-----611b93338cc3--------------------------------", "anchor_text": ""}, {"url": "https://medium.edkruegerdata.com/?source=post_page-----611b93338cc3--------------------------------", "anchor_text": "Edward Krueger"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4889b755e348&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&user=Edward+Krueger&userId=4889b755e348&source=post_page-4889b755e348----611b93338cc3---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F611b93338cc3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F611b93338cc3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://www.linkedin.com/in/edkrueger/", "anchor_text": "Edward Krueger"}, {"url": "https://www.linkedin.com/in/douglas-franklin-1a3a2aa3/", "anchor_text": "Douglas Franklin"}, {"url": "https://github.com/edkrueger/dot-product-timing/blob/master/dot_product_timing.ipynb", "anchor_text": "https://github.com/edkrueger/dot-product-timing"}, {"url": "https://medium.com/tag/data-science?source=post_page-----611b93338cc3---------------data_science-----------------", "anchor_text": "Data Science"}, {"url": "https://medium.com/tag/timing?source=post_page-----611b93338cc3---------------timing-----------------", "anchor_text": "Timing"}, {"url": "https://medium.com/tag/asymptotic-notation?source=post_page-----611b93338cc3---------------asymptotic_notation-----------------", "anchor_text": "Asymptotic Notation"}, {"url": "https://medium.com/tag/python?source=post_page-----611b93338cc3---------------python-----------------", "anchor_text": "Python"}, {"url": "https://medium.com/tag/jupyter?source=post_page-----611b93338cc3---------------jupyter-----------------", "anchor_text": "Jupyter"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F611b93338cc3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&user=Edward+Krueger&userId=4889b755e348&source=-----611b93338cc3---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F611b93338cc3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&user=Edward+Krueger&userId=4889b755e348&source=-----611b93338cc3---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F611b93338cc3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----611b93338cc3--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F611b93338cc3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----611b93338cc3---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----611b93338cc3--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----611b93338cc3--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----611b93338cc3--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----611b93338cc3--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----611b93338cc3--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----611b93338cc3--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----611b93338cc3--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----611b93338cc3--------------------------------", "anchor_text": ""}, {"url": "https://medium.edkruegerdata.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.edkruegerdata.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Edward Krueger"}, {"url": "https://medium.edkruegerdata.com/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "699 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4889b755e348&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&user=Edward+Krueger&userId=4889b755e348&source=post_page-4889b755e348--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F1f629c0dbfb9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Ftiming-and-numpy-611b93338cc3&newsletterV3=4889b755e348&newsletterV3Id=1f629c0dbfb9&user=Edward+Krueger&userId=4889b755e348&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}