{"url": "https://towardsdatascience.com/a-crash-course-on-proving-the-halting-problem-3579fdcd114", "time": 1682994714.2941499, "path": "towardsdatascience.com/a-crash-course-on-proving-the-halting-problem-3579fdcd114/", "webpage": {"metadata": {"title": "A Crash course on proving the Halting Problem | by Haihan Lan | Towards Data Science", "h1": "A Crash course on proving the Halting Problem", "description": "Suppose Jeff Bezos announced over twitter: \u201cI will offer $1 Billion to the person who can write a program that can test any and all other conceivable programs to see if on some input, they produce\u2026"}, "outgoing_paragraph_urls": [{"url": "https://en.wikipedia.org/wiki/Largest_known_prime_number", "anchor_text": "2^82589933 \u2212 1", "paragraph_index": 11}, {"url": "https://en.wikipedia.org/wiki/NaN", "anchor_text": "NaN", "paragraph_index": 17}, {"url": "https://en.wikipedia.org/wiki/Countable_set", "anchor_text": "is the same as the size of some subset of natural numbers N", "paragraph_index": 17}, {"url": "https://en.wikipedia.org/wiki/Turing_completeness", "anchor_text": "equivalent in the Turing sense", "paragraph_index": 20}, {"url": "https://en.wikipedia.org/wiki/Russell%27s_paradox", "anchor_text": "Russell\u2019s paradox", "paragraph_index": 25}, {"url": "https://en.wikipedia.org/wiki/Universal_set", "anchor_text": "discarded from the axioms of standard set theory", "paragraph_index": 25}, {"url": "https://en.wikipedia.org/wiki/Proof_by_contradiction", "anchor_text": "proof-by-contradiction", "paragraph_index": 27}, {"url": "https://en.wikipedia.org/wiki/Universal_approximation_theorem", "anchor_text": "somewhat like in machine learning", "paragraph_index": 27}, {"url": "https://en.wikipedia.org/wiki/Consistency", "anchor_text": "consistency", "paragraph_index": 37}], "all_paragraphs": ["During a lesson, the Master explained the \u201cI\u201d:", "\u201cThe I is the voice of the circumference\u201d he said", "When asked by a student to explain what he meant; The master said \u201cIt is a voice inside your head\u201d", "\u201cI don\u2019t have a voice inside my head\u201d thought the student, and he raised his hand to tell the master", "The master stopped the student, and said \u201cthe voice that just said you have no voice in your head; is the I\u201d", "And then the students were enlightened.", "Suppose Jeff Bezos announced over twitter: \u201cI will offer $1 Billion to the person who can write a program that can test any and all other conceivable programs to see if on some input, they produce the correct output after a finite time or continue running forever.\u201d", "You immediately start clacking away in your dark-themed IDE, and proceed swiftly to write the Python class structure for the project. But in the back of your mind you feel a certain sense of foreboding, as if some esoteric knowledge from the aether is quietly warning you of the impending futility.", "As it turns out, in general it is impossible to write a program or algorithm to determine if any arbitrary program or algorithm (including itself) halts on some arbitrary input or continues running forever. More so, it is even more impossible to determine if said programs will halt or run forever on all possible inputs. In this article we will talk about the former fact.", "For the sake of discussion, let\u2019s assume that our algorithms are perfect and will always produce the correct result in addition to halting. We can think of a general algorithm (informally) as behaving similarly to a giant lookup table (a function) that maps some input x to it\u2019s corresponding output y = f(x), and does this predictably 100% of the time. However, unlike a lookup table, the algorithm can consist of decision statements (if, else), loops and recursion in the classic programming sense, so that it is a \u2018dynamic\u2019 process with start and end states, that computes some output y on inputs x or continues running forever. The above problem is known as the halting problem and was famously proved by Alan Turing in 1936 to be uncomputable by the the formal definition of algorithms that he invented and its associated computational model, now popularly called the Turing machine. Indeed, not all functions are computable so our algorithms are distinct from lookup table functions even though the above analogy is useful.", "To get an appreciation of why this is the case, put on your thinking caps and we\u2019ll discuss some of the ideas behind compatibility and the halting problem in an informally rigorous way. In fact we need not even define formally what an algorithm is nor a computational model such as a Turing machine. We will only make simple arguments about general computability.", "Lets begin with some definitions. For now all our inputs we feed to our algorithms or programs are subsets of the natural numbers N, so our inputs consist of single whole numbers such as 2, 3, 12, 23 or 2^82589933 \u2212 1, and combinations thereof (in the sense of passing multiple arguments x, y, z to f(x, y, z)). The idea is all that the unique inputs we care to feed into our algorithm or function can be encoded by natural numbers.", "Definition 1: A function p(x) = y with x, y \u2208 N is called partially computable (p.c.) if there is an algorithm that halts when y is defined but does not halt (diverges) when y is undefined. This algorithm computes the values of y or some related value. Intuitively a partial function p is a function that does not require p to map every element x of the domain X to an element of y of the co-domain Y.", "An example of a partial computable function would be non-negative integer division with remainder. It is defined in the following with a, b \u2208 Z+:", "In the above, the entity \u03c6 is the actual algorithm or procedure used to compute the result of integer division with remainder, which is the function p. We can easily recall from elementary school that the rules of division with remainder are well defined and work for all non-negative integers a and b except when b is 0. Regular non-negative integer division without remainder is also a partial function.", "Definition 2: A function f is total computable or simply computable if it is defined on its entire domain of inputs subset of N, and there exist algorithms which halt on the domain of f.", "We can make general integer division (without remainder) computable with a few tricks:", "Noticed that we put a NaN as the output if b is 0 and we upgraded our algorithm \u03a6 to handle negative integers as well. Technically* our function is defined for the entire domain of a, b \u2208 Z, which, by the work of famous mathematician Georg Cantor has a size that is the same as the size of some subset of natural numbers N, or is countably infinite.", "*On the subject of technicalities, it is the bread and butter of proof methods in math and first order logic, since a lot of definitions in math are fairly precise, so best just to accept it. The proofs later on will rely directly on technicalities of the definitions that we ourselves created.", "Definition 3: For a certain algorithm \u03c6\u2096 a set (of inputs) is called computably enumerable (c.e., the term recursively enumerable is also popular) if it is in the domain of a p.c. function p = \u03c6\u2096. That is, a set X is c.e. in \u03c6\u2096 if all elements x cause \u03c6\u2096 to halt or cause \u03c6\u2096 to diverge but not both.", "The quality of computably enumerable is attributed to specific sets and specific algorithms. Therefore we can say that the set of integers Z is c.e. by the integer division with remainder algorithm, since there are values in Z that cause the division with remainder algorithm to give a undefined output (such as 0 and negative numbers). As well, \u03c6\u2096 are unique to a certain model of computation, but all models of deterministic computation with the right features but that differ only slightly from each other are equivalent in the Turing sense. So we can say \u03c6\u2096 is the kth algorithm in the set of all possible algorithms in a computational model T.", "Definition 4: A subset of N called X is computable or recursive if it has a computable characteristic function or indicator function:", "So the indicator function must halt and given a true or false result on the entire domain N.", "Now that we have built our playground, it\u2019s time to have some fun. Before going into the proof of why the halting problem is not computable, let\u2019s warm up with the following question:", "In a town where the barber shaves only the men who do not shave themselves, who shaves the barber? Wives, bachelorettes, mothers, children and out-of-towners do not get to shave anyone in this town.", "If the barber does not shave himself, then he must shave himself and conversely if the barber shaves himself then he cannot by definition! This is an applied version of Russell\u2019s paradox which asks whether the set of all sets not containing themselves exists. Russell\u2019s paradox is a direct consequence of the naive notion of trying to find \u2018the set of all sets\u2019 before such concept was discarded from the axioms of standard set theory. Another interesting logical contradiction is the famous Catch-22:", "Applying for a job requires work experience, but to obtain work experience one requires a job.", "It turns out we can use these contradictions to show the opposite of some premise (a logical hypothesis) or compound premise must be true, i.e. if the premises we have logically deduce to a contradiction, the negation of the original premise must be true. The is the famous proof-by-contradiction technique. For example, the existence of Russell\u2019s paradox implies that a set of all sets cannot exist. Note that many important theorems in computability theory, somewhat like in machine learning, are non-constructive. In other words the theorem may postulate the existence of some certain thing, or rule out the existence of others, but not actually provide an example of the thing, so the proof may be unintuitive and down right weird, but that\u2019s how computability works.", "The setup of the halting problem is as such that it leads to a contradiction; let\u2019s define a halting set H as a set of all programs or algorithms that halt on some arbitrary inputs. The proof would not be as profound if we only argued about certain subsets of H. Intuitively this is an acceptable \u2014 albeit naive as we\u2019ll soon see \u2014 definition. Recall in our computational model T all k indexed algorithms are unique.", "Definition 5: H := { (k, x) such that an algorithm or program \u03c6\u2096 halts when run on input x }", "Theorem 1: H is not computable.", "Assume H is (total) computable, then it must have a computable indicator function I(k, x) by Def. 4. This indicator outputs a 1 if a program in H halts and a 0 if otherwise:", "Suppose we make a program \u03c6\u2098 in the following way:", "A pseudo-code for the function \u03c6\u2098 would look like the following:", "\u03c6\u2098 is in H (since \u03c6\u2098 halts on some input x}, and is also p.c. (remember, only the indicator needs to be total computable). Now observe what happens when we apply the indicator function to \u03c6\u2098:", "We want to determine if \u03c6\u2098 halts on x. If the indicator I(m, x) = I(\u03c6\u2098(x)) determines \u03c6\u2098(x) halts, then by definition of \u03c6\u2098, it must not halt (\u03c6\u2098\u2019s return value is undefined). If the indicator determines \u03c6\u2098 does not halt, \u03c6\u2098 must halt and return 1 by definition. There is no rule against recursive self-reference in this case since the definition of H is broad enough to include such programs. Since we reach a contradiction, we cannot assume that H is computable. \u25a1", "To show that H is c.e. is left as an exercise to the reader (hint: can we build a p.c. indicator function for H?).", "This is analogous to Russell\u2019s paradox in that our (naive) definition of the set H allows such \u03c6\u2098 where \u03c6\u2098 halts if and only if \u03c6\u2098 does not halt. The stipulation of all programs in the definition of H is what allows this contradiction to happen. The might seem like circular reasoning, and in an abstract way it is, but our definition of H admits such contradiction when we assume that H is computable. Therefore to preserve the consistency of H, we must reject it as being computable.", "Of course in real life, if we were careful to avoid writing programs similar to \u03c6\u2098, then our halting tester can achieve practical performance on realistic programs, only limited by time. The implications of the halting problem are certainly remarkable. Conceivably we can build a meta-system to see if a subsystem of halt checkers runs into the halting problem. But then, how many meta-systems do we need to cover the systems below them? The situation becomes like an infinite Matryoshka doll. It is fascinating that humans can have an awareness of this situation from outside of the infinite regress of these halt checking meta-systems, but can also switch into arbitrary levels of these systems at will, and reason about them from both the outside and the inside. Indeed, this is what some would consider a hallmark attribute of consciousness. It is this power that allowed the likes of Kurt G\u00f6del, Alan Turing, Alonzo Church and others to prove several profoundly deep and connected theorems concerning logic, computation and the foundations of math in the 1930's.", "It would be interesting to see if we can build a deterministic or even machine learning based halting tester that analyzes CPU instructions to determine with a certain probability if a program is doing useful calculations or has run into an un-useful infinite loop*. If you enjoyed this article please check out my other ones, and if you found any glaring errors or logical gaps, please let me know.", "*If you have venture capital and are interested in investing in the idea, please contact me.", "In anticipation of complaints of the above proof being \u2018hand-wavy\u2019 or too informal (after all, we took recursive self-reference in stride and didn\u2019t quite define how the indicator would check if \u03c6\u2098 halts or not), I will present a somewhat more rigorous proof below.", "We will use the intuitive definition of a Turing machine T as a machine that runs a deterministic procedure, meeting the following conditions:", "This machine T will compute the function I(m, x) if it is computable. A lack of the precise definition of T will not impede our understanding of the proof too much.", "Theorem 2 (Theorem 1 restated): I(m, x) is not computable.", "Proof: Once again, assume I(m, x) is computable. One of the things we do to avoid weird recursive self-reference is to feed the source code of \u03c6\u2098, S(m) = \u03c6\u2098 to I as input, i.e. I(\u03c6\u2098, \u03c6\u2098). In the Turing machine definition, programs \u03c6\u2098 and their corresponding source code are just unique and really large natural numbers. Mechanically, there is nothing wrong with feeding a really large natural number to some program in H even if that number is the unique \u2018source code number\u2019 of \u03c6\u2098 itself. There is no recursion where the function calls itself in this case.", "Now we define a p.c. function h (our candidate halt checker) in the following:", "Notice we have a different indicator function I\u2019. Our definition of computable only speaks of the existence of computable indicators, they need not all be the same but they should behave the same (consistency). The program that computes h(\u03c6) is in H. Thus I(m, x) would be able to check if h(\u03c6) halts. We feed the source of h(\u03c6) to I(m, x), i.e. I(h, h). Think of I(h, h) as our 1st level halting meta-checker.", "When h(\u03c6) is run on some program source code \u03c6, it returns zero if I\u2019(\u03c6, \u03c6) does not halt but I(h, h) returns a 1 indicating h halted, and diverges when I\u2019(\u03c6, \u03c6) does halt, while I(h, h) returns a 0 indicating divergence. By the definition of computable, we cannot have programs that both halt and diverge at the same time (consider h(\u03c6) a subprogram of I(h, h)). Therefore I(m, x) is not computable. \u25a1", "Your home for data science. A Medium publication sharing concepts, ideas and codes."], "all_outgoing_urls": [{"url": "https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F3579fdcd114&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---two_column_layout_nav----------------------------------", "anchor_text": "Open in app"}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://medium.com/?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---two_column_layout_nav-----------------------new_post_sidenav-----------", "anchor_text": "Write"}, {"url": "https://medium.com/search?source=---two_column_layout_nav----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign up"}, {"url": "https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&source=post_page---two_column_layout_nav-----------------------global_nav-----------", "anchor_text": "Sign In"}, {"url": "https://towardsdatascience.com/?source=post_page-----3579fdcd114--------------------------------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----3579fdcd114--------------------------------", "anchor_text": "Towards Data Science"}, {"url": "https://medium.com/@hhl60492?source=post_page-----3579fdcd114--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@hhl60492?source=post_page-----3579fdcd114--------------------------------", "anchor_text": "Haihan Lan"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F70a936a57085&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&user=Haihan+Lan&userId=70a936a57085&source=post_page-70a936a57085----3579fdcd114---------------------follow_byline-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3579fdcd114&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&source=--------------------------bookmark_header-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3579fdcd114&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&source=--------------------------bookmark_header-----------", "anchor_text": "Save"}, {"url": "https://en.wikipedia.org/wiki/Largest_known_prime_number", "anchor_text": "2^82589933 \u2212 1"}, {"url": "https://en.wikipedia.org/wiki/NaN", "anchor_text": "NaN"}, {"url": "https://en.wikipedia.org/wiki/Countable_set", "anchor_text": "is the same as the size of some subset of natural numbers N"}, {"url": "https://en.wikipedia.org/wiki/Turing_completeness", "anchor_text": "equivalent in the Turing sense"}, {"url": "https://en.wikipedia.org/wiki/Russell%27s_paradox", "anchor_text": "Russell\u2019s paradox"}, {"url": "https://en.wikipedia.org/wiki/Universal_set", "anchor_text": "discarded from the axioms of standard set theory"}, {"url": "https://en.wikipedia.org/wiki/Proof_by_contradiction", "anchor_text": "proof-by-contradiction"}, {"url": "https://en.wikipedia.org/wiki/Universal_approximation_theorem", "anchor_text": "somewhat like in machine learning"}, {"url": "https://en.wikipedia.org/wiki/Consistency", "anchor_text": "consistency"}, {"url": "https://towardsdatascience.com/custom-tensorflow-loss-functions-for-advanced-machine-learning-f13cdd1d188a", "anchor_text": "Tensorflow and custom loss functions"}, {"url": "https://towardsdatascience.com/decision-trees-and-random-forests-for-classification-and-regression-pt-1-dbb65a458df", "anchor_text": "Random forests"}, {"url": "https://towardsdatascience.com/the-softmax-function-neural-net-outputs-as-probabilities-and-ensemble-classifiers-9bd94d75932", "anchor_text": "Softmax classification"}, {"url": "https://towardsdatascience.com/analyzing-climate-patterns-with-self-organizing-maps-soms-8d4ef322705b", "anchor_text": "Climate analysis"}, {"url": "https://medium.com/@hhl60492/black-swans-and-hockey-riots-extreme-value-analysis-and-generalized-extreme-value-distributions-d4b4b84cd374", "anchor_text": "Hockey riots and extreme values"}, {"url": "https://medium.com/tag/programming?source=post_page-----3579fdcd114---------------programming-----------------", "anchor_text": "Programming"}, {"url": "https://medium.com/tag/computer-science?source=post_page-----3579fdcd114---------------computer_science-----------------", "anchor_text": "Computer Science"}, {"url": "https://medium.com/tag/computer-science-theory?source=post_page-----3579fdcd114---------------computer_science_theory-----------------", "anchor_text": "Computer Science Theory"}, {"url": "https://medium.com/tag/mathematics?source=post_page-----3579fdcd114---------------mathematics-----------------", "anchor_text": "Mathematics"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F3579fdcd114&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&user=Haihan+Lan&userId=70a936a57085&source=-----3579fdcd114---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F3579fdcd114&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&user=Haihan+Lan&userId=70a936a57085&source=-----3579fdcd114---------------------clap_footer-----------", "anchor_text": ""}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3579fdcd114&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&source=--------------------------bookmark_footer-----------", "anchor_text": ""}, {"url": "https://towardsdatascience.com/?source=post_page-----3579fdcd114--------------------------------", "anchor_text": "More from Towards Data Science"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fcollection%2Ftowards-data-science%2F3579fdcd114&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&collection=Towards+Data+Science&collectionId=7f60cf5620c9&source=post_page-----3579fdcd114---------------------follow_footer-----------", "anchor_text": "Follow"}, {"url": "https://towardsdatascience.com/?source=post_page-----3579fdcd114--------------------------------", "anchor_text": "Read more from Towards Data Science"}, {"url": "https://medium.com/?source=post_page-----3579fdcd114--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/about?autoplay=1&source=post_page-----3579fdcd114--------------------------------", "anchor_text": "About"}, {"url": "https://help.medium.com/hc/en-us?source=post_page-----3579fdcd114--------------------------------", "anchor_text": "Help"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----3579fdcd114--------------------------------", "anchor_text": "Terms"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----3579fdcd114--------------------------------", "anchor_text": "Privacy"}, {"url": "https://itunes.apple.com/app/medium-everyones-stories/id828256236?pt=698524&mt=8&ct=post_page&source=post_page-----3579fdcd114--------------------------------", "anchor_text": ""}, {"url": "https://play.google.com/store/apps/details?id=com.medium.reader&source=post_page-----3579fdcd114--------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@hhl60492?source=---two_column_layout_sidebar----------------------------------", "anchor_text": ""}, {"url": "https://medium.com/@hhl60492?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Haihan Lan"}, {"url": "https://medium.com/@hhl60492/followers?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "371 Followers"}, {"url": "https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F70a936a57085&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&user=Haihan+Lan&userId=70a936a57085&source=post_page-70a936a57085--two_column_layout_sidebar-----------------------follow_profile-----------", "anchor_text": "Follow"}, {"url": "https://medium.com/m/signin?actionUrl=%2F_%2Fapi%2Fsubscriptions%2Fnewsletters%2F376c65fc851a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-crash-course-on-proving-the-halting-problem-3579fdcd114&newsletterV3=70a936a57085&newsletterV3Id=376c65fc851a&user=Haihan+Lan&userId=70a936a57085&source=---two_column_layout_sidebar-----------------------subscribe_user-----------", "anchor_text": ""}, {"url": "https://help.medium.com/hc/en-us?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Help"}, {"url": "https://medium.statuspage.io/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Status"}, {"url": "https://about.medium.com/creators/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Writers"}, {"url": "https://blog.medium.com/?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Blog"}, {"url": "https://medium.com/jobs-at-medium/work-at-medium-959d1a85284e?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Careers"}, {"url": "https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Privacy"}, {"url": "https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Terms"}, {"url": "https://medium.com/about?autoplay=1&source=---two_column_layout_sidebar----------------------------------", "anchor_text": "About"}, {"url": "https://speechify.com/medium?source=---two_column_layout_sidebar----------------------------------", "anchor_text": "Text to speech"}]}, "scrape_status": {"code": "1"}}